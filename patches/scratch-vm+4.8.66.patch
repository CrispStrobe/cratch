diff --git a/node_modules/scratch-vm/src/blocks/scratch3_looks.js b/node_modules/scratch-vm/src/blocks/scratch3_looks.js
index 18e163a..9e13a87 100644
--- a/node_modules/scratch-vm/src/blocks/scratch3_looks.js
+++ b/node_modules/scratch-vm/src/blocks/scratch3_looks.js
@@ -35,6 +35,7 @@ class Scratch3LooksBlocks {
 
         // Enable other blocks to use bubbles like ask/answer
         this.runtime.on(Scratch3LooksBlocks.SAY_OR_THINK, this._updateBubble);
+        this.runtime.on(Scratch3LooksBlocks.SAY_OR_THINK_MORE, this._updateBubblemore);
     }
 
     /**
@@ -278,6 +279,14 @@ class Scratch3LooksBlocks {
         this._renderBubble(target);
     }
 
+        _updateBubblemore (target, type, text) {
+        const bubbleState = this._getBubbleState(target);
+        bubbleState.type = type;
+        bubbleState.text += this._formatBubbleText(text);
+        bubbleState.usageId = uid();
+        this._renderBubble(target);
+    }
+
     /**
      * Retrieve the block primitives implemented by this package.
      * @return {object.<string, Function>} Mapping of opcode to Function.
@@ -285,8 +294,10 @@ class Scratch3LooksBlocks {
     getPrimitives () {
         return {
             looks_say: this.say,
+            looks_say_more: this.say_more,
             looks_sayforsecs: this.sayforsecs,
             looks_think: this.think,
+            looks_think_more: this.think_more,
             looks_thinkforsecs: this.thinkforsecs,
             looks_show: this.show,
             looks_hide: this.hide,
@@ -332,6 +343,11 @@ class Scratch3LooksBlocks {
         this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'say', args.MESSAGE);
     }
 
+    say_more (args, util) {
+        // @TODO in 2.0 calling say/think resets the right/left bias of the bubble
+    this._updateBubblemore(util.target, 'say', args.MESSAGE);
+    }    
+
     sayforsecs (args, util) {
         this.say(args, util);
         const target = util.target;
@@ -352,6 +368,10 @@ class Scratch3LooksBlocks {
         this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'think', args.MESSAGE);
     }
 
+    think_more (args, util) {
+        this._updateBubblemore(util.target, 'think', args.MESSAGE);
+    }
+
     thinkforsecs (args, util) {
         this.think(args, util);
         const target = util.target;
diff --git a/node_modules/scratch-vm/src/extension-support/extension-manager.js b/node_modules/scratch-vm/src/extension-support/extension-manager.js
index 94ce3b1..33cf365 100644
--- a/node_modules/scratch-vm/src/extension-support/extension-manager.js
+++ b/node_modules/scratch-vm/src/extension-support/extension-manager.js
@@ -19,11 +19,20 @@ const builtinExtensions = {
     microbit: () => require('../extensions/scratch3_microbit'),
     text2speech: () => require('../extensions/scratch3_text2speech'),
     translate: () => require('../extensions/scratch3_translate'),
-    videoSensing: () => require('../extensions/scratch3_video_sensing'),
+    //videoSensing: () => require('../extensions/scratch3_video_sensing'),
     ev3: () => require('../extensions/scratch3_ev3'),
     makeymakey: () => require('../extensions/scratch3_makeymakey'),
     boost: () => require('../extensions/scratch3_boost'),
-    gdxfor: () => require('../extensions/scratch3_gdx_for')
+    gdxfor: () => require('../extensions/scratch3_gdx_for'),
+    planetemaths: () => require('../extensions/scratch3_pm'),
+    bodydetection:() => require('../extensions/scratch3_bodydetection'),
+    qrcode:() => require('../extensions/scratch3_qrcode'),
+    ml:()   => require('../extensions/scratch3_ml'),
+    handpose:()   => require('../extensions/scratch3_handpose'),
+    facemesh:()   => require('../extensions/scratch3_facemesh'),
+    microbitMore:() => require('../extensions/microbitMore'),
+    tm:() => require('../extensions/scratch3_tm'),
+    text: () => require('../extensions/scratch3_text')
 };
 
 /**
diff --git a/node_modules/scratch-vm/src/extensions/microbitMore/ble-web.js b/node_modules/scratch-vm/src/extensions/microbitMore/ble-web.js
new file mode 100644
index 0000000..9d1531a
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/microbitMore/ble-web.js
@@ -0,0 +1,218 @@
+const {Buffer} = require('buffer');
+const log = require('../../util/log');
+
+const arrayBufferToBase64 = arrayBuffer => Buffer.from(arrayBuffer).toString('base64');
+const base64ToUint8Array = base64 => Buffer.from(base64, 'base64');
+
+class WebBLE {
+
+    /**
+     * A BLE peripheral object.  It handles connecting, over Web Bluetooth API, to
+     * BLE peripherals, and reading and writing data to them.
+     * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
+     * @param {string} extensionId - the id of the extension using this object.
+     * @param {object} peripheralOptions - the list of options for peripheral discovery.
+     * @param {object} connectCallback - a callback for connection.
+     * @param {object} resetCallback - a callback for resetting extension state.
+     */
+    constructor (runtime, extensionId, peripheralOptions, connectCallback, resetCallback = null) {
+        /**
+         * Remote device which have been connected.
+         * @type {BluetoothDevice}
+         */
+        this._device = null;
+
+        /**
+         * Remote GATT server
+         * @type {BluetoothRemoteGATTServer}
+         */
+        this._server = null;
+
+        this._connectCallback = connectCallback;
+        this._disconnected = true;
+        this._characteristicDidChangeCallback = null;
+        this._resetCallback = resetCallback;
+        this._extensionId = extensionId;
+        this._peripheralOptions = peripheralOptions;
+        this._runtime = runtime;
+
+        this.requestPeripheral();
+    }
+
+    /**
+     * Request connection to the peripheral.
+     * Request user to choose a device, and then connect it automatically.
+     */
+    requestPeripheral () {
+        if (this._server) {
+            this.disconnect();
+        }
+        navigator.bluetooth.requestDevice(this._peripheralOptions)
+            .then(device => {
+                this._device = device;
+                log.debug(`device=${this._device.name}`);
+                this._runtime.connectPeripheral(this._extensionId, this._device.id);
+            })
+            .catch(e => {
+                this._handleRequestError(e);
+            });
+    }
+
+    /**
+     * Try connecting to the GATT server of the device, and then call the connect
+     * callback when connection is successful.
+     */
+    connectPeripheral (/* id */) {
+        if (!this._device) {
+            throw new Error('device is not chosen');
+        }
+        this._device.gatt.connect()
+            .then(gattServer => {
+                log.debug(`GATTServer is connected`);
+                this._server = gattServer;
+                this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);
+                this._disconnected = false;
+                this._connectCallback();
+                this._device.addEventListener('gattserverdisconnected',
+                    event => {
+                        this.onDisconnected(event);
+                    });
+            });
+    }
+
+    /**
+     * Disconnect from the device and clean up.
+     * Then emit the connection state by the runtime.
+     */
+    disconnect () {
+        if (!this._server) return;
+        this._server.disconnect();
+        this._disconnected = true;
+        this._server = null;
+        this._device = null;
+        this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
+    }
+
+    /**
+     * @return {bool} whether the peripheral is connected.
+     */
+    isConnected () {
+        if (!this._server) return false;
+        return this._server.connected;
+    }
+
+    /**
+     * Start receiving notifications from the specified ble service.
+     * @param {number} serviceId - the ble service to read.
+     * @param {number} characteristicId - the ble characteristic to get notifications from.
+     * @param {object} onCharacteristicChanged - callback for characteristic change notifications
+     *  like function(base64message).
+     * @return {Promise} - a promise from the remote startNotifications request.
+     */
+    startNotifications (serviceId, characteristicId, onCharacteristicChanged = null) {
+        return this._server.getPrimaryService(serviceId)
+            .then(service => service.getCharacteristic(characteristicId))
+            .then(characteristic => {
+                characteristic.addEventListener('characteristicvaluechanged',
+                    event => {
+                        const dataView = event.target.value;
+                        onCharacteristicChanged(arrayBufferToBase64(dataView.buffer));
+                    });
+                characteristic.startNotifications();
+            });
+    }
+
+    /**
+     * Read from the specified ble service.
+     * @param {number} serviceId - the ble service to read.
+     * @param {number} characteristicId - the ble characteristic to read.
+     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
+     * @param {object} onCharacteristicChanged - callback for characteristic change notifications
+     *  like function(base64message).
+     * @return {Promise} - a promise from the remote read request which resolve {message: base64string}.
+     */
+    read (serviceId, characteristicId, optStartNotifications = false, onCharacteristicChanged = null) {
+        return this._server.getPrimaryService(serviceId)
+            .then(service => service.getCharacteristic(characteristicId))
+            .then(characteristic => {
+                if (optStartNotifications) {
+                    this.startNotifications(serviceId, characteristicId, onCharacteristicChanged);
+                }
+                return characteristic.readValue();
+            })
+            .then(dataView => ({
+                message: arrayBufferToBase64(dataView.buffer)
+            }));
+    }
+
+    /**
+     * Write data to the specified ble service.
+     * @param {number} serviceId - the ble service to write.
+     * @param {number} characteristicId - the ble characteristic to write.
+     * @param {string} message - the message to send.
+     * @param {string} encoding - the message encoding type.
+     * @param {boolean} withResponse - if true, resolve after peripheral's response.
+     * @return {Promise} - a promise from the remote send request.
+     */
+    // eslint-disable-next-line no-unused-vars
+    write (serviceId, characteristicId, message, encoding = null, withResponse = null) {
+        const value = encoding === 'base64' ? base64ToUint8Array(message) : message;
+        return this._server.getPrimaryService(serviceId)
+            .then(service => service.getCharacteristic(characteristicId))
+            .then(characteristic => {
+                if (withResponse && characteristic.writeValueWithResponse) {
+                    return characteristic.writeValueWithResponse(value);
+                }
+                if (characteristic.writeValueWithoutResponse) {
+                    return characteristic.writeValueWithoutResponse(value);
+                }
+                return characteristic.writeValue(value);
+            });
+    }
+
+    /**
+     * Handle an error resulting from losing connection to a peripheral.
+     *
+     * This could be due to:
+     * - battery depletion
+     * - going out of bluetooth range
+     * - being powered down
+     *
+     * Disconnect the device, and if the extension using this object has a
+     * reset callback, call it. Finally, emit an error to the runtime.
+     */
+    handleDisconnectError (/* e */) {
+        // log.error(`BLE error: ${JSON.stringify(e)}`);
+
+        if (this._disconnected) return;
+
+        this.disconnect();
+
+        if (this._resetCallback) {
+            this._resetCallback();
+        }
+
+        this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
+            message: `Scratch lost connection to`,
+            extensionId: this._extensionId
+        });
+    }
+
+    _handleRequestError (/* e */) {
+        // log.error(`BLE error: ${JSON.stringify(e)}`);
+
+        this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
+            message: `Scratch lost connection to`,
+            extensionId: this._extensionId
+        });
+    }
+
+    /**
+     * Called when disconnected by the device.
+     */
+    onDisconnected (/* event */) {
+        this.handleDisconnectError(new Error('device disconnected'));
+    }
+}
+
+module.exports = WebBLE;
diff --git a/node_modules/scratch-vm/src/extensions/microbitMore/ble.js b/node_modules/scratch-vm/src/extensions/microbitMore/ble.js
new file mode 100644
index 0000000..fbf054b
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/microbitMore/ble.js
@@ -0,0 +1,4 @@
+const BLE = require('../../io/ble');
+const WebBLE = require('./ble-web');
+
+module.exports = navigator.bluetooth ? WebBLE : BLE;
diff --git a/node_modules/scratch-vm/src/extensions/microbitMore/index.js b/node_modules/scratch-vm/src/extensions/microbitMore/index.js
new file mode 100644
index 0000000..302be1d
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/microbitMore/index.js
@@ -0,0 +1,3688 @@
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const log = require('../../util/log');
+const cast = require('../../util/cast');
+const BLE = require('./ble');
+const {Buffer} = require('buffer');
+
+const WebSerial = require('./serial-web');
+
+const uint8ArrayToBase64 = array => Buffer.from(array).toString('base64');
+const base64ToUint8Array = base64 => Buffer.from(base64, 'base64');
+
+
+let formatMessage = require('format-message');
+
+const EXTENSION_ID = 'microbitMore';
+
+/**
+ * URL to get this extension as a module.
+ * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
+ * @type {string}
+ */
+let extensionURL = 'https://microbit-more.github.io/dist/microbitMore.mjs';
+
+/**
+ * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
+ * @type {string}
+ */
+// eslint-disable-next-line max-len
+const blockIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAErmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjQwIgogICBleGlmOlBpeGVsWURpbWVuc2lvbj0iNDAiCiAgIGV4aWY6Q29sb3JTcGFjZT0iMSIKICAgdGlmZjpJbWFnZVdpZHRoPSI0MCIKICAgdGlmZjpJbWFnZUxlbmd0aD0iNDAiCiAgIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiCiAgIHRpZmY6WFJlc29sdXRpb249IjcyLjAiCiAgIHRpZmY6WVJlc29sdXRpb249IjcyLjAiCiAgIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiCiAgIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjEtMDMtMTBUMTE6NTE6MzgrMDk6MDAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjEtMDMtMTBUMTE6NTE6MzgrMDk6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJwcm9kdWNlZCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iRGVzaWduZXIgaVBhZCAxLjkuMSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyMS0wMy0xMFQxMTo1MTozOCswOTowMCIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+CHKf4QAAAYJpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHLS0JBFIc/tehlFBTRooWEtdKwAqtNkBIWSIgZ9NrozUfg43KvEdE2aCsURG16LeovqG3QOgiKIoh2QeuiNiW3czUwIs9w5nzzmzmHmTNgjaSVjF7jgUw2r4UDPsfs3Lyj7hkbDXQwhD2q6OpYKBSkqn3cYTHjjdusVf3cv9a0FNcVsNQLjyqqlheeEA6u5lWTt4XblVR0SfhU2KXJBYVvTT1W5heTk2X+MlmLhP1gbRV2JH9x7BcrKS0jLC/HmUmvKD/3MV9ij2dnpiV2i3ehEyaADweTjOPHSz8jMntxM0CfrKiS7ynlT5GTXEVmlTU0lkmSIo9L1BWpHpeYED0uI82a2f+/fdUTgwPl6nYf1D4ZxlsP1G1BsWAYn4eGUTwC2yNcZCv5uQMYfhe9UNGc+9CyAWeXFS22A+eb0PmgRrVoSbKJWxMJeD2B5jlou4bGhXLPfvY5vofIunzVFezuQa+cb1n8BlPUZ91ko37dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAJXElEQVRYhe2XW2wc5RXHf+eb2dmb144dx0kcQi4QTJprMRcnESni2halacMtUIEUib6lfejtAREh8UBRLyqiVRHqQ9UbEpSqVUGiShuo2iQ4QI0Fde4JTpM4dmLHu+u9zc7Md/qwaycbh5KUPuYvjXZGc76Z35zbdxau6Iqu6L9KPu0DXnjhZ9e3NGd+MnL6dKei2Mgax3HsjBktQ8Vi6Ttbt36j//8C+OKT6bZ0Un/X1mxvsoo532h8wkQnRpxoxbWBB2AtumfAq/QsryZf/GOmsP94S8pai4gYEXGstYExouVyJaeq0WXwRMAfgG1DQ0MVAHfyztVzor2f76nMvnDFyFmHzdtm8q1HJrh3bYUwErb+aAbzO6KmXR/E6TsQS0PpwmWJ+m/zZcBN6tvArUBPA+Ctq/xpcP8ecdi8rZ1jww4AlarwtWdbefO9BOmEUqx86gz5ON08eTIFGHMbLQ4dd3lo20xGztbgJkrCV5+aSe+ABzANrq3Z0t4S1W0Np8acTwMo0078t0W9mALw4ZEYjzw1k7P5c6k46bGG5AQs8OX1RZYujDiTdQGhJQN+YPjpK/GL2l+KhoaGBM7z4KTe2evx2NMzmSg1emgSbtoCYN2qFK+8meDDQ1X8QFmzOs6X1hky8TK+32gbXgbkNMC/9cV5/HttlP3puTUJ5wKuKg4QihABh443cfstLtct9ECE1maXIIoR+WXiQIsnxJLNjOZylw05RfL7Hyb1m8/PIAg/Hi4GpK2lCfDqLyoABWO4an6cjo44YCgUQg4fKhCPlIwqLSlDKXAYDwJ8YyhfAuRkiKdorprXqVYvbmzqQGlVZqmy1Fp6wpB/Og4DjsNEPE4+CAhEUBFca8m4Li1BwKIoYl0YMmAMfa7LKFA2htIlAk7l8MfBnQ8ZVyUJ3FGpsKGpiUcLBbpF+PrDD5NS5a61a3n0/vvJqPLYhg3csWABW4pFNqbTfKFSoZlag7ywcABWXBOw+c4SC+aE0977iZoMsRGhOYpIWkshlyMdRWwaHye3YwfzVBk5cIAj775Lhyr53l5u27ePtjCkmM+TsJZ0GGLqz7vwxTd0VZk/O+L4SGMZNlyJCKqKSC3yU+eqU8aiiqhi6oXSYi13Hj3KcWCoWiVZLtMaRdw7OEgqCBDA1Ne4QEKViQvgRIRcweHXf27CamMo3fONMpkM3d3dlEq1rcvzPHp7e4mCoGasiuu6uCKkk0nOBAFJEdo9jwezWd5pbyfd0cGi/fvpzGTwYzHOiDArmSQWBDiOg0pjL+3u7iaVSnHKr7J2bYzh4WEOHz7M6tWrpb+/Xw3A6tWrBSCVStHe3s7o6CjZbJa2tjZc18WpezQSwbGWCBjP5cg5Dm/G45zM5XCt5Ya+PhZt305zFDE2McFbrsvpWIxsPk9oTM3znCsOEWHWrFkYYxgcHCQejzNr1ixEBKmHcepjVDVS1aBQKLBz50527dpFEARTYTd1D1YBBZoyGUJVhuJxPurpoWQMbZ7HvHicCBhYtowzHR1UrSWVToMqoT1Xt5NpFIYhfX199Pf3s2/fPqIoAihfLMSOMcZpbm6mu7sbz/NIJBLnHqbK+fWlIgTGkHUcxufOZWdTE1uApDG80dRES2cnhSNH8EUQU/eDMUzOXqoKIniex8qVKzHG0NXVhV/bepINgP39/Tpv3jyKxSLZbJYlS5YAkM/nCcNzWJEITo2YXC6H9TwqQcCrO3bgOg7ftxYHOBuLEb79NjOA6+u26tSGBysy5RVVZWxsjHQ6zapVqzDGcPbs2Rp8LVDnPKiqTExMsH37du68qcJf301MgTmq2PpvVA9Ne1sbB4tFiMfZ9MAD/Pyll+js6WFORwcHX3+dTRs3cnpgALt3L21tbYzm82g9TUI5t1vt2bNnKtxTngXef/99hQvakarylc+VuOeWytT15ILJ3qWqoErJ91FVSkHA4WPHKBvD4ZER9p48Sd4Yjp48yej4OJEqlbqt1j/0Qk2+Q3X6btHQBzMpJZ20bN8Tn2YcAn59OIhU8YMAay2+tRwaHMQHTmez5HyfCnDo2DGaSqUp26juffsJkBeqwYMTJeHXb6TZ/k6iwcjWD1QJRAiNobW1laoxOOk0Gx96iArw2TVruGfDBqrA3Rs3sqCri6rj0NraSmQMvgiBXN4UfrHx7qKyQEmELLDL80iXy+z2PIbLZX7z8ssA7Nq1i2QyiQX+9NprSD7PhONwdaXCHs+jIEKV/3Hc6uzs1GRcWblEw3IFBj4yblTvCQZIuLB5fUxTEka9uyO3WoQqkLWWguvieLDhrphai339rdAJK0qTtbRQ7xkerF/naDXm2ld2hk6+ci7Urgv33R7TdEp49S9VyRcvMs0ArFmBn/SCxc2p4MYbl+rUR1pg010xzefKmxYNZpfdvN4Nh4BTIhRdlyrwwBc9e2K4vD4MKtdtvN2JQqBkDKdFGALW3WZscahyT2okf8N9dzn2fA8+fE9MrYaPp7zKZ7Zs9Br+pjYAdl3j6BOPjZ08NR59tHBe47zRvcKo1fLbm/9RHLyuy9WSMQQi+PWQXX+N4YMDlXef+9XI0SWLHA2pebgsQskYFi9JaNdAfvfWQ+P7Fs93Gyri+kWO/mv/6G+feG54//w5puGeAGTf6/H2HhzyR7MGvxKFXkyNl8yYdDxid38VEVizyiOTVg0DV11XzI53fMIIUDBGWLtKiMcCDdXFWld291eJIgUEY6BneYx4LFA1ilVPdvZViVQQDDcvC0gmRIPQs81p65SrkDGH3eUPErkAJ472hk2JTob9kKTnu2ot1q+QSFqaUx6OY6hWAqwXyeFjoSyc59GaCqhGBlWIGYuNBEskY1klk0nQkrJ1wBDH8VAtcWAwkLGs4aYVHjNSFUIbQ4gYzzp8MBxIoWyd665OsPQaA8F5O8nyB7F//0UUQDU2t7WKqnI6KxgsYkPEuKBK3KmycLZFbC1NRAVsFYwLeKhWaE66qPq1GdLWxjQxAaoei+f6LJ6r9fE9RNQHNWQSworFIUFk8GIFxrItwW1bajU01WaMY67t3x/8svcD5zlrZfa184MfGCOJU6NaEomw1jPvH0w9i+rQzJbw+eOnqtbWIogQIIJMlJPfRUysKVF95sRI1aoFkdphcSVfSD4ZWbS9JXjmxHBgVQWRiLgXc89OpH4Munf2TPv07JlyN1d0RVd0afoP68aPxQiA3SAAAAAASUVORK5CYII=';
+
+/**
+ * Enum for version of the hardware.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreHardwareVersion =
+{
+    MICROBIT_V1: 1,
+    MICROBIT_V2: 2
+};
+
+/**
+ * Communication route between Scratch and micro:bit
+ *
+ */
+const CommunicationRoute = {
+    BLE: 0,
+    SERIAL: 1
+};
+
+/**
+ * Enum for micro:bit BLE command protocol.
+ * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
+ * @readonly
+ * @enum {number}
+ */
+const BLECommand = {
+    CMD_CONFIG: 0x00,
+    CMD_PIN: 0x01,
+    CMD_DISPLAY: 0x02,
+    CMD_AUDIO: 0x03,
+    CMD_DATA: 0x04
+};
+
+/**
+ * Enum for command about gpio pins.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMorePinCommand =
+{
+    SET_OUTPUT: 0x01,
+    SET_PWM: 0x02,
+    SET_SERVO: 0x03,
+    SET_PULL: 0x04,
+    SET_EVENT: 0x05
+};
+
+/**
+ * Enum for command about gpio pins.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreDisplayCommand =
+{
+    CLEAR: 0x00,
+    TEXT: 0x01,
+    PIXELS_0: 0x02,
+    PIXELS_1: 0x03
+};
+
+/**
+ * Enum for name of pull mode.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMorePullModeName = {
+    NONE: 'NONE',
+    DOWN: 'DOWN',
+    UP: 'UP'
+};
+
+/**
+ * Enum for ID of pull mode.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMorePullModeID = {
+    NONE: 0,
+    DOWN: 1,
+    UP: 2
+};
+
+/**
+ * Enum for data format.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreDataFormat = {
+    CONFIG: 0x10, // not used at this version
+    PIN_EVENT: 0x11,
+    ACTION_EVENT: 0x12,
+    DATA_NUMBER: 0x13,
+    DATA_TEXT: 0x14
+};
+
+/**
+ * Enum for action event type.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreActionEvent = {
+    BUTTON: 0x01,
+    GESTURE: 0x02
+};
+
+/**
+ * Enum for ID of pin-mode
+ * @readonly
+ * @enum {string}
+ */
+const MbitMorePinMode = {
+    INPUT: 'INPUT',
+    OUTPUT: 'OUTPUT',
+    PWM: 'PWM',
+    SERVO: 'SERVO',
+    TOUCH: 'TOUCH'
+};
+
+/**
+ * Enum for ID of buttons
+ * @readonly
+ * @enum {string}
+ */
+const MbitMoreButtonName = {
+    P0: 'P0',
+    P1: 'P1',
+    P2: 'P2',
+    A: 'A',
+    B: 'B',
+    LOGO: 'LOGO'
+};
+
+/**
+ * Enum for componentID of buttons
+ * @readonly
+ * @enum {string}
+ */
+const MbitMoreButtonID = {
+    1: 'A',
+    2: 'B',
+    100: 'P0',
+    101: 'P1',
+    102: 'P2',
+    121: 'LOGO'
+};
+
+/**
+ * Enum for index of pin for buttons
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreButtonPinIndex = {
+    P0: 0,
+    P1: 1,
+    P2: 2
+};
+
+/**
+ * Enum for index in data of button state
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreButtonStateIndex = {
+    P0: 0,
+    P1: 1,
+    P2: 2,
+    A: 3,
+    B: 4,
+    LOGO: 5
+};
+
+/**
+ * Enum for name of event from button
+ * @readonly
+ * @enum {string}
+ */
+const MbitMoreButtonEventName = {
+    DOWN: 'DOWN',
+    UP: 'UP',
+    CLICK: 'CLICK',
+    LONG_CLICK: 'LONG_CLICK',
+    HOLD: 'HOLD',
+    DOUBLE_CLICK: 'DOUBLE_CLICK'
+};
+
+/**
+ * Enum for ID of event from button
+ * @readonly
+ * @enum {string}
+ */
+const MbitMoreButtonEventID = {
+    1: 'DOWN',
+    2: 'UP',
+    3: 'CLICK',
+    4: 'LONG_CLICK',
+    5: 'HOLD',
+    6: 'DOUBLE_CLICK'
+};
+
+/**
+ * Enum for name of gesture.
+ * @readonly
+ * @enum {string}
+ */
+const MbitMoreGestureName =
+{
+    TILT_UP: 'TILT_UP',
+    TILT_DOWN: 'TILT_DOWN',
+    TILT_LEFT: 'TILT_LEFT',
+    TILT_RIGHT: 'TILT_RIGHT',
+    FACE_UP: 'FACE_UP',
+    FACE_DOWN: 'FACE_DOWN',
+    FREEFALL: 'FREEFALL',
+    G3: 'G3',
+    G6: 'G6',
+    G8: 'G8',
+    SHAKE: 'SHAKE'
+};
+
+/**
+ * Enum for ID of gesture.
+ * @readonly
+ * @enum {string}
+ */
+const MbitMoreGestureID =
+{
+    1: 'TILT_UP',
+    2: 'TILT_DOWN',
+    3: 'TILT_LEFT',
+    4: 'TILT_RIGHT',
+    5: 'FACE_UP',
+    6: 'FACE_DOWN',
+    7: 'FREEFALL',
+    8: 'G3',
+    9: 'G6',
+    10: 'G8',
+    11: 'SHAKE'
+};
+
+/**
+ * Enum for event type in the micro:bit runtime.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMorePinEventType = {
+    NONE: 0,
+    ON_EDGE: 1,
+    ON_PULSE: 2,
+    ON_TOUCH: 3
+};
+
+/**
+ * Enum for event value in the micro:bit runtime.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMorePinEvent = {
+    RISE: 2,
+    FALL: 3,
+    PULSE_HIGH: 4,
+    PULSE_LOW: 5
+};
+
+/**
+ * Enum for data type of data-sending.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreSendingDataType = {
+    NUMBER: 1,
+    TEXT: 2
+};
+
+/**
+ * Enum for sub-command about configurations.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreConfig =
+{
+    MIC: 0x01,
+    TOUCH: 0x02
+};
+
+/**
+ * Enum for sub-command about audio.
+ * @readonly
+ * @enum {number}
+ */
+const MbitMoreAudioCommand =
+{
+    STOP_TONE: 0x00,
+    PLAY_TONE: 0x01
+};
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the BLE socket
+ * that data has stopped coming from the peripheral.
+ */
+const BLETimeout = 4500;
+
+
+/**
+ * A string to report to the BLE socket when the micro:bit has stopped receiving data.
+ * @type {string}
+ */
+const BLEDataStoppedError = 'micro:bit extension stopped receiving data';
+
+const MM_SERVICE = {
+    ID: '0b50f3e4-607f-4151-9091-7d008d6ffc5c',
+    COMMAND_CH: '0b500100-607f-4151-9091-7d008d6ffc5c',
+    STATE_CH: '0b500101-607f-4151-9091-7d008d6ffc5c',
+    MOTION_CH: '0b500102-607f-4151-9091-7d008d6ffc5c',
+    PIN_EVENT_CH: '0b500110-607f-4151-9091-7d008d6ffc5c',
+    ACTION_EVENT_CH: '0b500111-607f-4151-9091-7d008d6ffc5c',
+    ANALOG_IN_CH: [
+        '0b500120-607f-4151-9091-7d008d6ffc5c',
+        '0b500121-607f-4151-9091-7d008d6ffc5c',
+        '0b500122-607f-4151-9091-7d008d6ffc5c'
+    ],
+    MESSAGE_CH: '0b500130-607f-4151-9091-7d008d6ffc5c'
+};
+
+/**
+ * Enum for axis menu options.
+ * @readonly
+ * @enum {string}
+ */
+const AxisSymbol = {
+    X: 'x',
+    Y: 'y',
+    Z: 'z',
+    Absolute: 'absolute'
+};
+
+/**
+ * The unit-value of the gravitational acceleration from Micro:bit.
+ * @type {number}
+ */
+const G = 1024;
+
+/**
+ * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
+ */
+class MbitMore {
+
+    /**
+     * Construct a MicroBit communication object.
+     * @param {Runtime} runtime - the Scratch 3.0 runtime
+     * @param {string} extensionId - the id of the extension
+     */
+    constructor (runtime, extensionId) {
+
+        /**
+         * The Scratch 3.0 runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this.runtime = runtime;
+
+        /**
+         * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
+         * @type {BLE}
+         * @private
+         */
+        this._ble = null;
+        this.runtime.registerPeripheralExtension(extensionId, this);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._extensionId = extensionId;
+
+        this.digitalLevel = {};
+        this.lightLevel = 0;
+        this.temperature = 0;
+        this.soundLevel = 0;
+        this.pitch = 0;
+        this.roll = 0;
+        this.acceleration = {
+            x: 0,
+            y: 0,
+            z: 0
+        };
+        this.compassHeading = 0;
+        this.magneticForce = {
+            x: 0,
+            y: 0,
+            z: 0
+        };
+
+        this.buttonState = {};
+
+        /**
+         * The most recently received button events for each buttons.
+         * @type {Object} - Store of buttons which has events.
+         * @private
+         */
+        this.buttonEvents = {};
+        Object.keys(MbitMoreButtonStateIndex).forEach(name => {
+            this.buttonEvents[name] = {};
+        });
+
+        /**
+         * The most recently received gesture events.
+         * @type {Object <number, number>} - Store of gesture ID and timestamp.
+         * @private
+         */
+        this.gestureEvents = {};
+
+
+        /**
+         * The most recently received events for each pin.
+         * @type {Object} - Store of pins which has events.
+         * @private
+         */
+        this._pinEvents = {};
+
+        /**
+         * The most recently received data from micro:bit.
+         * @type {Object} - Store of received data
+         * @private
+         */
+        this.receivedData = {};
+
+        this.analogIn = [0, 1, 2];
+        this.analogValue = [];
+        this.analogIn.forEach(pinIndex => {
+            this.analogValue[pinIndex] = 0;
+        });
+
+        this.gpio = [
+            0, 1, 2,
+            8,
+            12, 13, 14, 15, 16
+        ];
+        this.gpio.forEach(pinIndex => {
+            this.digitalLevel[pinIndex] = 0;
+        });
+
+        /**
+         * Interval ID for data reading timeout.
+         * @type {number}
+         * @private
+         */
+        this._timeoutID = null;
+
+        /**
+         * A flag that is true while we are busy sending data to the BLE socket.
+         * @type {boolean}
+         * @private
+         */
+        this.bleBusy = true;
+
+        /**
+         * ID for a timeout which is used to clear the busy flag if it has been
+         * true for a long time.
+         */
+        this.bleBusyTimeoutID = null;
+
+        this.onDisconnect = this.onDisconnect.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this.onNotify = this.onNotify.bind(this);
+
+        this.stopTone = this.stopTone.bind(this);
+        if (this.runtime) {
+            this.runtime.on('PROJECT_STOP_ALL', this.stopTone);
+        }
+
+        this.analogInUpdateInterval = 100; // milli-seconds
+        this.analogInLastUpdated = [Date.now(), Date.now(), Date.now()];
+
+        /**
+         * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
+         * @type {number}
+         */
+        this.sendCommandInterval = 30;
+
+        this.initConfig();
+
+        // keyboard state monitor
+        this.keyState = {};
+        document.body.addEventListener('keydown', e => {
+            this.keyState[e.code] = {
+                key: e.key,
+                code: e.code,
+                alt: e.altKey,
+                ctrl: e.ctrlKey,
+                meta: e.metaKey,
+                shift: e.shiftKey
+            };
+        });
+        document.body.addEventListener('keyup', e => {
+            delete this.keyState[e.code];
+        });
+    }
+
+    /**
+     * Initialize configuration of the micro:bit.
+     */
+    initConfig () {
+        this.config = {};
+        this.config.mic = false;
+        this.config.pinMode = {};
+    }
+
+    /**
+     * Start updating process for micro:bit state and motion.
+     */
+    startUpdater () {
+        if (this.updater) {
+            clearTimeout(this.updater);
+        }
+        if (this.bleAccessWaiting) {
+            this.updater = setTimeout(() => this.startUpdater(), 0);
+            return;
+        }
+        this.updateState()
+            .then(() => this.updateMotion())
+            .finally(() => {
+                this.updater = setTimeout(
+                    () => this.startUpdater(),
+                    this.microbitUpdateInterval
+                );
+            });
+    }
+
+    /**
+     * Stop updating process for micro:bit state and motion.
+     */
+    stopUpdater () {
+        clearTimeout(this.updater);
+    }
+
+    /**
+     * @param {string} text - the text to display.
+     * @param {number} delay - The time to delay between characters, in milliseconds.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
+     */
+    displayText (text, delay, util) {
+        const textLength = Math.min(18, text.length);
+        const textData = new Uint8Array(textLength + 1);
+        for (let i = 0; i < textLength; i++) {
+            textData[i] = text.charCodeAt(i);
+        }
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_DISPLAY << 5) | MbitMoreDisplayCommand.TEXT,
+                message: new Uint8Array([
+                    Math.min(255, (Math.max(0, delay) / 10)),
+                    ...textData
+                ])
+            }],
+            util
+        );
+    }
+
+    /**
+     * Send display pixcels command to micro:bit.
+     * @param {Array.<Array.<number>>} matrix - pattern to display.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
+     */
+    displayPixels (matrix, util) {
+        const cmdSet = [
+            {
+                id: (BLECommand.CMD_DISPLAY << 5) | MbitMoreDisplayCommand.PIXELS_0,
+                message: new Uint8Array([
+                    ...matrix[0],
+                    ...matrix[1],
+                    ...matrix[2]
+                ])
+            },
+            {
+                id: (BLECommand.CMD_DISPLAY << 5) | MbitMoreDisplayCommand.PIXELS_1,
+                message: new Uint8Array([
+                    ...matrix[3],
+                    ...matrix[4]
+                ])
+            }
+        ];
+        return this.sendCommandSet(cmdSet, util);
+    }
+
+    /**
+     * Set pull mode to the pin.
+     * @param {number} pinIndex - index of the pin
+     * @param {MbitMorePullModeID} pullMode - pull mode to set
+     * @param {BlockUtility} util - utility object provided from the runtime
+     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
+     */
+    setPullMode (pinIndex, pullMode, util) {
+        this.config.pinMode[pinIndex] = MbitMorePinMode.INPUT;
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_PIN << 5) | MbitMorePinCommand.SET_PULL,
+                message: new Uint8Array([
+                    pinIndex,
+                    pullMode
+                ])
+            }],
+            util
+        );
+    }
+
+    /**
+     * Set pin to digital output mode on the level.
+     * @param {number} pinIndex - Index of pin.
+     * @param {boolean} level - Value in digital (true = High)
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
+     */
+    setPinOutput (pinIndex, level, util) {
+        this.config.pinMode[pinIndex] = MbitMorePinMode.OUTPUT;
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_PIN << 5) | MbitMorePinCommand.SET_OUTPUT,
+                message: new Uint8Array(
+                    [
+                        pinIndex,
+                        (level ? 1 : 0)
+                    ]
+                )
+            }],
+            util
+        );
+    }
+
+    /**
+     * Set the pin to PWM mode on the level.
+     * @param {number} pinIndex - index of the pin
+     * @param {number} level - value of analog output [0..1024].
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
+     */
+    setPinPWM (pinIndex, level, util) {
+        this.config.pinMode[pinIndex] = MbitMorePinMode.PWM;
+        const dataView = new DataView(new ArrayBuffer(2));
+        dataView.setUint16(0, level, true);
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_PIN << 5) | MbitMorePinCommand.SET_PWM,
+                message: new Uint8Array(
+                    [
+                        pinIndex,
+                        dataView.getUint8(0),
+                        dataView.getUint8(1)
+                    ]
+                )
+            }],
+            util
+        );
+    }
+
+
+    /**
+     * Set the pin to Servo mode on the angle in the range and center.
+     * @param {number} pinIndex - index of the pin.
+     * @param {number} angle - the level to set on the output pin, in the range 0 - 180.
+     * @param {number} range - the span of possible values. '0' means default(2000).
+     * @param {number} center - the center point from which to calculate the lower and upper bounds.
+     *                          '0' means default(1500).
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
+     */
+    setPinServo (pinIndex, angle, range, center, util) {
+        this.config.pinMode[pinIndex] = MbitMorePinMode.SERVO;
+        if (!range || range < 0) range = 0;
+        if (!center || center < 0) center = 0;
+        const dataView = new DataView(new ArrayBuffer(6));
+        dataView.setUint16(0, angle, true);
+        dataView.setUint16(2, range, true);
+        dataView.setUint16(4, center, true);
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_PIN << 5) | MbitMorePinCommand.SET_SERVO,
+                message: new Uint8Array(
+                    [
+                        pinIndex,
+                        dataView.getUint8(0),
+                        dataView.getUint8(1),
+                        dataView.getUint8(2),
+                        dataView.getUint8(3),
+                        dataView.getUint8(4),
+                        dataView.getUint8(5)
+                    ]
+                )
+            }],
+            util);
+    }
+
+    /**
+     * Read light level from the light sensor.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {number} - value of the light level [0..255].
+     */
+    readLightLevel () {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        return this.lightLevel;
+    }
+
+    /**
+     * Update data of the analog input.
+     * @param {number} pinIndex - index of the pin to get value.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves value of analog input or undefined if this process was yield.
+     */
+    readAnalogIn (pinIndex, util) {
+        if (!this.isConnected()) {
+            return Promise.resolve(0);
+        }
+        if ((Date.now() - this.analogInLastUpdated[pinIndex]) < this.analogInUpdateInterval) {
+            return Promise.resolve(this.analogValue[pinIndex]);
+        }
+        if (this.bleBusy) {
+            this.bleAccessWaiting = true;
+            if (util) util.yield(); // re-try this call after a while.
+            return; // Do not return Promise.resolve() to re-try.
+        }
+        this.bleBusy = true;
+        this.bleBusyTimeoutID = window.setTimeout(() => {
+            this.bleBusy = false;
+            this.bleAccessWaiting = false;
+        }, 1000);
+        return new Promise(resolve => this._ble.read(
+            MM_SERVICE.ID,
+            MM_SERVICE.ANALOG_IN_CH[pinIndex],
+            false)
+            .then(result => {
+                window.clearTimeout(this.bleBusyTimeoutID);
+                this.bleBusy = false;
+                this.bleAccessWaiting = false;
+                if (!result) {
+                    return resolve(this.analogValue[pinIndex]);
+                }
+                const data = base64ToUint8Array(result.message);
+                const dataView = new DataView(data.buffer, 0);
+                this.analogValue[pinIndex] = dataView.getUint16(0, true);
+                this.analogInLastUpdated = Date.now();
+                resolve(this.analogValue[pinIndex]);
+            })
+        );
+    }
+
+    /**
+     * Update data of digital level, light level, temperature, sound level.
+     * @return {Promise} - a Promise that resolves updated data holder.
+     */
+    updateState () {
+        if (!this.isConnected()) return Promise.resolve(this);
+        if (this.bleBusy) {
+            return Promise.resolve(this);
+        }
+        this.bleBusy = true;
+        this.bleBusyTimeoutID = window.setTimeout(() => {
+            this.bleBusy = false;
+        }, 1000);
+        return new Promise(resolve => {
+            this._ble.read(
+                MM_SERVICE.ID,
+                MM_SERVICE.STATE_CH,
+                false)
+                .then(result => {
+                    window.clearTimeout(this.bleBusyTimeoutID);
+                    this.bleBusy = false;
+                    if (!result) return resolve(this);
+                    const data = base64ToUint8Array(result.message);
+                    const dataView = new DataView(data.buffer, 0);
+                    // Digital Input
+                    const gpioData = dataView.getUint32(0, true);
+                    for (let i = 0; i < this.gpio.length; i++) {
+                        this.digitalLevel[this.gpio[i]] = (gpioData >> this.gpio[i]) & 1;
+                    }
+                    Object.keys(MbitMoreButtonStateIndex).forEach(
+                        name => {
+                            this.buttonState[name] = (gpioData >> (24 + MbitMoreButtonStateIndex[name])) & 1;
+                        });
+                    this.lightLevel = dataView.getUint8(4);
+                    this.temperature = dataView.getUint8(5) - 128;
+                    this.soundLevel = dataView.getUint8(6);
+                    this.resetConnectionTimeout();
+                    resolve(this);
+                });
+        });
+    }
+
+    /**
+     * Read temperature (integer in celsius) from the micro:bit cpu.
+     * @return {number} - degrees of temperature [centigrade].
+     */
+    readTemperature () {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        return this.temperature;
+    }
+
+    /**
+     * Configurate microphone.
+     * @param {boolean} use - true to use microphone.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} - a Promise that resolves state of the microphone or undefined if the process was yield.
+     */
+    configMic (use, util) {
+        use = (use === true);
+        if (!this.isConnected()) {
+            return Promise.resolve(false);
+        }
+        if (this.config.mic === use) {
+            return Promise.resolve(this.config.mic);
+        }
+        const sendPromise = this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_CONFIG << 5) | MbitMoreConfig.MIC,
+                message: new Uint8Array([(use ? 1 : 0)]) // use microphone
+            }],
+            util
+        );
+        if (sendPromise) {
+            return sendPromise
+                .then(() => {
+                    this.config.mic = use;
+                    return this.config.mic;
+                });
+        }
+        return;
+    }
+
+    /**
+     * Play tone on the speaker.
+     * @param {number} frequency - wave frequency to play [Hz]
+     * @param {number} volume laudness of tone [%]
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
+     */
+    playTone (frequency, volume, util) {
+        if (!this.isConnected()) {
+            return Promise.resolve();
+        }
+        const frequencyData = new DataView(new ArrayBuffer(4));
+        frequencyData.setUint32(0, Math.round(1000000 / frequency), true);
+        volume = Math.round(volume * 0xff / 100);
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_AUDIO << 5) | MbitMoreAudioCommand.PLAY_TONE,
+                message: new Uint8Array([
+                    frequencyData.getUint8(0),
+                    frequencyData.getUint8(1),
+                    frequencyData.getUint8(2),
+                    frequencyData.getUint8(3),
+                    volume
+                ])
+            }],
+            util
+        );
+    }
+
+    /**
+     * Stop playing tone on the speaker.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
+     */
+    stopTone (util) {
+        if (!this.isConnected()) {
+            return Promise.resolve();
+        }
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_AUDIO << 5) | MbitMoreAudioCommand.STOP_TONE,
+                message: new Uint8Array([])
+            }],
+            util
+        );
+    }
+
+    /**
+     * Read sound level.
+     * @return {number} - level of loudness (0 .. 255).
+     */
+    readSoundLevel () {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        return this.soundLevel;
+    }
+
+    /**
+     * Update data of acceleration, magnetic force.
+     * @return {Promise} - a Promise that resolves updated data holder.
+     */
+    updateMotion () {
+        if (!this.isConnected()) return Promise.resolve(this);
+        if (this.bleBusy) {
+            return Promise.resolve(this);
+        }
+        this.bleBusy = true;
+        this.bleBusyTimeoutID = window.setTimeout(() => {
+            this.bleBusy = false;
+        }, 1000);
+        return new Promise(resolve => {
+            this._ble.read(
+                MM_SERVICE.ID,
+                MM_SERVICE.MOTION_CH,
+                false)
+                .then(result => {
+                    window.clearTimeout(this.bleBusyTimeoutID);
+                    this.bleBusy = false;
+                    if (!result) return resolve(this);
+                    const data = base64ToUint8Array(result.message);
+                    const dataView = new DataView(data.buffer, 0);
+                    // Accelerometer
+                    this.pitch = Math.round(dataView.getInt16(0, true) * 180 / Math.PI / 1000);
+                    this.roll = Math.round(dataView.getInt16(2, true) * 180 / Math.PI / 1000);
+                    this.acceleration.x = 1000 * dataView.getInt16(4, true) / G;
+                    this.acceleration.y = 1000 * dataView.getInt16(6, true) / G;
+                    this.acceleration.z = 1000 * dataView.getInt16(8, true) / G;
+                    // Magnetometer
+                    this.compassHeading = dataView.getUint16(10, true);
+                    this.magneticForce.x = dataView.getInt16(12, true);
+                    this.magneticForce.y = dataView.getInt16(14, true);
+                    this.magneticForce.z = dataView.getInt16(16, true);
+                    this.resetConnectionTimeout();
+                    resolve(this);
+                });
+        });
+    }
+
+    /**
+     * Read pitch [degrees] of the micro:bit heading direction.
+     * @return {number} - degree of pitch.
+     */
+    readPitch () {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        return this.pitch;
+    }
+
+    /**
+     * Read roll [degrees] of the micro:bit heading direction.
+     * @return {number} - degree of roll.
+     */
+    readRoll () {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        return this.roll;
+    }
+
+    /**
+     * Read the value of gravitational acceleration [milli-g] for the axis.
+     * @param {AxisSymbol} axis - direction of acceleration.
+     * @return {number} - value of acceleration.
+     */
+    readAcceleration (axis) {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        if (axis === AxisSymbol.Absolute) {
+            return Math.round(
+                Math.sqrt(
+                    (this.acceleration.x ** 2) +
+                            (this.acceleration.y ** 2) +
+                            (this.acceleration.z ** 2)
+                )
+            );
+        }
+        return this.acceleration[axis];
+    }
+
+    /**
+     * Read the angle (degrees) of heading direction from the north.
+     * @return {number} - degree of compass heading.
+     */
+    readCompassHeading () {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        return this.compassHeading;
+    }
+
+
+    /**
+     * Read value of magnetic force [micro teslas] for the axis.
+     * @param {AxisSymbol} axis - direction of magnetic force.
+     * @return {number} - value of magnetic force.
+     */
+    readMagneticForce (axis) {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        if (axis === AxisSymbol.Absolute) {
+            return Math.round(
+                Math.sqrt(
+                    (this.magneticForce.x ** 2) +
+                            (this.magneticForce.y ** 2) +
+                            (this.magneticForce.z ** 2)
+                )
+            );
+        }
+        return this.magneticForce[axis];
+    }
+
+    /**
+     * Start to scan Bluetooth LE devices to find micro:bit with MicroBit More service.
+     */
+    scanBLE () {
+        const connectorClass = BLE;
+        this._ble = new connectorClass(
+            this.runtime,
+            this._extensionId,
+            {
+                filters: [
+                    {namePrefix: 'BBC micro:bit'},
+                    {services: [MM_SERVICE.ID]}
+                ]
+            },
+            this._onConnect,
+            this.onDisconnect
+        );
+    }
+
+    /**
+     * Start to scan USB serial devices to find micro:bit v2.
+     */
+    scanSerial () {
+        this._ble = new WebSerial(
+            this.runtime,
+            this._extensionId,
+            {
+                filters: [
+                    {usbVendorId: 0x0d28, usbProductId: 0x0204}
+                ]
+            },
+            this._onConnect,
+            this.onDisconnect
+        );
+    }
+
+    /**
+     * Open dialog to selector communication route [BLE | USB Serial]
+     */
+    selectCommunicationRoute () {
+        const selectDialog = document.createElement('dialog');
+        selectDialog.style.padding = '0px';
+        const dialogFace = document.createElement('div');
+        dialogFace.style.padding = '16px';
+        selectDialog.appendChild(dialogFace);
+        const label = document.createTextNode(formatMessage({
+            id: 'mbitMore.selectCommunicationRoute.connectWith',
+            default: 'Connect with',
+            description: 'label of select communication route dialog for microbit more extension'
+        }));
+        dialogFace.appendChild(label);
+        // Dialog form
+        const selectForm = document.createElement('form');
+        selectForm.setAttribute('method', 'dialog');
+        selectForm.style.margin = '8px';
+        dialogFace.appendChild(selectForm);
+        // API select
+        const apiSelect = document.createElement('select');
+        apiSelect.setAttribute('id', 'api');
+        selectForm.appendChild(apiSelect);
+        // BLE option
+        const bleOption = document.createElement('option');
+        bleOption.setAttribute('value', 'ble');
+        bleOption.textContent = formatMessage({
+            id: 'mbitMore.selectCommunicationRoute.bluetooth',
+            default: 'Bluetooth',
+            description: 'bluetooth button on select communication route dialog for microbit more extension'
+        });
+        apiSelect.appendChild(bleOption);
+        // USB option
+        const usbOption = document.createElement('option');
+        usbOption.setAttribute('value', 'usb');
+        usbOption.textContent = formatMessage({
+            id: 'mbitMore.selectCommunicationRoute.usb',
+            default: 'USB',
+            description: 'usb button on select communication route dialog for microbit more extension'
+        });
+        apiSelect.appendChild(usbOption);
+        // Cancel button
+        const cancelButton = document.createElement('button');
+        cancelButton.textContent = formatMessage({
+            id: 'mbitMore.selectCommunicationRoute.cancel',
+            default: 'cancel',
+            description: 'cancel button on select communication route dialog for microbit more extension'
+        });
+        cancelButton.style.margin = '8px';
+        dialogFace.appendChild(cancelButton);
+        // OK button
+        const confirmButton = document.createElement('button');
+        confirmButton.textContent = formatMessage({
+            id: 'mbitMore.selectCommunicationRoute.connect',
+            default: 'connect',
+            description: 'connect button on select communication route dialog for microbit more extension'
+        });
+        confirmButton.style.margin = '8px';
+        dialogFace.appendChild(confirmButton);
+        // Add onClick action
+        const selectProcess = () => {
+            if (apiSelect.value === 'ble') {
+                this.scanBLE();
+            }
+            if (apiSelect.value === 'usb') {
+                this.scanSerial();
+            }
+            document.body.removeChild(selectDialog);
+        };
+        cancelButton.onclick = () => {
+            document.body.removeChild(selectDialog);
+            this.runtime.emit(this.runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
+                message: `Scan was canceled by user`,
+                extensionId: this._extensionId
+            });
+        };
+        confirmButton.onclick = selectProcess;
+        selectDialog.addEventListener('keydown', e => {
+            if (e.code === 'Enter') {
+                selectProcess();
+            }
+        });
+        // Close when click outside of the dialog
+        // selectDialog.onclick = e => {
+        //     if (!e.target.closest('div')) {
+        //         e.target.close();
+        //         selectProcess();
+        //     }
+        // };
+        document.body.appendChild(selectDialog);
+        selectDialog.showModal();
+    }
+
+    /**
+     * Whether the key is pressed at this moment.
+     * @param {string} key - key in keyboard event
+     * @returns {boolean} - return true when the key is pressed
+     */
+    isKeyPressing (key) {
+        return Object.values(this.keyState).find(state => state.key === key);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     */
+    scan () {
+        if (this._ble) {
+            this._ble.disconnect();
+        }
+        this.bleBusy = true;
+        if (('serial' in navigator) && this.isKeyPressing('Shift')) {
+            this.selectCommunicationRoute();
+        } else {
+            this.scanBLE();
+        }
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     */
+    connect (id) {
+        if (this._ble) {
+            this._ble.connectPeripheral(id);
+        }
+    }
+
+    /**
+     * Disconnect from the micro:bit.
+     */
+    disconnect () {
+        if (this._ble) {
+            this._ble.disconnect();
+        }
+        this.onDisconnect();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    onDisconnect () {
+        this.stopUpdater();
+        if (this._timeoutID) {
+            window.clearTimeout(this._timeoutID);
+            this._timeoutID = null;
+        }
+    }
+
+    /**
+     * Return true if connected to the micro:bit.
+     * @return {boolean} - whether the micro:bit is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._ble) {
+            connected = this._ble.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Send a command to micro:bit.
+     * @param {object} command command to send.
+     * @param {number} command.id ID of the command.
+     * @param {Uint8Array} command.message Contents of the command.
+     * @return {Promise} a Promise that resolves when the data was sent and after send command interval.
+     */
+    sendCommand (command) {
+        const data = uint8ArrayToBase64(
+            new Uint8Array([
+                command.id,
+                ...command.message
+            ])
+        );
+        return new Promise(resolve => {
+            this._ble.write(
+                MM_SERVICE.ID,
+                MM_SERVICE.COMMAND_CH,
+                data,
+                'base64',
+                false
+            );
+            setTimeout(() => resolve(), this.sendCommandInterval);
+        });
+    }
+
+    /**
+     * Send multiple commands sequentially.
+     * @param {Array.<{id: number, message: Uint8Array}>} commands array of command.
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when the all commands was sent.
+     */
+    sendCommandSet (commands, util) {
+        if (!this.isConnected()) return Promise.resolve();
+        if (this.bleBusy) {
+            this.bleAccessWaiting = true;
+            if (util) {
+                util.yield(); // re-try this call after a while.
+            } else {
+                setTimeout(() => this.sendCommandSet(commands, util), 1);
+            }
+            return; // Do not return Promise.resolve() to re-try.
+        }
+        this.bleBusy = true;
+        // Clear busy and BLE access waiting flag when the scratch-link does not respond.
+        this.bleBusyTimeoutID = window.setTimeout(() => {
+            this.bleBusy = false;
+            this.bleAccessWaiting = false;
+        }, 1000);
+        return new Promise(resolve => {
+            commands.reduce((acc, cur) => acc.then(() => this.sendCommand(cur)),
+                Promise.resolve()
+            )
+                .then(() => {
+                    window.clearTimeout(this.bleBusyTimeoutID);
+                })
+                .catch(err => {
+                    log.log(err);
+                    this._ble.handleDisconnectError(err);
+                })
+                .finally(() => {
+                    this.bleBusy = false;
+                    this.bleAccessWaiting = false;
+                    resolve();
+                });
+        });
+    }
+
+    /**
+     * Starts reading data from peripheral after BLE has connected to it.
+     */
+    _onConnect () {
+        this._ble.read(
+            MM_SERVICE.ID,
+            MM_SERVICE.COMMAND_CH,
+            false)
+            .then(result => {
+                if (!result) {
+                    throw new Error('Config is not readable');
+                }
+                const data = base64ToUint8Array(result.message);
+                const dataView = new DataView(data.buffer, 0);
+                this.hardware = dataView.getUint8(0);
+                this.protocol = dataView.getUint8(1);
+                this.route = dataView.getUint8(2);
+                this._ble.startNotifications(
+                    MM_SERVICE.ID,
+                    MM_SERVICE.ACTION_EVENT_CH,
+                    this.onNotify);
+                this._ble.startNotifications(
+                    MM_SERVICE.ID,
+                    MM_SERVICE.PIN_EVENT_CH,
+                    this.onNotify);
+                if (this.hardware === MbitMoreHardwareVersion.MICROBIT_V1) {
+                    this.microbitUpdateInterval = 100; // milliseconds
+                } else {
+                    this._ble.startNotifications(
+                        MM_SERVICE.ID,
+                        MM_SERVICE.MESSAGE_CH,
+                        this.onNotify);
+                    this.microbitUpdateInterval = 50; // milliseconds
+                }
+                if (this.route === CommunicationRoute.SERIAL) {
+                    this.sendCommandInterval = 100; // milliseconds
+                } else {
+                    this.sendCommandInterval = 30; // milliseconds
+                }
+                this.initConfig();
+                this.bleBusy = false;
+                this.startUpdater();
+                this.resetConnectionTimeout();
+            })
+            .catch(err => this._ble.handleDisconnectError(err));
+    }
+
+    /**
+     * Process the data from the incoming BLE characteristic.
+     * @param {string} msg - the incoming BLE data.
+     * @private
+     */
+    onNotify (msg) {
+        const data = base64ToUint8Array(msg);
+        const dataView = new DataView(data.buffer, 0);
+        const dataFormat = dataView.getUint8(19);
+        if (dataFormat === MbitMoreDataFormat.ACTION_EVENT) {
+            const actionEventType = dataView.getUint8(0);
+            if (actionEventType === MbitMoreActionEvent.BUTTON) {
+                const buttonName = MbitMoreButtonID[dataView.getUint16(1, true)];
+                const eventName = MbitMoreButtonEventID[dataView.getUint8(3)];
+                this.buttonEvents[buttonName][eventName] = dataView.getUint32(4, true); // Timestamp
+            } else if (actionEventType === MbitMoreActionEvent.GESTURE) {
+                const gestureName = MbitMoreGestureID[dataView.getUint8(1)];
+                this.gestureEvents[gestureName] = dataView.getUint32(2, true); // Timestamp
+            }
+        } else if (dataFormat === MbitMoreDataFormat.PIN_EVENT) {
+            const pinIndex = dataView.getUint8(0);
+            if (!this._pinEvents[pinIndex]) {
+                this._pinEvents[pinIndex] = {};
+            }
+            const event = dataView.getUint8(1);
+            this._pinEvents[pinIndex][event] =
+            {
+                value: dataView.getUint32(2, true), // timesamp of the edge or duration of the pulse
+                timestamp: Date.now() // received time
+            };
+        } else if (dataFormat === MbitMoreDataFormat.DATA_NUMBER) {
+            const label = new TextDecoder().decode(data.slice(0, 8).filter(char => (char !== 0)));
+            this.receivedData[label] =
+            {
+                content: dataView.getFloat32(8, true),
+                timestamp: Date.now()
+            };
+        } else if (dataFormat === MbitMoreDataFormat.DATA_TEXT) {
+            const label = new TextDecoder().decode(data.slice(0, 8).filter(char => (char !== 0)));
+            this.receivedData[label] =
+            {
+                content: new TextDecoder().decode(data.slice(8, 20).filter(char => (char !== 0))),
+                timestamp: Date.now()
+            };
+        }
+        this.resetConnectionTimeout();
+    }
+
+    /**
+     * Cancel disconnect timeout and start counting again.
+     */
+    resetConnectionTimeout () {
+        if (this._timeoutID) window.clearTimeout(this._timeoutID);
+        this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
+    }
+
+    /**
+     * Return whether the pin value is high.
+     * @param {number} pin - the pin to check.
+     * @return {boolean} - whether the pin is high or not.
+     */
+    isPinHigh (pin) {
+        const level = this.readDigitalLevel(pin);
+        return level === 1;
+    }
+
+    /**
+     * Read digital input from the pin.
+     * @param {number} pin - the pin to read.
+     * @return {number} - digital input value of the pin [0|1].
+     */
+    readDigitalLevel (pin) {
+        if (!this.isConnected()) {
+            return 0;
+        }
+        return this.digitalLevel[pin];
+    }
+
+    /**
+     * Return whether the button is pressed.
+     * @param {string} buttonName - name of the button
+     * @return {boolean} - true when it is pressed
+     */
+    isButtonPressed (buttonName) {
+        if (!this.isConnected()) {
+            return false;
+        }
+        return this.buttonState[buttonName] === 1;
+    }
+
+    /**
+     * Return whether the pin is touch-mode.
+     * @param {number} pinIndex - indesx of the pin
+     * @return {boolean} - true when it is touch-mode
+     */
+    isPinTouchMode (pinIndex) {
+        return this.config.pinMode[pinIndex] === MbitMorePinMode.TOUCH;
+    }
+
+    /**
+     * Configurate touch mode of the pin.
+     * @param {number} pinIndex - index of the pin as a button.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} - a Promise that resolves when configured or undefined if the process was yield.
+     */
+    configTouchPin (pinIndex, util) {
+        if (!this.isConnected()) {
+            return Promise.resolve();
+        }
+        if (this.isPinTouchMode(pinIndex)) {
+            return Promise.resolve();
+        }
+        const sendPromise = this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_CONFIG << 5) | MbitMoreConfig.TOUCH,
+                message: new Uint8Array([
+                    pinIndex,
+                    1
+                ])
+            }],
+            util
+        );
+        if (sendPromise) {
+            return sendPromise
+                .then(() => {
+                    this.config.pinMode[pinIndex] = MbitMorePinMode.TOUCH;
+                });
+        }
+        return;
+    }
+
+    /**
+     * Return whether the touche-pin is touched.
+     * @param {string} buttonName - ID to check.
+     * @return {boolean} - whether the id is high or not.
+     */
+    isTouched (buttonName) {
+        if (!this.isConnected()) {
+            return false;
+        }
+        return this.buttonState[buttonName] === 1;
+    }
+
+    /**
+     * Return the last timestamp of the button event or undefined if the event is not received.
+     * @param {MbitMoreButtonName} buttonName - name of the button to get the event.
+     * @param {MbitMoreButtonEventName} eventName - name of event to get.
+     * @return {?number} Timestamp of the last event or null.
+     */
+    getButtonEventTimestamp (buttonName, eventName) {
+        if (this.buttonEvents[buttonName] && this.buttonEvents[buttonName][eventName]) {
+            return this.buttonEvents[buttonName][eventName];
+        }
+        return null;
+    }
+
+    /**
+     * Return the last timestamp of the gesture event or undefined if the event is not received.
+     * @param {MbitMoreGestureName} gestureName - name of the event.
+     * @return {?number} Timestamp of the last event or null.
+     */
+    getGestureEventTimestamp (gestureName) {
+        if (this.gestureEvents[gestureName]) {
+            return this.gestureEvents[gestureName];
+        }
+        return null;
+    }
+
+    /**
+     * Return the last value of the pin event or undefined if the event was not received.
+     * @param {number} pinIndex - index of the pin to get the event.
+     * @param {MbitMorePinEvent} event - event to get.
+     * @return {?number} Timestamp of the last event or null.
+     */
+    getPinEventValue (pinIndex, event) {
+        if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
+            return this._pinEvents[pinIndex][event].value;
+        }
+        return null;
+    }
+
+    /**
+     * Return the last timestamp of the pin event or undefined if the event was not received.
+     * @param {number} pinIndex - index of the pin to get the event.
+     * @param {MbitMorePinEvent} event - event to get.
+     * @return {?number} Timestamp of the last event or null.
+     */
+    getPinEventTimestamp (pinIndex, event) {
+        if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
+            return this._pinEvents[pinIndex][event].timestamp;
+        }
+        return null;
+    }
+
+    /**
+     * Set event type to be get from the pin.
+     * @param {number} pinIndex - Index of the pin to set.
+     * @param {MbitMorePinEventType} eventType - Event type to set.
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
+     */
+    listenPinEventType (pinIndex, eventType, util) {
+        return this.sendCommandSet(
+            [{
+                id: (BLECommand.CMD_PIN << 5) | MbitMorePinCommand.SET_EVENT,
+                message: new Uint8Array([
+                    pinIndex,
+                    eventType
+                ])
+            }],
+            util
+        );
+    }
+
+    /**
+     * Send data to micro:bit.
+     * @param {string} label - label of the data [ascii]
+     * @param {string} content - content of the data [ascii | number]
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves when sending done or undefined if this process was yield.
+     */
+    sendData (label, content, util) {
+        const labelData = new Array(8)
+            .fill()
+            .map((_value, index) => label.charCodeAt(index));
+        const contentNumber = Number(content);
+        let contentData;
+        let type;
+        if (Number.isNaN(contentNumber)) {
+            type = MbitMoreSendingDataType.TEXT;
+            contentData = content
+                .split('')
+                .map(ascii => ascii.charCodeAt(0))
+                .slice(0, 11);
+        } else {
+            type = MbitMoreSendingDataType.NUMBER;
+            const dataView = new DataView(new ArrayBuffer(4));
+            dataView.setFloat32(0, contentNumber, true);
+            contentData = [
+                dataView.getUint8(0),
+                dataView.getUint8(1),
+                dataView.getUint8(2),
+                dataView.getUint8(3)
+            ];
+        }
+        return this.sendCommandSet(
+            [{
+                id: ((BLECommand.CMD_DATA << 5) | type),
+                message: new Uint8Array([
+                    ...labelData,
+                    ...contentData])
+            }],
+            util);
+    }
+
+    /**
+     * Return the last data with the label or undefined if no data received with the label.
+     * @param {string} label - label to get.
+     * @return {?(number | string)} data of the label or null.
+     */
+    getDataLabeled (label) {
+        if (this.receivedData[label]) {
+            return this.receivedData[label].content;
+        }
+        return null;
+    }
+
+    /**
+     * Return the last timestamp of the data or undefined if the data is not received.
+     * @param {string} label - label of the data.
+     * @return {?number} Timestamp of the last data or null.
+     */
+    getDataTimestamp (label) {
+        if (this.receivedData[label]) {
+            return this.receivedData[label].timestamp;
+        }
+        return null;
+    }
+}
+
+/**
+ * Scratch 3.0 blocks to interact with a MicroBit peripheral.
+ */
+class MbitMoreBlocks {
+
+    /**
+     * @return {string} - the name of this extension.
+     */
+    static get EXTENSION_NAME () {
+        return 'Microbit More';
+    }
+
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get EXTENSION_ID () {
+        return EXTENSION_ID;
+    }
+
+    /**
+     * URL to get this extension.
+     * @type {string}
+     */
+    static get extensionURL () {
+        return extensionURL;
+    }
+
+    /**
+     * Set URL to get this extension.
+     * @param {string} url - URL
+     */
+    static set extensionURL (url) {
+        extensionURL = url;
+    }
+
+    /**
+     * @return {array} - text and values for each gestures menu element
+     */
+    get GESTURES_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.tiltUp',
+                    default: 'titl up',
+                    description: 'label for tilt up gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.TILT_UP
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.tiltDown',
+                    default: 'titl down',
+                    description: 'label for tilt down gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.TILT_DOWN
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.tiltLeft',
+                    default: 'titl left',
+                    description: 'label for tilt left gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.TILT_LEFT
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.tiltRight',
+                    default: 'titl right',
+                    description: 'label for tilt right gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.TILT_RIGHT
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.faceUp',
+                    default: 'face up',
+                    description: 'label for face up gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.FACE_UP
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.faceDown',
+                    default: 'face down',
+                    description: 'label for face down gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.FACE_DOWN
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.freefall',
+                    default: 'freefall',
+                    description: 'label for freefall gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.FREEFALL
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.g3',
+                    default: '3G',
+                    description: 'label for 3G gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.G3
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.g6',
+                    default: '6G',
+                    description: 'label for 6G gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.G6
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.g8',
+                    default: '8G',
+                    description: 'label for 3G gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.G8
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.gesturesMenu.shake',
+                    default: 'shake',
+                    description: 'label for shaken gesture in gesture picker for microbit more extension'
+                }),
+                value: MbitMoreGestureName.SHAKE
+            }
+
+        ];
+    }
+
+
+    /**
+     * @return {array} - text and values for each buttons menu element
+     */
+    get BUTTON_ID_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.buttonIDMenu.a',
+                    default: 'A',
+                    description: 'label for "A" element in button picker for Microbit More extension'
+                }),
+                value: MbitMoreButtonName.A
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.buttonIDMenu.b',
+                    default: 'B',
+                    description: 'label for "B" element in button picker for Microbit More extension'
+                }),
+                value: MbitMoreButtonName.B
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - Menu items for button event selector.
+     */
+    get BUTTON_EVENT_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.buttonEventMenu.down',
+                    default: 'down',
+                    description: 'label for button down event'
+                }),
+                value: MbitMoreButtonEventName.DOWN
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.buttonEventMenu.up',
+                    default: 'up',
+                    description: 'label for button up event'
+                }),
+                value: MbitMoreButtonEventName.UP
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.buttonEventMenu.click',
+                    default: 'click',
+                    description: 'label for button click event'
+                }),
+                value: MbitMoreButtonEventName.CLICK
+            // },
+            // // These events are not in use because they are unstable in coal-microbit-v2.
+            // {
+            //     text: formatMessage({
+            //         id: 'mbitMore.buttonEventMenu.hold',
+            //         default: 'hold',
+            //         description: 'label for button hold event'
+            //     }),
+            //     value: MbitMoreButtonEventName.HOLD
+            // },
+            // {
+            //     text: formatMessage({
+            //         id: 'mbitMore.buttonEventMenu.longClick',
+            //         default: 'long click',
+            //         description: 'label for button long click event'
+            //     }),
+            //     value: MbitMoreButtonEventName.LONG_CLICK
+            // },
+            // {
+            //     text: formatMessage({
+            //         id: 'mbitMore.buttonEventMenu.doubleClick',
+            //         default: 'double click',
+            //         description: 'label for button double click event'
+            //     }),
+            //     value: MbitMoreButtonEventName.DOUBLE_CLICK
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - text and values for each buttons menu element
+     */
+    get TOUCH_ID_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.touchIDMenu.logo',
+                    default: 'LOGO',
+                    description: 'label for "LOGO" element in touch button picker for Microbit More extension'
+                }),
+                value: MbitMoreButtonName.LOGO
+            },
+            {
+                text: 'P0',
+                value: MbitMoreButtonName.P0
+            },
+            {
+                text: 'P1',
+                value: MbitMoreButtonName.P1
+            },
+            {
+                text: 'P2',
+                value: MbitMoreButtonName.P2
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - Menu items for touch event selector.
+     */
+    get TOUCH_EVENT_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.touchEventMenu.touched',
+                    default: 'touched',
+                    description: 'label for touched event'
+                }),
+                value: MbitMoreButtonEventName.DOWN
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.touchEventMenu.released',
+                    default: 'released',
+                    description: 'label for released event'
+                }),
+                value: MbitMoreButtonEventName.UP
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.touchEventMenu.tapped',
+                    default: 'tapped',
+                    description: 'label for tapped event'
+                }),
+                value: MbitMoreButtonEventName.CLICK
+            // },
+            // // These events are not in use because they are unstable in coal-microbit-v2.
+            // {
+            //     text: formatMessage({
+            //         id: 'mbitMore.touchEventMenu.hold',
+            //         default: 'hold',
+            //         description: 'label for hold event in touch'
+            //     }),
+            //     value: MbitMoreButtonEventName.HOLD
+            // },
+            // {
+            //     text: formatMessage({
+            //         id: 'mbitMore.touchEventMenu.longTapped',
+            //         default: 'long tapped',
+            //         description: 'label for long click event in touch'
+            //     }),
+            //     value: MbitMoreButtonEventName.LONG_CLICK
+            // },
+            // {
+            //     text: formatMessage({
+            //         id: 'mbitMore.touchEventMenu.doubleTapped',
+            //         default: 'double tapped',
+            //         description: 'label for double click event in touch'
+            //     }),
+            //     value: MbitMoreButtonEventName.DOUBLE_CLICK
+            }
+        ];
+    }
+
+    get ANALOG_IN_PINS_MENU () {
+        return this._peripheral.analogIn.map(
+            pinIndex =>
+                Object.create({
+                    text: `P${pinIndex.toString()}`,
+                    value: pinIndex.toString()
+                })
+        );
+    }
+
+
+    get GPIO_MENU () {
+        return this._peripheral.gpio.map(
+            pinIndex =>
+                Object.create({
+                    text: `P${pinIndex.toString()}`,
+                    value: pinIndex.toString()
+                })
+        );
+    }
+
+    get DIGITAL_VALUE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.digitalValueMenu.Low',
+                    default: 'Low',
+                    description: 'label for low value in digital output menu for microbit more extension'
+                }),
+                value: 'false'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.digitalValueMenu.High',
+                    default: 'High',
+                    description: 'label for high value in digital output menu for microbit more extension'
+                }),
+                value: 'true'
+            }
+        ];
+    }
+
+    get AXIS_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.axisMenu.x',
+                    default: 'x',
+                    description: 'label of X axis.'
+                }),
+                value: AxisSymbol.X
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.axisMenu.y',
+                    default: 'y',
+                    description: 'label of Y axis.'
+                }),
+                value: AxisSymbol.Y
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.axisMenu.z',
+                    default: 'z',
+                    description: 'label of Z axis.'
+                }),
+                value: AxisSymbol.Z
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.axisMenu.absolute',
+                    default: 'absolute',
+                    description: 'label of absolute value.'
+                }),
+                value: AxisSymbol.Absolute
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - text and values for each pin mode menu element
+     */
+    get PIN_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinModeMenu.pullNone',
+                    default: 'pull none',
+                    description: 'label for pullNone mode'
+                }),
+                value: MbitMorePullModeName.NONE
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinModeMenu.pullUp',
+                    default: 'pull up',
+                    description: 'label for pullUp mode'
+                }),
+                value: MbitMorePullModeName.UP
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinModeMenu.pullDown',
+                    default: 'pull down',
+                    description: 'label for pullDown mode'
+                }),
+                value: MbitMorePullModeName.DOWN
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - Menu items for event selector.
+     */
+    get PIN_EVENT_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventMenu.pulseLow',
+                    default: 'low pulse',
+                    description: 'label for low pulse event'
+                }),
+                value: 'PULSE_LOW'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventMenu.pulseHigh',
+                    default: 'high pulse',
+                    description: 'label for high pulse event'
+                }),
+                value: 'PULSE_HIGH'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventMenu.fall',
+                    default: 'fall',
+                    description: 'label for fall event'
+                }),
+                value: 'FALL'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventMenu.rise',
+                    default: 'rise',
+                    description: 'label for rise event'
+                }),
+                value: 'RISE'
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - Menu items for event selector.
+     */
+    get PIN_EVENT_TIMESTAMP_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventTimestampMenu.pulseLow',
+                    default: 'low pulse',
+                    description: 'label for low pulse event'
+                }),
+                value: 'PULSE_LOW'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventTimestampMenu.pulseHigh',
+                    default: 'high pulse',
+                    description: 'label for high pulse event'
+                }),
+                value: 'PULSE_HIGH'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventTimestampMenu.fall',
+                    default: 'fall',
+                    description: 'label for fall event'
+                }),
+                value: 'FALL'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventTimestampMenu.rise',
+                    default: 'rise',
+                    description: 'label for rise event'
+                }),
+                value: 'RISE'
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - Menu items for event listening.
+     */
+    get PIN_EVENT_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventTypeMenu.none',
+                    default: 'none',
+                    description: 'label for remove event listener'
+                }),
+                value: 'NONE'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventTypeMenu.pulse',
+                    default: 'pulse',
+                    description: 'label for pulse event type'
+                }),
+                value: 'ON_PULSE'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.pinEventTypeMenu.edge',
+                    default: 'edge',
+                    description: 'label for edge event type'
+                }),
+                value: 'ON_EDGE'
+            }
+        ];
+    }
+
+    /**
+     * @return {array} - Menu items for connection state.
+     */
+    get CONNECTION_STATE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'mbitMore.connectionStateMenu.connected',
+                    default: 'connected',
+                    description: 'label for connected'
+                }),
+                value: 'connected'
+            },
+            {
+                text: formatMessage({
+                    id: 'mbitMore.connectionStateMenu.disconnected',
+                    default: 'disconnected',
+                    description: 'label for disconnected'
+                }),
+                value: 'disconnected'
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of MicroBit blocks.
+     * @param {Runtime} runtime - the Scratch 3.0 runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The Scratch 3.0 runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        if (runtime.formatMessage) {
+            // Replace 'formatMessage' to a formatter which is used in the runtime.
+            formatMessage = runtime.formatMessage;
+        }
+        // Create a new MicroBit peripheral instance
+        this._peripheral = new MbitMore(this.runtime, MbitMoreBlocks.EXTENSION_ID);
+
+        /**
+         * The previous timestamps of button events.
+         * @type {Object.<number, Object.<number, number>>} button ID to object with event and timestamp.
+         */
+        this.prevButtonEvents = {};
+
+        /**
+         * The previous timestamps of gesture events.
+         * @type {Object.<number, number>} key: event ID, value: timestamp.
+         */
+        this.prevGestureEvents = {};
+
+        /**
+         * The previous timestamps of pin events.
+         * @type {Object.<number, Object.<number, number>>} pin index to object with event and timestamp.
+         */
+        this.prevPinEvents = {};
+
+        /**
+         * The previous timestamps of messages.
+         * @type {Object.<number, Object>} pin index to object with event and timestamp.
+         */
+        this.prevReceivedData = {};
+    }
+
+    /**
+     * @returns {object} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        this.setupTranslations();
+        return {
+            id: MbitMoreBlocks.EXTENSION_ID,
+            name: MbitMoreBlocks.EXTENSION_NAME,
+            extensionURL: MbitMoreBlocks.extensionURL,
+            blockIconURI: blockIconURI,
+            showStatusButton: true,
+            blocks: [
+                {
+                    opcode: 'whenConnectionChanged',
+                    text: formatMessage({
+                        id: 'mbitMore.whenConnectionChanged',
+                        default: 'when micro:bit [STATE]',
+                        description: 'when a micro:bit connection state changed'
+                    }),
+                    blockType: BlockType.HAT,
+                    arguments: {
+                        STATE: {
+                            type: ArgumentType.STRING,
+                            menu: 'connectionStateMenu',
+                            defaultValue: 'connected'
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'whenButtonEvent',
+                    text: formatMessage({
+                        id: 'mbitMore.whenButtonEvent',
+                        default: 'when button [NAME] is [EVENT]',
+                        description: 'when the selected button on the micro:bit get the selected event'
+                    }),
+                    blockType: BlockType.HAT,
+                    arguments: {
+                        NAME: {
+                            type: ArgumentType.STRING,
+                            menu: 'buttonIDMenu',
+                            defaultValue: MbitMoreButtonName.A
+                        },
+                        EVENT: {
+                            type: ArgumentType.STRING,
+                            menu: 'buttonEventMenu',
+                            defaultValue: MbitMoreButtonEventName.DOWN
+                        }
+                    }
+                },
+                {
+                    opcode: 'isButtonPressed',
+                    text: formatMessage({
+                        id: 'mbitMore.isButtonPressed',
+                        default: 'button [NAME] pressed?',
+                        description: 'is the selected button on the micro:bit pressed?'
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NAME: {
+                            type: ArgumentType.STRING,
+                            menu: 'buttonIDMenu',
+                            defaultValue: MbitMoreButtonName.A
+                        }
+                    }
+                },
+                {
+                    opcode: 'whenTouchEvent',
+                    text: formatMessage({
+                        id: 'mbitMore.whenTouchEvent',
+                        default: 'when pin [NAME] is [EVENT]',
+                        description: 'when the selected touch pin on the micro:bit is touched'
+                    }),
+                    blockType: BlockType.HAT,
+                    arguments: {
+                        NAME: {
+                            type: ArgumentType.STRING,
+                            menu: 'touchIDMenu',
+                            defaultValue: MbitMoreButtonName.LOGO
+                        },
+                        EVENT: {
+                            type: ArgumentType.STRING,
+                            menu: 'touchEventMenu',
+                            defaultValue: MbitMoreButtonEventName.DOWN
+                        }
+                    }
+                },
+                {
+                    opcode: 'isPinTouched',
+                    text: formatMessage({
+                        id: 'mbitMore.isPinTouched',
+                        default: 'pin [NAME] is touched?',
+                        description: 'is the selected pin is touched?'
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NAME: {
+                            type: ArgumentType.STRING,
+                            menu: 'touchIDMenu',
+                            defaultValue: MbitMoreButtonName.LOGO
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'whenGesture',
+                    text: formatMessage({
+                        id: 'mbitMore.whenGesture',
+                        default: 'when [GESTURE]',
+                        description: 'when the selected gesture is detected by the micro:bit'
+                    }),
+                    blockType: BlockType.HAT,
+                    arguments: {
+                        GESTURE: {
+                            type: ArgumentType.STRING,
+                            menu: 'gestures',
+                            defaultValue: MbitMoreGestureName.SHAKE
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'displayMatrix',
+                    text: formatMessage({
+                        id: 'mbitMore.displayMatrix',
+                        default: 'display pattern [MATRIX] ',
+                        description: 'display a pattern on the micro:bit display'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        MATRIX: {
+                            type: ArgumentType.MATRIX,
+                            defaultValue: '0101010101100010101000100'
+                        }
+                    }
+                },
+                {
+                    opcode: 'displayText',
+                    text: formatMessage({
+                        id: 'mbitMore.displayText',
+                        default: 'display text [TEXT] delay [DELAY] ms',
+                        description: 'display text on the micro:bit display'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        TEXT: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'Hello!'
+                        },
+                        DELAY: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 120
+                        }
+                    }
+                },
+                {
+                    opcode: 'displayClear',
+                    text: formatMessage({
+                        id: 'mbitMore.clearDisplay',
+                        default: 'clear display',
+                        description: 'display nothing on the micro:bit display'
+                    }),
+                    blockType: BlockType.COMMAND
+                },
+                '---',
+                {
+                    opcode: 'getLightLevel',
+                    text: formatMessage({
+                        id: 'mbitMore.lightLevel',
+                        default: 'light intensity',
+                        description: 'how much the amount of light falling on the LEDs on micro:bit'
+                    }),
+                    blockType: BlockType.REPORTER
+                },
+                {
+                    opcode: 'getTemperature',
+                    text: formatMessage({
+                        id: 'mbitMore.temperature',
+                        default: 'temperature',
+                        description: 'temperature (celsius) on the surface of CPU of micro:bit'
+                    }),
+                    blockType: BlockType.REPORTER
+                },
+                {
+                    opcode: 'getCompassHeading',
+                    text: formatMessage({
+                        id: 'mbitMore.compassHeading',
+                        default: 'angle with the North',
+                        description: 'angle from the North to the micro:bit heading direction'
+                    }),
+                    blockType: BlockType.REPORTER
+                },
+                {
+                    opcode: 'getPitch',
+                    text: formatMessage({
+                        id: 'mbitMore.pitch',
+                        default: 'pitch',
+                        description: 'nose up movement of the micro:bit from level'
+                    }),
+                    blockType: BlockType.REPORTER
+                },
+                {
+                    opcode: 'getRoll',
+                    text: formatMessage({
+                        id: 'mbitMore.roll',
+                        default: 'roll',
+                        description: 'clockwise circular movement of the micro:bit from level'
+                    }),
+                    blockType: BlockType.REPORTER
+                },
+                {
+                    opcode: 'getSoundLevel',
+                    text: formatMessage({
+                        id: 'mbitMore.soundLevel',
+                        default: 'sound level',
+                        description: 'level of the sound from microphone on micro:bit'
+                    }),
+                    blockType: BlockType.REPORTER
+                },
+                {
+                    opcode: 'getMagneticForce',
+                    text: formatMessage({
+                        id: 'mbitMore.magneticForce',
+                        default: 'magnetic force',
+                        description: 'value of magnetic force (micro tesla)'
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        AXIS: {
+                            type: ArgumentType.STRING,
+                            menu: 'axis',
+                            defaultValue: AxisSymbol.Absolute
+                        }
+                    }
+                },
+                {
+                    opcode: 'getAcceleration',
+                    text: formatMessage({
+                        id: 'mbitMore.acceleration',
+                        default: 'acceleration [AXIS]',
+                        description: 'value of acceleration on the axis (milli-g)'
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        AXIS: {
+                            type: ArgumentType.STRING,
+                            menu: 'axis',
+                            defaultValue: AxisSymbol.X
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'getAnalogValue',
+                    text: formatMessage({
+                        id: 'mbitMore.analogValue',
+                        default: 'analog value of pin [PIN]',
+                        description: 'analog input value of the pin'
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'analogInPins',
+                            defaultValue: '0'
+                        }
+                    }
+                },
+                {
+                    opcode: 'setPullMode',
+                    text: formatMessage({
+                        id: 'mbitMore.setPullMode',
+                        default: 'set pin [PIN] to input [MODE]',
+                        description: 'set a pin into the mode'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        },
+                        MODE: {
+                            type: ArgumentType.STRING,
+                            menu: 'pinMode',
+                            defaultValue: MbitMorePullModeName.UP
+                        }
+                    }
+                },
+                {
+                    opcode: 'isPinHigh',
+                    text: formatMessage({
+                        id: 'mbitMore.isPinHigh',
+                        default: '[PIN] pin is high?',
+                        description: 'is the selected pin high as digital?'
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'setDigitalOut',
+                    text: formatMessage({
+                        id: 'mbitMore.setDigitalOut',
+                        default: 'set [PIN] Digital [LEVEL]',
+                        description: 'set pin to Digtal Output mode and the level(true = High)'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        },
+                        LEVEL: {
+                            type: ArgumentType.STRING,
+                            menu: 'digitalValueMenu',
+                            defaultValue: 'false'
+                        }
+                    }
+                },
+                {
+                    opcode: 'setAnalogOut',
+                    text: formatMessage({
+                        id: 'mbitMore.setAnalogOut',
+                        default: 'set [PIN] analog [LEVEL] %',
+                        description: 'set pin to PWM mode and the level(0 to 1023)'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        },
+                        LEVEL: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 0
+                        }
+                    }
+                },
+                {
+                    opcode: 'setServo',
+                    text: formatMessage({
+                        id: 'mbitMore.setServo',
+                        default: 'set [PIN] Servo [ANGLE]',
+                        description: 'set pin to Servo mode and the angle(0 to 180)'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        },
+                        ANGLE: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 0
+                        },
+                        RANGE: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 2000
+                        },
+                        CENTER: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 1500
+                        }
+                    }
+                },
+                {
+                    opcode: 'playTone',
+                    text: formatMessage({
+                        id: 'mbitMore.playTone',
+                        default: 'play tone [FREQ] Hz volume [VOL] %',
+                        description: 'play tone on the speaker'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        FREQ: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 440
+                        },
+                        VOL: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 100
+                        }
+                    }
+                },
+                {
+                    opcode: 'stopTone',
+                    text: formatMessage({
+                        id: 'mbitMore.stopTone',
+                        default: 'stop tone',
+                        description: 'stop tone on the speaker'
+                    }),
+                    blockType: BlockType.COMMAND
+                },
+                '---',
+                {
+                    opcode: 'listenPinEventType',
+                    text: formatMessage({
+                        id: 'mbitMore.listenPinEventType',
+                        default: 'catch event [EVENT_TYPE] on [PIN]',
+                        description: 'listen the event on the pin'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        EVENT_TYPE: {
+                            type: ArgumentType.STRING,
+                            menu: 'pinEventTypeMenu',
+                            defaultValue: 'NONE'
+                        },
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        }
+                    }
+                },
+                {
+                    opcode: 'whenPinEvent',
+                    text: formatMessage({
+                        id: 'mbitMore.whenPinEvent',
+                        default: 'when catch [EVENT] at pin [PIN]',
+                        description: 'when catch the event at the pin'
+
+                    }),
+                    blockType: BlockType.HAT,
+                    arguments: {
+                        EVENT: {
+                            type: ArgumentType.STRING,
+                            menu: 'pinEventMenu',
+                            defaultValue: 'PULSE_LOW'
+                        },
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        }
+                    }
+                },
+                {
+                    opcode: 'getPinEventValue',
+                    text: formatMessage({
+                        id: 'mbitMore.getPinEventValue',
+                        default: 'value of [EVENT] at [PIN]',
+                        description: 'value of the value of the event (timestamp of the edge or duration of the pulse)'
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        EVENT: {
+                            type: ArgumentType.STRING,
+                            menu: 'pinEventTimestampMenu',
+                            defaultValue: 'PULSE_LOW'
+                        },
+                        PIN: {
+                            type: ArgumentType.STRING,
+                            menu: 'gpio',
+                            defaultValue: '0'
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'whenDataReceived',
+                    text: formatMessage({
+                        id: 'mbitMore.whenDataReceived',
+                        default: 'when data with label [LABEL] received from micro:bit',
+                        description: 'when the data which has the label received'
+
+                    }),
+                    blockType: BlockType.HAT,
+                    arguments: {
+                        LABEL: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'label-01'
+                        }
+                    }
+                },
+                {
+                    opcode: 'getDataLabeled',
+                    text: formatMessage({
+                        id: 'mbitMore.getDataLabeled',
+                        default: 'data of label [LABEL]',
+                        description: 'the last data which has the label'
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        LABEL: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'label-01'
+                        }
+                    }
+                },
+                {
+                    opcode: 'sendData',
+                    text: formatMessage({
+                        id: 'mbitMore.sendData',
+                        default: 'send data [DATA] with label [LABEL] to micro:bit',
+                        description: 'send data content with label to micro:bit'
+                    }),
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        LABEL: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'label-01'
+                        },
+                        DATA: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'data'
+                        }
+                    }
+                }
+            ],
+            menus: {
+                buttonIDMenu: {
+                    acceptReporters: false,
+                    items: this.BUTTON_ID_MENU
+                },
+                buttonEventMenu: {
+                    acceptReporters: false,
+                    items: this.BUTTON_EVENT_MENU
+                },
+                touchIDMenu: {
+                    acceptReporters: false,
+                    items: this.TOUCH_ID_MENU
+                },
+                touchEventMenu: {
+                    acceptReporters: false,
+                    items: this.TOUCH_EVENT_MENU
+                },
+                gestures: {
+                    acceptReporters: false,
+                    items: this.GESTURES_MENU
+                },
+                analogInPins: {
+                    acceptReporters: false,
+                    items: this.ANALOG_IN_PINS_MENU
+                },
+                digitalValueMenu: {
+                    acceptReporters: true,
+                    items: this.DIGITAL_VALUE_MENU
+                },
+                gpio: {
+                    acceptReporters: false,
+                    items: this.GPIO_MENU
+                },
+                axis: {
+                    acceptReporters: false,
+                    items: this.AXIS_MENU
+                },
+                pinMode: {
+                    acceptReporters: false,
+                    items: this.PIN_MODE_MENU
+                },
+                pinEventTypeMenu: {
+                    acceptReporters: false,
+                    items: this.PIN_EVENT_TYPE_MENU
+                },
+                pinEventMenu: {
+                    acceptReporters: false,
+                    items: this.PIN_EVENT_MENU
+                },
+                pinEventTimestampMenu: {
+                    acceptReporters: false,
+                    items: this.PIN_EVENT_TIMESTAMP_MENU
+                },
+                connectionStateMenu: {
+                    acceptReporters: false,
+                    items: this.CONNECTION_STATE_MENU
+                }
+            },
+            // eslint-disable-next-line no-use-before-define
+            translationMap: extensionTranslations
+        };
+    }
+
+    /**
+     * Update the previous occured time of all button events.
+     */
+    updatePrevButtonEvents () {
+        this.prevButtonEvents = {};
+        Object.entries(this._peripheral.buttonEvents).forEach(([componentID, events]) => {
+            this.prevButtonEvents[componentID] = {};
+            Object.entries(events).forEach(([eventName, timestamp]) => {
+                this.prevButtonEvents[componentID][eventName] = timestamp;
+            });
+        });
+    }
+
+    /**
+     * Test whether the event raised at the button.
+     * @param {object} args - the block's arguments.
+     * @param {string} args.NAME - name of the button.
+     * @param {string} args.EVENT - name of event to catch.
+     * @return {boolean} - true if the event raised.
+     */
+    whenButtonEvent (args) {
+        if (!this.updateLastButtonEventTimer) {
+            this.updateLastButtonEventTimer = setTimeout(() => {
+                this.updatePrevButtonEvents();
+                this.updateLastButtonEventTimer = null;
+            }, this.runtime.currentStepTime);
+        }
+        const buttonName = args.NAME;
+        const eventName = args.EVENT;
+        const lastTimestamp =
+            this._peripheral.getButtonEventTimestamp(buttonName, eventName);
+        if (lastTimestamp === null) return false;
+        if (!this.prevButtonEvents[buttonName]) return true;
+        return lastTimestamp !== this.prevButtonEvents[buttonName][eventName];
+    }
+
+    /**
+     * Test whether the A or B button is pressed
+     * @param {object} args - the block's arguments.
+     * @param {string} args.NAME - name of the button.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {boolean} - whether the button is pressed or not.
+     */
+    isButtonPressed (args) {
+        const buttonName = args.NAME;
+        return this._peripheral.isButtonPressed(buttonName);
+    }
+
+
+    /**
+     * Test whether the touch event raised at the pin.
+     * @param {object} args - the block's arguments.
+     * @param {string} args.NAME - name of the pin to catch.
+     * @param {string} args.EVENT - event to catch.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {boolean|Promise<boolean>|undefined} - true if the event raised or promise that or undefinde if yield.
+     */
+    whenTouchEvent (args, util) {
+        const buttonName = args.NAME;
+        if (buttonName === MbitMoreButtonName.LOGO) {
+            return this.whenButtonEvent(args);
+        }
+        if (this._peripheral.isPinTouchMode(MbitMoreButtonPinIndex[buttonName])) {
+            return this.whenButtonEvent(args);
+        }
+        const configPromise = this._peripheral.configTouchPin(MbitMoreButtonPinIndex[buttonName], util);
+        if (!configPromise) return; // This thread was yielded.
+        return configPromise.then(() => this.whenButtonEvent(args));
+    }
+
+    /**
+     * Test whether the touch-pin is touched.
+     * @param {object} args - the block's arguments.
+     * @param {string} args.NAME - name of the pin.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {boolean|Promise<boolean>|undefined} - true if touched or promise that or undefinde if yield.
+     */
+    isPinTouched (args, util) {
+        const buttonName = args.NAME;
+        if (buttonName === MbitMoreButtonName.LOGO) {
+            return this._peripheral.isTouched(buttonName);
+        }
+        if (this._peripheral.isPinTouchMode(MbitMoreButtonPinIndex[buttonName])) {
+            return this._peripheral.isTouched(buttonName);
+        }
+        const configPromise = this._peripheral.configTouchPin(MbitMoreButtonPinIndex[buttonName], util);
+        if (!configPromise) return; // This thread was yielded.
+        return configPromise.then(() => this._peripheral.isTouched(buttonName));
+    }
+
+    /**
+     * Update the last occured time of all gesture events.
+     */
+    updatePrevGestureEvents () {
+        this.prevGestureEvents = {};
+        Object.entries(this._peripheral.gestureEvents).forEach(([gestureName, timestamp]) => {
+            this.prevGestureEvents[gestureName] = timestamp;
+        });
+    }
+
+    /**
+     * Test whether the gesture event raised.
+     * @param {object} args - the block's arguments.
+     * @param {string} args.GESTURE - name of the gesture.
+     * @return {boolean} - true if the event raised.
+     */
+    whenGesture (args) {
+        if (!this.updateLastGestureEventTimer) {
+            this.updateLastGestureEventTimer = setTimeout(() => {
+                this.updatePrevGestureEvents();
+                this.updateLastGestureEventTimer = null;
+            }, this.runtime.currentStepTime);
+        }
+        const gestureName = args.GESTURE;
+        const lastTimestamp =
+            this._peripheral.getGestureEventTimestamp(gestureName);
+        if (lastTimestamp === null) return false;
+        if (!this.prevGestureEvents[gestureName]) return true;
+        return lastTimestamp !== this.prevGestureEvents[gestureName];
+    }
+
+    /**
+     * Display pixcel pattern on the 5x5 LED matrix with brightness and write mode.
+     * @param {object} args - the block's arguments.
+     * @param {string} args.MATRIX - the pattern of the pixels.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} - a Promise that resolves after a tick or undefinde if yield.
+     */
+    displayMatrix (args, util) {
+        const matrixString = cast.toString(args.MATRIX)
+            .replace(/！-～/g, ws => String.fromCharCode(ws.charCodeAt(0) - 0xFEE0)); // zenkaku to hankaku
+        let matrixData;
+        if (matrixString.includes(',')) {
+            // comma separated values
+            matrixData = matrixString.split(/[,\n]/);
+        } else if (/[ \t]\d*[ \t]/g.test(matrixString)) {
+            // space|tab separated values
+            matrixData = matrixString.split(/\s/g);
+        } else {
+            // 0|1 pattern.
+            matrixData = matrixString.replace(/\s/g, '')
+                .split('');
+            matrixData = matrixData.map(level => ((level === '0') ? 0 : 100));
+        }
+        matrixData = matrixData.map(brightness =>
+            (Math.max(0,
+                Math.min(100,
+                    Number(brightness)) * 255 / 100))); // percent to 8bits value
+        const matrix = [];
+        for (let line = 0; line < 5; line++) {
+            matrix[line] = [];
+            for (let col = 0; col < 5; col++) {
+                matrix[line][col] = matrixData[(line * 5) + col];
+            }
+        }
+        return this._peripheral.displayPixels(matrix, util);
+    }
+
+    /**
+     * Display text on the 5x5 LED matrix.
+     * Displayable character is ascii and non-ascii is replaced to '?'.
+     * @param {object} args - the block's arguments.
+     * @param {string} args.TEXT - The contents to display.
+     * @param {number} args.DELAY - The time to delay between characters, in milliseconds.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {Promise} - a Promise that resolves after the text is done printing or undefinde if yield.
+     * Note the limit is 18 characters
+     * The print time is calculated by multiplying the number of horizontal pixels
+     * by the default scroll delay of 120ms.
+     * The number of horizontal pixels = 6px for each character in the string,
+     * 1px before the string, and 5px after the string.
+     */
+    displayText (args, util) {
+        const text = String(args.TEXT)
+            .replace(/！-～/g, zenkaku =>
+                String.fromCharCode(zenkaku.charCodeAt(0) - 0xFEE0)) // zenkaku to hankaku
+            .replace(/[^ -~]/g, '?');
+        let delay = parseInt(args.DELAY, 10);
+        delay = isNaN(delay) ? 120 : delay; // Use default delay if NaN.
+        const resultPromise = this._peripheral.displayText(text, delay, util);
+        if (!resultPromise) return; // This thread was yielded.
+        const yieldDelay = delay * ((6 * text.length) + 6);
+        return new Promise(resolve => {
+            setTimeout(() => {
+                resolve();
+            }, yieldDelay);
+        });
+    }
+
+    /**
+     * Turn all 5x5 matrix LEDs off.
+     * @param {object} args - the block's arguments.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {Promise} - a Promise that resolves after a tick or undefinde if yield.
+     */
+    displayClear (args, util) {
+        const matrix = [
+            [0, 0, 0, 0, 0],
+            [0, 0, 0, 0, 0],
+            [0, 0, 0, 0, 0],
+            [0, 0, 0, 0, 0],
+            [0, 0, 0, 0, 0]
+        ];
+        return this._peripheral.displayPixels(matrix, util);
+    }
+
+    /**
+     * Test the selected pin is high as digital.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @return {boolean} - true if the pin is high.
+     */
+    isPinHigh (args) {
+        return this._peripheral.isPinHigh(parseInt(args.PIN, 10));
+    }
+
+    /**
+     * Get amount of light (0 - 255) on the LEDs.
+     * @param {object} args - the block's arguments.
+     * @return {number} - light level.
+     */
+    getLightLevel () {
+        const level = this._peripheral.readLightLevel();
+        return Math.round(level * 1000 / 255) / 10;
+    }
+
+    /**
+     * Get temperature (integer in celsius) of micro:bit.
+     * @param {object} args - the block's arguments.
+     * @return {number} - value of temperature [centigrade].
+     */
+    getTemperature () {
+        return this._peripheral.readTemperature();
+    }
+
+    /**
+     * Get loudness of the sound from microphone on micro:bit.
+     * @param {object} args - the block's arguments.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {Promise} - a Promise that resolves digital input value of the pin or undefinde if yield.
+     */
+    getSoundLevel (args, util) {
+        const resultPromise = this._peripheral.configMic(true, util);
+        if (!resultPromise) return; // This thread was yielded.
+        return resultPromise
+            .then(micState => {
+                if (micState) {
+                    return Math.round(this._peripheral.readSoundLevel() * 1000 / 255) / 10;
+                }
+                return 0;
+            });
+    }
+
+    /**
+     * Return angle from the north to the micro:bit heading direction.
+     * @return {number} - degree of compass heading angle from the north (0 - 359 degrees).
+     */
+    getCompassHeading () {
+        return this._peripheral.readCompassHeading();
+    }
+
+    /**
+     * Return analog value of the pin.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} a Promise that resolves analog input value of the pin or undefined if this process was yield.
+     */
+    getAnalogValue (args, util) {
+        const pinIndex = parseInt(args.PIN, 10);
+        const resultPromise = this._peripheral.readAnalogIn(pinIndex, util);
+        if (!resultPromise) return;
+        return resultPromise.then(level => Math.round(level * 100 * 10 / 1024) / 10);
+    }
+
+    /**
+     * Return digital value of the pin.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @return {number} - digital input value of the pin.
+     */
+    getDigitalValue (args) {
+        return this._peripheral.readDigitalLevel(parseInt(args.PIN, 10));
+    }
+
+    /**
+     * Send data with label.
+     * @param {object} args - the block's arguments.
+     * @property {string} args.LABEL - label of the data.
+     * @property {string} args.DATA - content of the data.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {?Promise} - a Promise that resolves when the process was done or undefined if this process was yield.
+     */
+    sendData (args, util) {
+        if (args.LABEL.length <= 0) {
+            return;
+        }
+        return this._peripheral.sendData(args.LABEL, args.DATA, util);
+    }
+
+    /**
+     * Set pull mode of the pin.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {MbitMorePullModeName} args.MODE - mode to set.
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {promise | undefined} - a Promise that resolves when the command was sent
+     *                                 or undefined if this process was yield.
+     */
+    setPullMode (args, util) {
+        return this._peripheral.setPullMode(parseInt(args.PIN, 10), MbitMorePullModeID[args.MODE], util);
+    }
+
+    /**
+     * Set the pin to Output mode and level.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {boolean | string | number} args.LEVEL - value to be set.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {promise | undefined} - a Promise that resolves when the command was sent
+     *                                 or undefined if this process was yield.
+     */
+    setDigitalOut (args, util) {
+        let level = (args.LEVEL === true);
+        level = level || (args.LEVEL === 'true');
+        if (!level) {
+            const num = Number(args.LEVEL);
+            if (!isNaN(num)) {
+                level = (num > 0);
+            }
+        }
+        return this._peripheral.setPinOutput(parseInt(args.PIN, 10), level, util);
+    }
+
+    /**
+     * Set the pin to PWM mode and level.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {number} args.LEVEL - value[%] for PWM.
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {promise | undefined} - a Promise that resolves when the command was sent
+     *                                 or undefined if this process was yield.
+     */
+    setAnalogOut (args, util) {
+        let percent = parseInt(args.LEVEL, 10);
+        if (isNaN(percent)) {
+            return;
+        }
+        percent = Math.max(0, Math.min(percent, 100));
+        const level = Math.round(percent * 1024 / 100);
+        return this._peripheral.setPinPWM(
+            parseInt(args.PIN, 10),
+            level,
+            util
+        );
+    }
+
+    /**
+     * Set the pin to Servo mode and angle.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {promise | undefined} - a Promise that resolves when the command was sent
+     *                                 or undefined if this process was yield.
+     */
+    setServo (args, util) {
+        let angle = parseInt(args.ANGLE, 10);
+        if (isNaN(angle)) return;
+        angle = Math.max(0, angle);
+        angle = Math.min(angle, 180);
+        // let range = parseInt(args.RANGE, 10);
+        // if (isNaN(range)) range = 0;
+        // range = Math.max(0, range);
+        // let center = parseInt(args.CENTER, 10);
+        // if (isNaN(center)) range = 0;
+        // center = Math.max(0, center);
+        return this._peripheral.setPinServo(parseInt(args.PIN, 10), angle, null, null, util);
+    }
+
+    /**
+     * Return the value of magnetic force [micro tesla] on axis.
+     * @param {object} args - the block's arguments.
+     * @property {AxisSymbol} AXIS - the axis (X, Y, Z, Absolute).
+     * @return {number} - value of magnetic force.
+     */
+    getMagneticForce (args) {
+        return this._peripheral.readMagneticForce(args.AXIS);
+    }
+
+    /**
+     * Return the value of acceleration on the specified axis.
+     * @param {object} args - the block's arguments.
+     * @param {AxisSymbol} args.AXIS - direction to get.
+     * @return {number} - value of acceleration.
+     */
+    getAcceleration (args) {
+        return this._peripheral.readAcceleration(args.AXIS);
+    }
+
+    /**
+     * Return pitch [degrees] of the micro:bit heading direction.
+     * @return {number} - degree of pitch.
+     */
+    getPitch () {
+        return this._peripheral.readPitch();
+    }
+
+    /**
+     * Read roll [degrees] of the micro:bit heading direction.
+     * @return {number} - degree of roll.
+     */
+    getRoll () {
+        return this._peripheral.readRoll();
+    }
+
+
+    /**
+     * Play tone on the speaker.
+     * @param {object} args - the block's arguments.
+     * @param {string} args.FREQ - wave frequency to play
+     * @param {string} args.VOL laudness of tone
+     * @param {object} util - utility object provided by the runtime.
+     * @return {promise | undefined} - a Promise that resolves when the command was sent
+     *                                 or undefined if this process was yield.
+     */
+    playTone (args, util) {
+        const frequency = parseFloat(args.FREQ);
+        let volume = parseInt(args.VOL, 10);
+        volume = Math.min(100, (Math.max(0, volume)));
+        return this._peripheral.playTone(frequency, volume, util);
+    }
+
+    /**
+     * Stop playing tone on the speaker.
+     * @param {object} args - the block's arguments.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {promise | undefined} - a Promise that resolves when the command was sent
+     *                                 or undefined if this process was yield.
+     */
+    stopTone (args, util) {
+        return this._peripheral.stopTone(util);
+    }
+
+    /**
+     * Set listening event type at the pin.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {string} args.EVENT_TYPE - event to listen.
+     * @param {BlockUtility} util - utility object provided by the runtime.
+     * @return {promise | undefined} - a Promise that resolves when the command was sent
+     *                                 or undefined if this process was yield.
+    */
+    listenPinEventType (args, util) {
+        return this._peripheral.listenPinEventType(parseInt(args.PIN, 10), MbitMorePinEventType[args.EVENT_TYPE], util);
+    }
+
+    /**
+     * Rerutn value (timestamp of the edge or duration of the pulse) of the event or 0 when the event is not received.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {string} args.EVENT - event value to get.
+     * @param {object} util - utility object provided by the runtime.
+     * @return {number} - timestamp of the event or 0.
+     */
+    getPinEventValue (args) {
+        const value = this._peripheral.getPinEventValue(parseInt(args.PIN, 10), MbitMorePinEvent[args.EVENT]);
+        return value ? value : 0;
+    }
+
+    /**
+     * Update the previous occured time of all pin events.
+     */
+    updatePrevPinEvents () {
+        this.prevPinEvents = {};
+        Object.entries(this._peripheral._pinEvents).forEach(([pinIndex, events]) => {
+            this.prevPinEvents[pinIndex] = {};
+            Object.entries(events).forEach(([eventID, eventData]) => {
+                this.prevPinEvents[pinIndex][eventID] = {};
+                Object.entries(eventData).forEach(([key, value]) => {
+                    this.prevPinEvents[pinIndex][eventID][key] = value;
+                });
+            });
+        });
+    }
+
+    /**
+     * Return the previous timestamp of the pin event or undefined if the event was not received.
+     * @param {number} pinIndex - index of the pin to get the event.
+     * @param {MbitMorePinEvent} eventID - ID of the event to get.
+     * @return {?number} Timestamp of the previous event or null.
+     */
+    getPrevPinEventTimestamp (pinIndex, eventID) {
+        if (this.prevPinEvents[pinIndex] && this.prevPinEvents[pinIndex][eventID]) {
+            return this.prevPinEvents[pinIndex][eventID].timestamp;
+        }
+        return null;
+    }
+
+    /**
+     * Test whether the event raised at the pin.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.PIN - pin ID.
+     * @param {string} args.EVENT - event to catch.
+     * @return {boolean} - true if the event raised.
+     */
+    whenPinEvent (args) {
+        if (!this.updateLastPinEventTimer) {
+            this.updateLastPinEventTimer = setTimeout(() => {
+                this.updatePrevPinEvents();
+                this.updateLastPinEventTimer = null;
+            }, this.runtime.currentStepTime);
+        }
+        const pinIndex = parseInt(args.PIN, 10);
+        const eventID = MbitMorePinEvent[args.EVENT];
+        const lastTimestamp =
+            this._peripheral.getPinEventTimestamp(pinIndex, eventID);
+        if (lastTimestamp === null) return false;
+        const prevTimestamp = this.getPrevPinEventTimestamp(pinIndex, eventID);
+        if (prevTimestamp === null) return true;
+        return lastTimestamp !== prevTimestamp;
+    }
+
+    /**
+     * Rerutn the last content of the messge or undefined if the data which has the label is not received.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.LABEL - label of the data.
+     * @return {?(string | number)} - content of the data or empty string when the data was null
+     */
+    getDataLabeled (args) {
+        const data = this._peripheral.getDataLabeled(args.LABEL);
+        if (data === null) {
+            return '';
+        }
+        return data;
+    }
+
+    /**
+     * Update the previous occured time of all received data.
+     */
+    updatePrevReceivedData () {
+        this.prevReceivedData = {};
+        Object.entries(this._peripheral.receivedData).forEach(([label, contentObject]) => {
+            this.prevReceivedData[label] = {};
+            Object.entries(contentObject).forEach(([key, value]) => {
+                this.prevReceivedData[label][key] = value;
+            });
+        });
+    }
+
+    /**
+     * Return the previous timestamp of the data or undefined if the data was not received.
+     * @param {string} label - label of the data.
+     * @return {?number} Timestamp of the previous data or null.
+     */
+    getPrevReceivedDataTimestamp (label) {
+        if (this.prevReceivedData[label]) {
+            return this.prevReceivedData[label].timestamp;
+        }
+        return null;
+    }
+
+    /**
+     * Test whether the data received which had the label.
+     * @param {object} args - the block's arguments.
+     * @param {number} args.LABEL - label of the data.
+     * @return {boolean} - true if the data received.
+     */
+    whenDataReceived (args) {
+        if (!this.updateLastDataTimer) {
+            this.updateLastDataTimer = setTimeout(() => {
+                this.updatePrevReceivedData();
+                this.updateLastDataTimer = null;
+            }, this.runtime.currentStepTime);
+        }
+        const label = args.LABEL;
+        const lastTimestamp =
+            this._peripheral.getDataTimestamp(label);
+        if (lastTimestamp === null) return false;
+        const prevTimestamp = this.getPrevReceivedDataTimestamp(label);
+        if (prevTimestamp === null) return true;
+        return lastTimestamp !== prevTimestamp;
+    }
+
+    /**
+     * Test whether a micro:bit connected.
+     * @param {object} args - the block's arguments.
+     * @property {string} args.STATE - the state of connection to check.
+     * @return {boolean} - true if the state is matched.
+     */
+    whenConnectionChanged (args) {
+        const state = (args.STATE === 'connected');
+        return (state === this._peripheral.isConnected());
+    }
+
+    /**
+     * Setup format-message for this extension.
+     */
+    setupTranslations () {
+        const localeSetup = formatMessage.setup();
+        if (localeSetup && localeSetup.translations[localeSetup.locale]) {
+            Object.assign(
+                localeSetup.translations[localeSetup.locale],
+                // eslint-disable-next-line no-use-before-define
+                extensionTranslations[localeSetup.locale]
+            );
+        }
+    }
+}
+
+const extensionTranslations = {
+    'ja': {
+        'mbitMore.whenButtonEvent': 'ボタン [NAME] が [EVENT] とき',
+        'mbitMore.buttonIDMenu.a': 'A',
+        'mbitMore.buttonIDMenu.b': 'B',
+        'mbitMore.buttonEventMenu.down': '押された',
+        'mbitMore.buttonEventMenu.hold': '長押しされた',
+        'mbitMore.buttonEventMenu.up': '離された',
+        'mbitMore.buttonEventMenu.click': 'クリックされた',
+        'mbitMore.buttonEventMenu.longClick': 'ロングクリックされた',
+        'mbitMore.buttonEventMenu.doubleClick': 'ダブルクリックされた',
+        'mbitMore.isButtonPressed': 'ボタン [NAME] が押されている',
+        'mbitMore.whenTouchEvent': 'ピン [NAME] が [EVENT] とき',
+        'mbitMore.isPinTouched': 'ピン [NAME] がタッチされている',
+        'mbitMore.touchIDMenu.logo': 'ロゴ',
+        'mbitMore.touchEventMenu.touched': 'タッチされた',
+        'mbitMore.touchEventMenu.hold': '長押しされた',
+        'mbitMore.touchEventMenu.released': '離された',
+        'mbitMore.touchEventMenu.tapped': 'タップされた',
+        'mbitMore.touchEventMenu.longTapped': 'ロングタップされた',
+        'mbitMore.touchEventMenu.doubleTapped': 'ダブルタップされた',
+        'mbitMore.whenGesture': '[GESTURE] とき',
+        'mbitMore.gesturesMenu.tiltUp': '上へ傾いた',
+        'mbitMore.gesturesMenu.tiltDown': '下へ傾いた',
+        'mbitMore.gesturesMenu.tiltLeft': '左へ傾いた',
+        'mbitMore.gesturesMenu.tiltRight': '右へ傾いた',
+        'mbitMore.gesturesMenu.faceUp': '表になった',
+        'mbitMore.gesturesMenu.faceDown': '裏になった',
+        'mbitMore.gesturesMenu.freefall': '落ちた',
+        'mbitMore.gesturesMenu.g3': '3Gかかった',
+        'mbitMore.gesturesMenu.g6': '6Gかかった',
+        'mbitMore.gesturesMenu.g8': '8Gかかった',
+        'mbitMore.gesturesMenu.shake': 'ゆさぶられた',
+        'mbitMore.displayMatrix': 'パターン [MATRIX] を表示する',
+        'mbitMore.displayText': '文字 [TEXT] を [DELAY] ミリ秒間隔で流す',
+        'mbitMore.clearDisplay': '画面を消す',
+        'mbitMore.isPinHigh': 'ピン [PIN] がハイである',
+        'mbitMore.lightLevel': '明るさ',
+        'mbitMore.temperature': '温度',
+        'mbitMore.compassHeading': '北からの角度',
+        'mbitMore.magneticForce': '磁力 [AXIS]',
+        'mbitMore.acceleration': '加速度 [AXIS]',
+        'mbitMore.pitch': 'ピッチ',
+        'mbitMore.roll': 'ロール',
+        'mbitMore.soundLevel': '音の大きさ',
+        'mbitMore.analogValue': 'ピン [PIN] のアナログレベル',
+        'mbitMore.setPullMode': 'ピン [PIN] を [MODE] 入力にする',
+        'mbitMore.setDigitalOut': 'ピン [PIN] をデジタル出力 [LEVEL] にする',
+        'mbitMore.setAnalogOut': 'ピン [PIN] をアナログ出力 [LEVEL] %にする',
+        'mbitMore.playTone': '[FREQ] Hzの音を [VOL] %の大きさで鳴らす',
+        'mbitMore.stopTone': '音を止める',
+        'mbitMore.setServo': 'ピン [PIN] をサーボ [ANGLE] 度にする',
+        'mbitMore.digitalValueMenu.Low': 'ロー',
+        'mbitMore.digitalValueMenu.High': 'ハイ',
+        'mbitMore.axisMenu.x': 'x',
+        'mbitMore.axisMenu.y': 'y',
+        'mbitMore.axisMenu.z': 'z',
+        'mbitMore.axisMenu.absolute': '大きさ',
+        'mbitMore.pinModeMenu.pullNone': '開放',
+        'mbitMore.pinModeMenu.pullUp': 'プルアップ',
+        'mbitMore.pinModeMenu.pullDown': 'プルダウン',
+        'mbitMore.listenPinEventType': 'ピン [PIN] で [EVENT_TYPE] ',
+        'mbitMore.pinEventTypeMenu.none': 'イベントを受けない',
+        'mbitMore.pinEventTypeMenu.edge': 'エッジイベントを受ける',
+        'mbitMore.pinEventTypeMenu.pulse': 'パルスイベントを受ける',
+        'mbitMore.pinEventTypeMenu.touch': 'タッチイベントを受ける',
+        'mbitMore.whenPinEvent': 'ピン [PIN] で [EVENT] イベントが上がった',
+        'mbitMore.pinEventMenu.rise': 'ライズ',
+        'mbitMore.pinEventMenu.fall': 'フォール',
+        'mbitMore.pinEventMenu.pulseHigh': 'ハイパルス',
+        'mbitMore.pinEventMenu.pulseLow': 'ローパルス',
+        'mbitMore.getPinEventValue': 'ピン [PIN] の [EVENT]',
+        'mbitMore.pinEventTimestampMenu.rise': 'ライズの時刻',
+        'mbitMore.pinEventTimestampMenu.fall': 'フォールの時刻',
+        'mbitMore.pinEventTimestampMenu.pulseHigh': 'ハイパルスの期間',
+        'mbitMore.pinEventTimestampMenu.pulseLow': 'ローパルスの期間',
+        'mbitMore.whenDataReceived': 'micro:bit からラベル [LABEL] のデータを受け取ったとき',
+        'mbitMore.getDataLabeled': 'ラベル [LABEL] のデータ',
+        'mbitMore.sendData': 'micro:bit へデータ [DATA] にラベル [LABEL] を付けて送る',
+        'mbitMore.connectionStateMenu.connected': 'つながった',
+        'mbitMore.connectionStateMenu.disconnected': '切れた',
+        'mbitMore.whenConnectionChanged': 'micro:bit と[STATE]とき',
+        'mbitMore.selectCommunicationRoute.connectWith': 'つなぎ方',
+        'mbitMore.selectCommunicationRoute.bluetooth': 'Bluetooth',
+        'mbitMore.selectCommunicationRoute.usb': 'USB',
+        'mbitMore.selectCommunicationRoute.connect': 'つなぐ',
+        'mbitMore.selectCommunicationRoute.cancel': 'やめる'
+    },
+    'ja-Hira': {
+        'mbitMore.whenButtonEvent': '[NAME] ボタンが [EVENT] とき',
+        'mbitMore.buttonIDMenu.a': 'A',
+        'mbitMore.buttonIDMenu.b': 'B',
+        'mbitMore.buttonEventMenu.down': 'おされた',
+        'mbitMore.buttonEventMenu.hold': 'ながおしされた',
+        'mbitMore.buttonEventMenu.up': 'はなされた',
+        'mbitMore.buttonEventMenu.click': 'クリックされた',
+        'mbitMore.buttonEventMenu.longClick': 'ロングクリックされた',
+        'mbitMore.buttonEventMenu.doubleClick': 'ダブルクリックされた',
+        'mbitMore.isButtonPressed': '[NAME] ボタンがおされている',
+        'mbitMore.whenTouchEvent': 'ピン [NAME] が [EVENT] とき',
+        'mbitMore.isPinTouched': 'ピン [NAME] がタッチされている',
+        'mbitMore.touchIDMenu.logo': 'ロゴ',
+        'mbitMore.touchEventMenu.touched': 'タッチされた',
+        'mbitMore.touchEventMenu.hold': 'ながおしされた',
+        'mbitMore.touchEventMenu.released': 'はなされた',
+        'mbitMore.touchEventMenu.tapped': 'タップされた',
+        'mbitMore.touchEventMenu.longTapped': 'ロングタップされた',
+        'mbitMore.touchEventMenu.doubleTapped': 'ダブルタップされた',
+        'mbitMore.whenGesture': '[GESTURE] とき',
+        'mbitMore.gesturesMenu.tiltUp': 'うえへかたむいた',
+        'mbitMore.gesturesMenu.tiltDown': 'したへかたむいた',
+        'mbitMore.gesturesMenu.tiltLeft': 'ひだりへかたむいた',
+        'mbitMore.gesturesMenu.tiltRight': 'みぎへかたむいた',
+        'mbitMore.gesturesMenu.faceUp': 'おもてになった',
+        'mbitMore.gesturesMenu.faceDown': 'うらになった',
+        'mbitMore.gesturesMenu.freefall': 'おちた',
+        'mbitMore.gesturesMenu.g3': '3Gかかった',
+        'mbitMore.gesturesMenu.g6': '6Gかかった',
+        'mbitMore.gesturesMenu.g8': '8Gかかった',
+        'mbitMore.gesturesMenu.shake': 'ゆさぶられた',
+        'mbitMore.displayMatrix': 'パターン [MATRIX] をひょうじする',
+        'mbitMore.displayText': 'もじ [TEXT] を [DELAY] ミリびょうかんかくでながす',
+        'mbitMore.clearDisplay': 'がめんをけす',
+        'mbitMore.isPinHigh': 'ピン [PIN] がハイである',
+        'mbitMore.lightLevel': 'あかるさ',
+        'mbitMore.temperature': 'おんど',
+        'mbitMore.compassHeading': 'きたからのかくど',
+        'mbitMore.magneticForce': 'じりょく [AXIS]',
+        'mbitMore.acceleration': 'かそくど [AXIS]',
+        'mbitMore.pitch': 'ピッチ',
+        'mbitMore.roll': 'ロール',
+        'mbitMore.soundLevel': 'おとのおおきさ',
+        'mbitMore.analogValue': 'ピン [PIN] のアナログレベル',
+        'mbitMore.setPullMode': 'ピン [PIN] を [MODE] にゅうりょくにする',
+        'mbitMore.setDigitalOut': 'ピン [PIN] をデジタルしゅつりょく [LEVEL] にする',
+        'mbitMore.setAnalogOut': 'ピン [PIN] をアナログしゅつりょく [LEVEL] パーセントにする',
+        'mbitMore.playTone': '[FREQ] ヘルツのおとを [VOL] パーセントの大きさで鳴らす',
+        'mbitMore.stopTone': 'おとをとめる',
+        'mbitMore.setServo': 'ピン [PIN] をサーボ [ANGLE] どにする',
+        'mbitMore.digitalValueMenu.Low': 'ロー',
+        'mbitMore.digitalValueMenu.High': 'ハイ',
+        'mbitMore.axisMenu.x': 'x',
+        'mbitMore.axisMenu.y': 'y',
+        'mbitMore.axisMenu.z': 'z',
+        'mbitMore.axisMenu.absolute': 'おおきさ',
+        'mbitMore.pinModeMenu.pullNone': 'かいほう',
+        'mbitMore.pinModeMenu.pullUp': 'プルアップ',
+        'mbitMore.pinModeMenu.pullDown': 'プルダウン',
+        'mbitMore.listenPinEventType': 'ピン [PIN] で [EVENT_TYPE]',
+        'mbitMore.pinEventTypeMenu.none': 'イベントをうけない',
+        'mbitMore.pinEventTypeMenu.edge': 'エッジイベントをうける',
+        'mbitMore.pinEventTypeMenu.pulse': 'パルスイベントをうける',
+        'mbitMore.pinEventTypeMenu.touch': 'タッチイベントをうける',
+        'mbitMore.whenPinEvent': 'ピン [PIN] で [EVENT] イベントがあがった',
+        'mbitMore.pinEventMenu.rise': 'ライズ',
+        'mbitMore.pinEventMenu.fall': 'フォール',
+        'mbitMore.pinEventMenu.pulseHigh': 'ハイパルス',
+        'mbitMore.pinEventMenu.pulseLow': 'ローパルス',
+        'mbitMore.getPinEventValue': 'ピン [PIN] の [EVENT]',
+        'mbitMore.pinEventTimestampMenu.rise': 'ライズのじかん',
+        'mbitMore.pinEventTimestampMenu.fall': 'フォールのじかん',
+        'mbitMore.pinEventTimestampMenu.pulseHigh': 'ハイパルスのきかん',
+        'mbitMore.pinEventTimestampMenu.pulseLow': 'ローパルスのきかん',
+        'mbitMore.whenDataReceived': 'micro:bit からラベル [LABEL] のデータをうけとったとき',
+        'mbitMore.getDataLabeled': 'ラベル [LABEL] のデータ',
+        'mbitMore.sendData': 'micro:bit へデータ [DATA] にラベル [LABEL] をつけておくる',
+        'mbitMore.connectionStateMenu.connected': 'つながった',
+        'mbitMore.connectionStateMenu.disconnected': 'きれた',
+        'mbitMore.whenConnectionChanged': 'micro:bit と[STATE]とき',
+        'mbitMore.selectCommunicationRoute.connectWith': 'つなぎかた',
+        'mbitMore.selectCommunicationRoute.bluetooth': 'むせん',
+        'mbitMore.selectCommunicationRoute.usb': 'ゆうせん',
+        'mbitMore.selectCommunicationRoute.connect': 'つなぐ',
+        'mbitMore.selectCommunicationRoute.cancel': 'やめる'
+    },
+    'pt-br': {
+        'mbitMore.lightLevel': 'Intensidade da Luz',
+        'mbitMore.compassHeading': 'Está em direção ao Norte',
+        'mbitMore.magneticForce': 'Força Magnética [AXIS]',
+        'mbitMore.acceleration': 'Aceleração no Eixo[AXIS]',
+        'mbitMore.analogValue': 'Ler Pino Analógico [PIN]',
+        'mbitMore.setInput': 'Definir Pino[PIN] como entrada',
+        'mbitMore.setAnalogOut': 'Definir pino PWM[PIN]com[LEVEL]',
+        'mbitMore.setServo': 'Definir Servo no pino [PIN]com ângulo de [ANGLE]॰',
+        'mbitMore.digitalValueMenu.Low': 'desligado',
+        'mbitMore.digitalValueMenu.High': 'ligado'
+    },
+    'pt': {
+        'mbitMore.lightLevel': 'Intensidade da Luz',
+        'mbitMore.compassHeading': 'Está em direção ao Norte',
+        'mbitMore.magneticForce': 'Força Magnética [AXIS]',
+        'mbitMore.acceleration': 'Aceleração no Eixo[AXIS]',
+        'mbitMore.analogValue': 'Ler Pino Analógico [PIN]',
+        'mbitMore.setInput': 'Definir Pino[PIN] como entrada',
+        'mbitMore.setAnalogOut': 'Definir pino PWM[PIN]com[LEVEL]',
+        'mbitMore.setServo': 'Definir Servo no pino [PIN]com ângulo de [ANGLE]॰',
+        'mbitMore.digitalValueMenu.Low': 'desligado',
+        'mbitMore.digitalValueMenu.High': 'ligado'
+    } ,
+    'fr': {
+        'mbitMore.whenButtonEvent': 'quand le bouton [NAME] est [EVENT]',
+        'mbitMore.buttonIDMenu.a': 'A',
+        'mbitMore.buttonIDMenu.b': 'B',
+        'mbitMore.buttonEventMenu.down': 'appuyé',
+        'mbitMore.buttonEventMenu.up': 'relâché',
+        'mbitMore.buttonEventMenu.click': 'cliqué',
+        'mbitMore.isButtonPressed': 'bouton [NAME] est pressé ?',
+        'mbitMore.whenTouchEvent': 'quand [NAME] est [EVENT]',
+        'mbitMore.isPinTouched': '[NAME] est touché ?',
+        'mbitMore.touchIDMenu.logo': 'LOGO',
+        'mbitMore.touchEventMenu.touched': 'touché',
+        'mbitMore.touchEventMenu.released': 'relâché',
+        'mbitMore.touchEventMenu.tapped': 'tapé',
+        'mbitMore.whenGesture': 'quand micro:bit est [GESTURE]',
+        'mbitMore.gesturesMenu.tiltUp': 'incliné vers le haut',
+        'mbitMore.gesturesMenu.tiltDown': 'incliné vers le bas',
+        'mbitMore.gesturesMenu.tiltLeft': 'incliné vers la gauche',
+        'mbitMore.gesturesMenu.tiltRight': 'incliné vers la droite',
+        'mbitMore.gesturesMenu.faceUp': 'écran vers le haut',
+        'mbitMore.gesturesMenu.faceDown': 'écran vers le bas',
+        'mbitMore.gesturesMenu.freefall': 'en chute libre',
+        'mbitMore.gesturesMenu.g3': '3G',
+        'mbitMore.gesturesMenu.g6': '6G',
+        'mbitMore.gesturesMenu.g8': '8G',
+        'mbitMore.gesturesMenu.shake': 'secoué',
+        'mbitMore.displayMatrix': 'montrer LEDs [MATRIX]',
+        'mbitMore.displayText': 'afficher le texte [TEXT] avec un délai de [DELAY] ms',
+        'mbitMore.clearDisplay': 'effacer l\'écran',
+        'mbitMore.isPinHigh': 'broche [PIN] est activée ?',
+        'mbitMore.lightLevel': 'luminosité',
+        'mbitMore.temperature': 'température (°C)',
+        'mbitMore.compassHeading': 'direction de la boussole',
+        'mbitMore.magneticForce': 'force magnétique (µT) [AXIS]',
+        'mbitMore.acceleration': 'accélération (mg) [AXIS]',
+        'mbitMore.pitch': 'inclinaison haut-bas (°)',
+        'mbitMore.roll': 'inclinaison gauche-droite (°)',
+        'mbitMore.soundLevel': 'niveau sonore',
+        'mbitMore.analogValue': 'Lire la broche analogique [PIN]',
+        'mbitMore.setPullMode': 'régler la broche [PIN] sur [MODE]',
+        'mbitMore.setDigitalOut': 'Écrire sur la broche numérique [PIN] la valeur [LEVEL]',
+        'mbitMore.setAnalogOut': 'Écrire sur la broche analogique [PIN] la valeur [LEVEL]',
+        'mbitMore.playTone': 'jouer la fréquence [FREQ] Hz avec un volume de [VOL] %',
+        'mbitMore.stopTone': 'arrêter tous les sons',
+        'mbitMore.setServo': 'régler position servo de la broche [PIN] à [ANGLE] °',
+        'mbitMore.digitalValueMenu.Low': 'Bas',
+        'mbitMore.digitalValueMenu.High': 'Haut',
+        'mbitMore.axisMenu.x': 'x',
+        'mbitMore.axisMenu.y': 'y',
+        'mbitMore.axisMenu.z': 'z',
+        'mbitMore.axisMenu.absolute': 'force',
+        'mbitMore.pinModeMenu.pullNone': 'aucun',
+        'mbitMore.pinModeMenu.pullUp': 'haut',
+        'mbitMore.pinModeMenu.pullDown': 'bas',
+        'mbitMore.listenPinEventType': 'Capturer l\'évènement [EVENT_TYPE] sur [PIN]',
+        'mbitMore.pinEventTypeMenu.none': 'aucun',
+        'mbitMore.pinEventTypeMenu.edge': 'front',
+        'mbitMore.pinEventTypeMenu.pulse': 'impulsion',
+        'mbitMore.pinEventTypeMenu.touch': 'toucher',
+        'mbitMore.whenPinEvent': 'quand la broche [PIN] est [EVENT]',
+        'mbitMore.getPinEventValue': 'valeur de [EVENT] sur [PIN]',
+        'mbitMore.pinEventTimestampMenu.rise': 'augmentation',
+        'mbitMore.pinEventTimestampMenu.fall': 'diminution',
+        'mbitMore.pinEventTimestampMenu.pulseHigh': 'impulsion haute',
+        'mbitMore.pinEventTimestampMenu.pulseLow': 'impulsion basse',
+        'mbitMore.pinEventMenu.rise': 'augmentation',
+        'mbitMore.pinEventMenu.fall': 'diminution',
+        'mbitMore.pinEventMenu.pulseHigh': 'impulsion haute',
+        'mbitMore.pinEventMenu.pulseLow': 'impulsion basse',
+        'mbitMore.connectionStateMenu.connected': 'connecté',
+        'mbitMore.connectionStateMenu.disconnected': 'déconnecté',
+        'mbitMore.whenConnectionChanged': 'quand micro:bit est [STATE]',
+        'mbitMore.selectCommunicationRoute.bluetooth': 'Bluetooth',
+        'mbitMore.selectCommunicationRoute.usb': 'USB',
+    },
+};
+
+module.exports = MbitMoreBlocks;
diff --git a/node_modules/scratch-vm/src/extensions/microbitMore/serial-web.js b/node_modules/scratch-vm/src/extensions/microbitMore/serial-web.js
new file mode 100644
index 0000000..84fd745
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/microbitMore/serial-web.js
@@ -0,0 +1,541 @@
+const log = require('../../util/log');
+const Buffer = require('buffer');
+const arrayBufferToBase64 = buffer => Buffer.from(buffer).toString('base64');
+const base64ToUint8Array = base64 => Buffer.from(base64, 'base64');
+
+/**
+ * Characteristic ID on serial-port.
+ */
+const SERIAL_CH_ID = {
+    '0b500100-607f-4151-9091-7d008d6ffc5c': 0x0100,
+    '0b500101-607f-4151-9091-7d008d6ffc5c': 0x0101,
+    '0b500102-607f-4151-9091-7d008d6ffc5c': 0x0102,
+    '0b500110-607f-4151-9091-7d008d6ffc5c': 0x0110,
+    '0b500111-607f-4151-9091-7d008d6ffc5c': 0x0111,
+    '0b500120-607f-4151-9091-7d008d6ffc5c': 0x0120,
+    '0b500121-607f-4151-9091-7d008d6ffc5c': 0x0121,
+    '0b500122-607f-4151-9091-7d008d6ffc5c': 0x0122,
+    '0b500130-607f-4151-9091-7d008d6ffc5c': 0x0130
+};
+
+/**
+ * Start Frame Delimiter
+ */
+const SFD = 0xFF;
+
+/**
+ * Request type in data frame.
+ */
+const ChRequest = {
+    READ: 0x01,
+    WRITE: 0x10,
+    WRITE_RESPONSE: 0x11,
+    NOTIFY_STOP: 0x20,
+    NOTIFY_START: 0x21
+};
+
+/**
+ * Response type in data frame.
+ */
+const ChResponse = {
+    READ: 0x01,
+    WRITE_RESPONSE: 0x11,
+    NOTIFY: 0x21
+};
+
+/**
+ * Class to communicate with device via USB serial-port using Web Serial API.
+ */
+class WebSerial {
+
+    /**
+     * A BLE peripheral object.  It handles connecting, over Web Bluetooth API, to
+     * BLE peripherals, and reading and writing data to them.
+     * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
+     * @param {string} extensionId - the id of the extension using this object.
+     * @param {object} peripheralOptions - the list of options for peripheral discovery.
+     * @param {function} connectCallback - a callback for connection.
+     * @param {function} resetCallback - a callback for resetting extension state.
+     */
+    constructor (runtime, extensionId, peripheralOptions, connectCallback, resetCallback = null) {
+        /**
+         * Remote device which have been connected.
+         * @type {SerialPort}
+         */
+        this.port = null;
+
+        this._connectCallback = connectCallback;
+        this.state = 'init';
+        this._resetCallback = resetCallback;
+        this._extensionId = extensionId;
+        this._peripheralOptions = peripheralOptions;
+        this._serialOptions = {
+            // baudRate: 57600
+            baudRate: 115200 // Default for micro:bit
+        };
+        this._runtime = runtime;
+        this.receivingInterval = 1;
+        this.sendDataInterval = 10; // Time for receiving process in micro:bit
+
+        /**
+         * Store of received type and value for each characteristics.
+         * @type {Object.<number, Object.<number, Uint8Array>>} - { ch: { type: value }}.
+         */
+        this.chValues = {};
+
+        /**
+         * Notification callbacks.
+         * @type {Object.<number, function>} - { ch: callback }
+         */
+        this.notifyListeners = {};
+
+        this.requestPeripheral();
+    }
+
+    /**
+     * Request connection to the peripheral.
+     * Request user to choose a device, and then connect it automatically.
+     * @return {Promise} - a Promise which will resolved when a serial-port was selected.
+     */
+    requestPeripheral () {
+        let promise = Promise.resolve();
+        if (this.isConnected()) {
+            promise = promise.then(() => this.disconnect());
+        }
+        return promise.then(() => {
+            navigator.serial.requestPort(this._peripheralOptions)
+                .then(selected => {
+                    this.port = selected;
+                    this._runtime.connectPeripheral(this._extensionId, null);
+                })
+                .catch(e => {
+                    this._handleRequestError(e);
+                });
+        });
+    }
+
+    /**
+     * Try connecting to the serial-port of the device, and then call the connect
+     * callback when connection is successful.
+     */
+    connectPeripheral (/* id */) {
+        if (!this.port) {
+            throw new Error('device is not chosen');
+        }
+        class ChValueTransformer {
+            constructor () {
+                // A container for holding stream data until a new frame.
+                this.chunks = [];
+            }
+
+            transform (chunk, controller) {
+                // Append new chunks to existing chunks.
+                this.chunks = this.chunks.concat(Array.from(chunk));
+                // Split chunks into {ch: {type: value}.
+                // Skip until SFD occurred
+                const frameStart = this.chunks.findIndex(element => element === SFD);
+                if (frameStart === -1) {
+                    this.chunks = [];
+                    return;
+                }
+                this.chunks = this.chunks.slice(frameStart);
+                // Read header
+                if (this.chunks.length < 5) {
+                    return;
+                }
+                const type = this.chunks[1];
+                if (type > ChResponse.NOTIFY) {
+                    this.chunks = []; // remove all until SFD + valid type
+                    return;
+                }
+                const ch = (this.chunks[2] << 8) | this.chunks[3];
+                const valueLength = this.chunks[4];
+                const frameEnd = 5 + valueLength;
+                if (this.chunks.length < (frameEnd + 1)) {
+                    return;
+                }
+                const value = this.chunks.slice(5, frameEnd);
+                // Checksum
+                const checksum = this.chunks.slice(0, frameEnd).reduce((acc, cur) => acc + cur) % 0xFF;
+                if (checksum === this.chunks[frameEnd]) {
+                    // Received successfully
+                    this.chunks.splice(0, frameEnd + 1);
+                    controller.enqueue({ch: ch, data: {type: type, value: value}});
+                } else {
+                    // Error occurred
+                    log.debug(this.chunks); // debug
+                    this.chunks.shift(); // Remove current SFD
+                    return;
+                }
+            }
+
+            flush (controller) {
+                // When the stream is closed, delete any remaining chunks.
+                controller.terminate();
+            }
+        }
+        this.port.open(this._serialOptions)
+            .then(() => {
+                log.log(`SerialPort: open`);
+                this.state = 'open';
+                this.writer = this.port.writable.getWriter();
+                // eslint-disable-next-line no-undef
+                const chValueTransformStream = new TransformStream(new ChValueTransformer());
+                this.readableStreamClosed = this.port.readable.pipeTo(chValueTransformStream.writable);
+                this.reader = chValueTransformStream.readable.getReader();
+                this.port.addEventListener('disconnect',
+                    event => {
+                        this.onDisconnected(event);
+                    });
+                this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);
+                this._connectCallback();
+                this.startReceiving();
+            });
+    }
+
+    /**
+     * Disconnect from the device and clean up.
+     * Then emit the connection state by the runtime.
+     * @return {Promise} - a Promise which will resolve when the serial-port was disconnected.
+     */
+    disconnect () {
+        if (this.state !== 'open') return Promise.resolve();
+        this.state = 'closing';
+        this.stopReceiving();
+        return this.reader.cancel()
+            .then(() => this.readableStreamClosed.catch(() => { /* Ignore the error */ }))
+            .then(() => {
+                this.writer.close();
+                this.writer.releaseLock();
+                return this.write.closed;
+            })
+            .then(() => {
+                this.port.close();
+                this.state = 'close';
+                this.reader = null;
+                this.writer = null;
+                this.port = null;
+                this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
+            });
+    }
+
+    /**
+     * @return {bool} whether the peripheral is connected.
+     */
+    isConnected () {
+        return this.state === 'open';
+    }
+
+    /**
+     * Receive data and process it.
+     * @returns {Promise} - a Promise which will resolve when read next data
+     */
+    receiveData () {
+        return this.reader.read()
+            .then(result => {
+                const {value, done} = result;
+                if (done) {
+                    this.reader.releaseLock();
+                }
+                if (value) {
+                    const data = value.data;
+                    const ch = value.ch;
+                    if (!this.chValues[ch]) {
+                        this.chValues[ch] = {};
+                    }
+                    this.chValues[ch][data.type] = data.value;
+                    if (data.type === ChResponse.NOTIFY) {
+                        if (ch in this.notifyListeners) {
+                            this.notifyListeners[ch](arrayBufferToBase64(data.value));
+                        }
+                    }
+                    // log.debug({ch: ch, type: data.type, value: data.value});
+                }
+            });
+    }
+
+    /**
+     * Start data receiving process.
+     */
+    startReceiving () {
+        this.dataReceiving = window.setTimeout(() => {
+            if (this.state !== 'open') return;
+            this.receiveData()
+                .then(() => {
+                    // start again
+                    this.startReceiving();
+                })
+                .catch(() => {
+                    this.handleDisconnectError();
+                });
+        }, this.receivingInterval);
+    }
+
+    /**
+     * Stop data receiving process.
+     */
+    stopReceiving () {
+        clearTimeout(this.dataReceiving);
+        this.dataReceiving = null;
+    }
+
+    /**
+     * Send data to the device.
+     * @param {Uint8Array} data - data to send
+     * @returns {Promise} - a Promise which will resolve write process was done
+     */
+    sendData (data) {
+        return this.writer.ready
+            .then(() => this.writer.write(data))
+            .then(() => new Promise(resolve => {
+                setTimeout(() => resolve(), this.sendDataInterval); // Wait for receiving process in micro:bit
+            }));
+    }
+
+    /**
+     * Start receiving notifications from the device.
+     * @param {number} _serviceId - the ble service to read. (ignore it for serial-port)
+     * @param {number} characteristicId - the ble characteristic to get notifications from.
+     * @param {function?} onCharacteristicChanged - callback for characteristic change notifications
+     *  like function(base64message).
+     * @return {Promise} - a Promise which will resolve when requested start notification.
+     */
+    startNotifications (_serviceId, characteristicId, onCharacteristicChanged = null) {
+        // Connected device will start necessary notifications automatically on serial-port.
+        this.notifyListeners[SERIAL_CH_ID[characteristicId]] = onCharacteristicChanged;
+        return Promise.resolve();
+    }
+
+    readCh (ch) {
+        if (this.state !== 'open') {
+            return Promise.reject(new Error('port is not opened'));
+        }
+        return new Promise(resolve => {
+            const dataFrame = new Uint8Array(4);
+            dataFrame[0] = SFD;
+            dataFrame[1] = ChRequest.READ;
+            dataFrame[2] = ch >> 8;
+            dataFrame[3] = ch & 0xFF;
+            if (this.chValues[ch]) {
+                this.chValues[ch][ChResponse.READ] = null;
+            }
+            this.sendData(dataFrame)
+                .then(() => {
+                    const checkInterval = 10;
+                    const check = count => {
+                        const received = this.chValues[ch];
+                        if (received && received[ChResponse.READ]) {
+                            return resolve({
+                                message: arrayBufferToBase64(received[ChResponse.READ])
+                            });
+                        }
+                        count--;
+                        if (count === 0) {
+                            return resolve(null);
+                        }
+                        setTimeout(() => {
+                            check(count);
+                        }, checkInterval);
+                    };
+                    check(20);
+                });
+        });
+    }
+
+    /**
+     * Read from the specified ble service.
+     * @param {number} serviceId - the ble service to read.
+     * @param {number} characteristicId - the ble characteristic to read.
+     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
+     * @param {function} onCharacteristicChanged - callback for characteristic change notifications
+     *  like function(base64message).
+     * @return {Promise} - a Promise from the remote read request which resolve {message: base64string}.
+     */
+    read (serviceId, characteristicId, optStartNotifications = false, onCharacteristicChanged = null) {
+        const ch = SERIAL_CH_ID[characteristicId];
+        const constantUpdatingCh = [
+            0x0101, /* State */
+            0x0102 /* Motion */
+        ];
+        if (constantUpdatingCh.includes(ch)) {
+            // Return already received values because rapid repeating requests will make the port freeze.
+            if (!this.chValues[ch]) {
+                return Promise.resolve(null);
+            }
+            return Promise.resolve({
+                message: arrayBufferToBase64(this.chValues[ch][ChResponse.READ])
+            });
+        }
+        const readRetry = count => new Promise((resolve, reject) => {
+            if (count < 0) {
+                reject(new Error(`no response`));
+                log.debug(`read ch: ${ch} dose not response`);
+                return;
+            }
+            this.readCh(ch)
+                .then(result => {
+                    if (result) {
+                        if (optStartNotifications) {
+                            this.startNotifications(serviceId, characteristicId, onCharacteristicChanged)
+                                .then(() => resolve(result));
+                            return;
+                        }
+                        resolve(result);
+                        return;
+                    }
+                    count--;
+                    resolve(readRetry(count));
+                    return;
+                })
+                .catch(err => {
+                    resolve(null);
+                    log.debug(err);
+                    return;
+                });
+        });
+        return readRetry(2)
+            .catch(err => {
+                log.debug(err);
+                this.handleDisconnectError(err);
+                return;
+            });
+    }
+    
+    /**
+     * Write value on the characteristic.
+     * @param {number} ch - characteristic to write
+     * @param {Uint8Array} value - value to write
+     * @param {boolean} withResponse - whether request response or not
+     * @returns {Promise} - a Promise which will resolve true when success to write
+     */
+    writeCh (ch, value, withResponse) {
+        if (this.state !== 'open') {
+            return Promise.reject(new Error('port is not opened'));
+        }
+        return new Promise(resolve => {
+            const header = new Uint8Array(5);
+            header[0] = SFD;
+            header[1] = withResponse ? ChRequest.WRITE_RESPONSE : ChRequest.WRITE;
+            header[2] = ch >> 8;
+            header[3] = ch & 0xFF;
+            header[4] = value.length;
+            const dataFrame = new Uint8Array([...header, ...value, 0]);
+            dataFrame[dataFrame.length - 1] = dataFrame.reduce((acc, cur) => acc + cur) % 0xFF;
+            if (withResponse) {
+                this.sendData(dataFrame)
+                    .then(() => {
+                        const checkInterval = 10;
+                        const check = count => {
+                            const received = this.chValues[ch];
+                            if (received && (received[ChResponse.WRITE_RESPONSE])) {
+                                return resolve(received[ChResponse.WRITE_RESPONSE][0] === 1);
+                            }
+                            count--;
+                            if (count === 0) {
+                                return resolve(false);
+                            }
+                            setTimeout(() => {
+                                check(count);
+                            }, checkInterval);
+                        };
+                        check(20);
+                    });
+            } else {
+                this.sendData(dataFrame)
+                    .then(() => resolve(true));
+            }
+        });
+    }
+
+    /**
+     * Write data to the specified ble service.
+     * @param {number} serviceId - the ble service to write.
+     * @param {number} characteristicId - the ble characteristic to write.
+     * @param {string} message - the message to send.
+     * @param {string} encoding - the message encoding type.
+     * @param {boolean} withResponse - if true, resolve after peripheral's response. Always true for serial port.
+     * @return {Promise} - a Promise which will resolve true when success to write or reject with 'no response'
+     */
+    // eslint-disable-next-line no-unused-vars
+    write (serviceId, characteristicId, message, encoding = null, withResponse = null) {
+        withResponse = true; // "response" is always required for noise tolerance on serial-port.
+        const value = (encoding === 'base64') ? base64ToUint8Array(message) : message;
+        const ch = SERIAL_CH_ID[characteristicId];
+        if (this.chValues[ch]) {
+            this.chValues[ch][ChResponse.WRITE_RESPONSE] = null;
+        }
+        const writeRetry = count => new Promise((resolve, reject) => {
+            if (count < 0) {
+                reject(new Error(`no response`));
+                log.debug(`write ch: ${ch} dose not response`);
+                return;
+            }
+            this.writeCh(ch, value, withResponse)
+                .then(result => {
+                    if (result) {
+                        resolve(result);
+                        return;
+                    }
+                    count--;
+                    resolve(writeRetry(count));
+                    return;
+                })
+                .catch(err => {
+                    resolve(null);
+                    log.debug(err);
+                    return;
+                });
+        });
+        return writeRetry(2)
+            .catch(err => {
+                log.debug(err);
+                this.handleDisconnectError(err);
+                return;
+            });
+    }
+
+    /**
+     * Handle an error resulting from losing connection to a peripheral.
+     *
+     * This could be due to:
+     * - battery depletion
+     * - going out of bluetooth range
+     * - being powered down
+     *
+     * Disconnect the device, and if the extension using this object has a
+     * reset callback, call it. Finally, emit an error to the runtime.
+     */
+    handleDisconnectError (/* e */) {
+        if (this.state !== 'open') return;
+
+        this.disconnect()
+            .then(() => {
+                if (this._resetCallback) {
+                    this._resetCallback();
+                }
+
+                this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
+                    message: `Scratch lost connection to`,
+                    extensionId: this._extensionId
+                });
+            });
+    }
+
+    _handleRequestError (/* e */) {
+        // log.error(`BLE error: ${JSON.stringify(e)}`);
+
+        this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
+            message: `Scratch lost connection to`,
+            extensionId: this._extensionId
+        });
+    }
+
+    /**
+     * Called when disconnected by the device.
+     */
+    onDisconnected (/* event */) {
+        this.handleDisconnectError(new Error('device disconnected'));
+    }
+}
+
+module.exports = WebSerial;
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_bodydetection/index.js b/node_modules/scratch-vm/src/extensions/scratch3_bodydetection/index.js
new file mode 100644
index 0000000..d939409
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_bodydetection/index.js
@@ -0,0 +1,671 @@
+// Importation des modules nécessaires pour l'extension Scratch
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const Timer = require('../../util/timer');
+const ml5 = require('ml5'); // Bibliothèque ml5 pour utiliser les modèles de machine learning
+const formatMessage = require('format-message'); // Gestion des messages multilingues
+// Icone pour l'extension
+const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDUwMCA1MDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM6c2VyaWY9Imh0dHA6Ly93d3cuc2VyaWYuY29tLyIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoyOyI+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNLTAuNSw0OTYuNUMwLjQwNCw0OTcuMjA5IDAuNzM3LDQ5OC4yMDkgMC41LDQ5OS41TC0wLjUsNDk5LjVMLTAuNSw0OTYuNVoiIHN0eWxlPSJmaWxsOnJnYigzNiw4MiwzMik7ZmlsbC1vcGFjaXR5OjAuMDI7Ii8+CiAgICAgICAgPHJlY3QgeD0iLTcuMDk0IiB5PSItNi4zNDgiIHdpZHRoPSI1MTkuMjc1IiBoZWlnaHQ9IjU1Mi41MiIgc3R5bGU9ImZpbGw6cmdiKDEzLDE4OSwxNDApOyIvPgogICAgPC9nPgogICAgPGcgaWQ9Il9JbWFnZTFfIiBzZXJpZjppZD0iX0ltYWdlMSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNzguNjc3LDkuMTYxKSI+CiAgICAgICAgPHVzZSB4bGluazpocmVmPSIjX0ltYWdlMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjE0MHB4IiBoZWlnaHQ9IjQ4NXB4Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjY5LjUsMzAuNUwyNjIuNSwzMC41QzI1OC40MDYsMjAuMDk2IDI2MS41NzIsMTYuNzYyIDI3MiwyMC41QzI3Mi42NjcsMjMuMTY3IDI3Mi42NjcsMjUuODMzIDI3MiwyOC41QzI3MS4yOTIsMjkuMzgxIDI3MC40NTgsMzAuMDQ3IDI2OS41LDMwLjVaIiBzdHlsZT0iZmlsbDpyZ2IoMzIsODgsMTgpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI2Mi41LDMwLjVMMjY5LjUsMzAuNUMyNjcuMTk1LDQ4Ljc5NCAyNjUuMTk1LDY3LjEyNyAyNjMuNSw4NS41QzI2MS45NDcsODMuNjE1IDI1OS45NDcsODIuNjE1IDI1Ny41LDgyLjVDMjU4LjkxOCw2NC45OTYgMjYwLjU4NCw0Ny42NjMgMjYyLjUsMzAuNVoiIHN0eWxlPSJmaWxsOnJnYigxMDQsMjA4LDc0KTsiLz4KICAgIDwvZz4KICAgIDxnPgogICAgICAgIDxwYXRoIGQ9Ik0yNTcuNSw4Mi41QzI1OS45NDcsODIuNjE1IDI2MS45NDcsODMuNjE1IDI2My41LDg1LjVDMjY0LjExLDg2LjM5MSAyNjQuNDQzLDg3LjM5MSAyNjQuNSw4OC41QzI2NC4zNzEsOTAuMjE2IDI2NC4wMzgsOTEuODgzIDI2My41LDkzLjVDMjYxLjQwOSw5NC44NjUgMjU5LjA3Niw5NS41MzIgMjU2LjUsOTUuNUMyNTQuMjQ2LDk0Ljg3NiAyNTIuNTc5LDkzLjU0MyAyNTEuNSw5MS41QzI1MS4yNzcsODYuOTMxIDI1My4yNzcsODMuOTMxIDI1Ny41LDgyLjVaIiBzdHlsZT0iZmlsbDpyZ2IoMzEsOTIsMTYpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI2NC41LDg4LjVDMjc2LjAzOCw5Mi43MTQgMjg3LjM3Miw5Ny4zODEgMjk4LjUsMTAyLjVDMjk3LjI0OCwxMDQuMDAxIDI5Ni4yNDgsMTA1LjY2OCAyOTUuNSwxMDcuNUMyODUuMTYyLDEwMy40OTkgMjc0LjgyOCw5OS40OTkgMjY0LjUsOTUuNUMyNjIuMzIzLDk2LjUwNCAyNjEuOTg5LDk1LjgzOCAyNjMuNSw5My41QzI2NC4wMzgsOTEuODgzIDI2NC4zNzEsOTAuMjE2IDI2NC41LDg4LjVaIiBzdHlsZT0iZmlsbDpyZ2IoODEsMTc1LDU3KTsiLz4KICAgIDwvZz4KICAgIDxnPgogICAgICAgIDxwYXRoIGQ9Ik0yNjMuNSw5My41QzI2MS45ODksOTUuODM4IDI2Mi4zMjMsOTYuNTA0IDI2NC41LDk1LjVDMjY4LjU3MSwxMTQuMzg3IDI3Mi4yMzgsMTMzLjM4NyAyNzUuNSwxNTIuNUMyNzMuNzM1LDE1My40NjEgMjcxLjczNSwxNTMuNzk1IDI2OS41LDE1My41QzI2Ni4wOSwxMzYuMTE4IDI2Mi40MjMsMTE4Ljc4NCAyNTguNSwxMDEuNUMyNTguNzQxLDk5LjExNCAyNTguMDc1LDk3LjExNCAyNTYuNSw5NS41QzI1OS4wNzYsOTUuNTMyIDI2MS40MDksOTQuODY1IDI2My41LDkzLjVaIiBzdHlsZT0iZmlsbDpyZ2IoNTgsMTMzLDM5KTsiLz4KICAgIDwvZz4KICAgIDxnPgogICAgICAgIDxwYXRoIGQ9Ik0yNjQuNSw5NS41QzI3NC44MjgsOTkuNDk5IDI4NS4xNjIsMTAzLjQ5OSAyOTUuNSwxMDcuNUMyOTUuNzMxLDExMC41ODggMjk3LjA2NCwxMTIuOTIxIDI5OS41LDExNC41TDI5OS41LDE2My41QzI5OS4xNjcsMTY0LjE2NyAyOTguODMzLDE2NC44MzMgMjk4LjUsMTY1LjVDMjkyLjk3MSwxNjQuMDQgMjg3LjMwNCwxNjMuMjA3IDI4MS41LDE2M0MyNzkuMTM3LDE2Mi40MTEgMjc4LjEzNywxNjAuOTExIDI3OC41LDE1OC41QzI4MC41LDE1OC4xNjcgMjgyLjUsMTU3LjgzMyAyODQuNSwxNTcuNUMyOTAuNTA5LDE2Mi4yOTYgMjk0LjUwOSwxNjAuOTYzIDI5Ni41LDE1My41QzI5My4zMywxNDUuMjIxIDI4OC45OTcsMTQ0LjU1NCAyODMuNSwxNTEuNUMyODAuODMzLDE1MS44MzMgMjc4LjE2NywxNTIuMTY3IDI3NS41LDE1Mi41QzI3Mi4yMzgsMTMzLjM4NyAyNjguNTcxLDExNC4zODcgMjY0LjUsOTUuNVoiIHN0eWxlPSJmaWxsOnJnYigyNTEsMjUzLDI1MSk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjI5LjUsMTU0LjVDMjI3LjI3NSwxNDkuODkxIDIyMy42MDksMTQ4LjM5MSAyMTguNSwxNTBDMjE1Ljk1OCwxNTMuNzYzIDIxNS45NTgsMTU3LjU5NyAyMTguNSwxNjEuNUwyMTMuNSwxNjEuNUMyMTIuNjA5LDE2MC44OSAyMTEuNjA5LDE2MC41NTcgMjEwLjUsMTYwLjVDMjEyLjQ1NiwxNDQuODc0IDIxNC4xMjMsMTI5LjIwOCAyMTUuNSwxMTMuNUMyMTcuODczLDExMS40MjEgMjE5LjIwNiwxMDguNzU0IDIxOS41LDEwNS41QzIzMC4yMzEsMTAzLjAzMyAyNDAuODk4LDEwMC4zNjYgMjUxLjUsOTcuNUMyNDcuODMzLDExNS44MzkgMjQ0LDEzNC4xNzIgMjQwLDE1Mi41QzIzNi44NTEsMTU0LjM2MiAyMzMuMzUxLDE1NS4wMjkgMjI5LjUsMTU0LjVaIiBzdHlsZT0iZmlsbDpyZ2IoMjUwLDI1MywyNTApOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTIxNi41LDEwMC41QzIxNy4zNiwxMDIuMjg4IDIxOC4zNiwxMDMuOTU1IDIxOS41LDEwNS41QzIxOS4yMDYsMTA4Ljc1NCAyMTcuODczLDExMS40MjEgMjE1LjUsMTEzLjVDMjEzLjA5NywxMTMuNTUyIDIxMC43NjQsMTEzLjIxOSAyMDguNSwxMTIuNUMyMDQuMjEsMTA0LjEgMjA2Ljg3NywxMDAuMSAyMTYuNSwxMDAuNVoiIHN0eWxlPSJmaWxsOnJnYigzOCw5OCwyMyk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjU4LjUsMTAxLjVDMjYyLjQyMywxMTguNzg0IDI2Ni4wOSwxMzYuMTE4IDI2OS41LDE1My41QzI2MS45NzgsMTU0LjYxNSAyNTQuMzEyLDE1NS42MTUgMjQ2LjUsMTU2LjVDMjQ5LjE5LDEzOS4wODEgMjUyLjUyMywxMjEuNzQ4IDI1Ni41LDEwNC41QzI1Ni42NCwxMDIuOTcgMjU3LjMwNywxMDEuOTcgMjU4LjUsMTAxLjVaIiBzdHlsZT0iZmlsbDpyZ2IoMjQ4LDI1MiwyNDcpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI5OC41LDEwMi41QzMwNS44MTksMTAwLjY4MSAzMDkuMzE5LDEwMy4zNDcgMzA5LDExMC41QzMwOC42MjMsMTExLjk0MiAzMDcuNzksMTEyLjk0MiAzMDYuNSwxMTMuNUMzMDQuMjM2LDExNC4yMTkgMzAxLjkwMywxMTQuNTUyIDI5OS41LDExNC41QzI5Ny4wNjQsMTEyLjkyMSAyOTUuNzMxLDExMC41ODggMjk1LjUsMTA3LjVDMjk2LjI0OCwxMDUuNjY4IDI5Ny4yNDgsMTA0LjAwMSAyOTguNSwxMDIuNVoiIHN0eWxlPSJmaWxsOnJnYigzOSwxMDAsMjMpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTIwOC41LDExMi41QzIxMC43NjQsMTEzLjIxOSAyMTMuMDk3LDExMy41NTIgMjE1LjUsMTEzLjVDMjE0LjEyMywxMjkuMjA4IDIxMi40NTYsMTQ0Ljg3NCAyMTAuNSwxNjAuNUMyMDYuMjUsMTYwLjI5MiAyMDMuMjUsMTYyLjEyNSAyMDEuNSwxNjZDMjAzLjU3NiwxNjcuMjQ0IDIwNC41NzYsMTY5LjA3NyAyMDQuNSwxNzEuNUMxOTkuOTE4LDE2OC43NjEgMTk5LjQxOCwxNjUuNDI4IDIwMywxNjEuNUMyMDUuNzc4LDE0NS4yNzkgMjA3LjYxMSwxMjguOTQ2IDIwOC41LDExMi41WiIgc3R5bGU9ImZpbGw6cmdiKDYwLDEzMiw0MSk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMzA2LjUsMTEzLjVMMzA2LjUsMTYzLjVMMjk5LjUsMTYzLjVMMjk5LjUsMTE0LjVDMzAxLjkwMywxMTQuNTUyIDMwNC4yMzYsMTE0LjIxOSAzMDYuNSwxMTMuNVoiIHN0eWxlPSJmaWxsOnJnYig3NywxNTcsNTYpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTIyOS41LDE1NC41QzIyOC41LDE2MS4xNjIgMjI0LjgzNCwxNjMuNDk1IDIxOC41LDE2MS41QzIxNS45NTgsMTU3LjU5NyAyMTUuOTU4LDE1My43NjMgMjE4LjUsMTUwQzIyMy42MDksMTQ4LjM5MSAyMjcuMjc1LDE0OS44OTEgMjI5LjUsMTU0LjVaIiBzdHlsZT0iZmlsbDpyZ2IoMzEsODgsMTcpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI1MS41LDkxLjVDMjUyLjU3OSw5My41NDMgMjU0LjI0Niw5NC44NzYgMjU2LjUsOTUuNUMyNTguMDc1LDk3LjExNCAyNTguNzQxLDk5LjExNCAyNTguNSwxMDEuNUMyNTcuMzA3LDEwMS45NyAyNTYuNjQsMTAyLjk3IDI1Ni41LDEwNC41QzI1Mi41MjMsMTIxLjc0OCAyNDkuMTksMTM5LjA4MSAyNDYuNSwxNTYuNUMyNTQuMzEyLDE1NS42MTUgMjYxLjk3OCwxNTQuNjE1IDI2OS41LDE1My41QzI3MS43MzUsMTUzLjc5NSAyNzMuNzM1LDE1My40NjEgMjc1LjUsMTUyLjVDMjc4LjE2NywxNTIuMTY3IDI4MC44MzMsMTUxLjgzMyAyODMuNSwxNTEuNUMyODMuNTE3LDE1My41NjUgMjgzLjg1LDE1NS41NjUgMjg0LjUsMTU3LjVDMjgyLjUsMTU3LjgzMyAyODAuNSwxNTguMTY3IDI3OC41LDE1OC41QzI3OC4xMzcsMTYwLjkxMSAyNzkuMTM3LDE2Mi40MTEgMjgxLjUsMTYzQzI4Ny4zMDQsMTYzLjIwNyAyOTIuOTcxLDE2NC4wNCAyOTguNSwxNjUuNUMyOTcuMDU4LDE2Ni44MiAyOTYuMzkyLDE2OC40ODYgMjk2LjUsMTcwLjVDMjkxLjA3LDE3MC40ODMgMjg1LjczNywxNjkuODE3IDI4MC41LDE2OC41QzI3OC4wMjEsMTY3LjM3NyAyNzUuNjg4LDE2Ny4zNzcgMjczLjUsMTY4LjVDMjcyLjcxMSwxNjguMjE3IDI3Mi4wNDQsMTY3LjcxNyAyNzEuNSwxNjdDMjY1LjAyNSwxNjYuODM2IDI1OC42OTEsMTY1LjgzNiAyNTIuNSwxNjRDMjQ5LjU3MSwxNjMuMjIzIDI0Ni43MzcsMTYzLjM5IDI0NCwxNjQuNUMyMzcuNzU5LDE5NC4yMDUgMjMxLjU5MywyMjMuODcyIDIyNS41LDI1My41QzIyMy42MjEsMjUyLjY1OSAyMjEuNjIxLDI1Mi4zMjUgMjE5LjUsMjUyLjVDMjI0LjUyOSwyMjMuNDY2IDIzMC41MjksMTk0LjYzMiAyMzcuNSwxNjZDMjI5Ljg1NiwxNjYuMzYzIDIyMi4xOSwxNjYuODYzIDIxNC41LDE2Ny41QzIxNC42NzUsMTY1LjM3OSAyMTQuMzQxLDE2My4zNzkgMjEzLjUsMTYxLjVMMjE4LjUsMTYxLjVDMjI0LjgzNCwxNjMuNDk1IDIyOC41LDE2MS4xNjIgMjI5LjUsMTU0LjVDMjMzLjM1MSwxNTUuMDI5IDIzNi44NTEsMTU0LjM2MiAyNDAsMTUyLjVDMjQ0LDEzNC4xNzIgMjQ3LjgzMywxMTUuODM5IDI1MS41LDk3LjVDMjQwLjg5OCwxMDAuMzY2IDIzMC4yMzEsMTAzLjAzMyAyMTkuNSwxMDUuNUMyMTguMzYsMTAzLjk1NSAyMTcuMzYsMTAyLjI4OCAyMTYuNSwxMDAuNUMyMjguMDA5LDk3LjI2OCAyMzkuNjc1LDk0LjI2OCAyNTEuNSw5MS41WiIgc3R5bGU9ImZpbGw6cmdiKDExNywyMTgsODQpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI4NC41LDE1Ny41QzI4My44NSwxNTUuNTY1IDI4My41MTcsMTUzLjU2NSAyODMuNSwxNTEuNUMyODguOTk3LDE0NC41NTQgMjkzLjMzLDE0NS4yMjEgMjk2LjUsMTUzLjVDMjk0LjUwOSwxNjAuOTYzIDI5MC41MDksMTYyLjI5NiAyODQuNSwxNTcuNVoiIHN0eWxlPSJmaWxsOnJnYigzOCw5NSwyMyk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjEwLjUsMTYwLjVDMjExLjYwOSwxNjAuNTU3IDIxMi42MDksMTYwLjg5IDIxMy41LDE2MS41QzIxNC4zNDEsMTYzLjM3OSAyMTQuNjc1LDE2NS4zNzkgMjE0LjUsMTY3LjVDMjEyLjQzMSwxNzIuMTY5IDIwOS4wOTgsMTczLjUwMiAyMDQuNSwxNzEuNUMyMDQuNTc2LDE2OS4wNzcgMjAzLjU3NiwxNjcuMjQ0IDIwMS41LDE2NkMyMDMuMjUsMTYyLjEyNSAyMDYuMjUsMTYwLjI5MiAyMTAuNSwxNjAuNVoiIHN0eWxlPSJmaWxsOnJnYigzMiw5MiwxOCk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjczLjUsMTY4LjVDMjc4Ljg2NiwxOTUuMjc1IDI4NC44NjYsMjIxLjk0MiAyOTEuNSwyNDguNUwyOTEuNSwyNTMuNUMyNzAuMjQyLDI1NC40ODggMjQ4LjkwOSwyNTQuODIyIDIyNy41LDI1NC41QzIyNi44MzMsMjU0LjE2NyAyMjYuMTY3LDI1My44MzMgMjI1LjUsMjUzLjVDMjMxLjU5MywyMjMuODcyIDIzNy43NTksMTk0LjIwNSAyNDQsMTY0LjVDMjQ2LjczNywxNjMuMzkgMjQ5LjU3MSwxNjMuMjIzIDI1Mi41LDE2NEMyNTguNjkxLDE2NS44MzYgMjY1LjAyNSwxNjYuODM2IDI3MS41LDE2N0MyNzIuMDQ0LDE2Ny43MTcgMjcyLjcxMSwxNjguMjE3IDI3My41LDE2OC41WiIgc3R5bGU9ImZpbGw6cmdiKDI1MSwyNTMsMjUwKTsiLz4KICAgIDwvZz4KICAgIDxnPgogICAgICAgIDxwYXRoIGQ9Ik0yOTkuNSwxNjMuNUwzMDYuNSwxNjMuNUMzMDguODc2LDE2NC41MTIgMzA5Ljg3NiwxNjYuMzQ1IDMwOS41LDE2OUMzMDguNzc0LDE3NC4yMDcgMzA1Ljc3NCwxNzYuMjA3IDMwMC41LDE3NUMyOTguOTU5LDE3My42MjkgMjk3LjYyNSwxNzIuMTI5IDI5Ni41LDE3MC41QzI5Ni4zOTIsMTY4LjQ4NiAyOTcuMDU4LDE2Ni44MiAyOTguNSwxNjUuNUMyOTguODMzLDE2NC44MzMgMjk5LjE2NywxNjQuMTY3IDI5OS41LDE2My41WiIgc3R5bGU9ImZpbGw6cmdiKDM0LDk1LDE5KTsiLz4KICAgIDwvZz4KICAgIDxnPgogICAgICAgIDxwYXRoIGQ9Ik0yODAuNSwxNjguNUMyODUuNzI1LDE5NC4xODIgMjkxLjA1OCwyMTkuODQ5IDI5Ni41LDI0NS41QzI5NC45NTUsMjQ2LjY0IDI5My4yODgsMjQ3LjY0IDI5MS41LDI0OC41QzI4NC44NjYsMjIxLjk0MiAyNzguODY2LDE5NS4yNzUgMjczLjUsMTY4LjVDMjc1LjY4OCwxNjcuMzc3IDI3OC4wMjEsMTY3LjM3NyAyODAuNSwxNjguNVoiIHN0eWxlPSJmaWxsOnJnYig1OCwxMzMsMzkpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI5Ni41LDI0NS41QzMwMy4zOTEsMjQ3LjE3NyAzMDUuMjI1LDI1MS4xNzcgMzAyLDI1Ny41QzMwMC44ODcsMjU4LjMwNSAyOTkuNzIxLDI1OC45NzIgMjk4LjUsMjU5LjVDMjk2Ljk1OCwyNTguNjk5IDI5NS4yOTIsMjU4LjM2NiAyOTMuNSwyNTguNUMyOTIuMDY5LDI1Ny4yMiAyOTEuNDAyLDI1NS41NTMgMjkxLjUsMjUzLjVMMjkxLjUsMjQ4LjVDMjkzLjI4OCwyNDcuNjQgMjk0Ljk1NSwyNDYuNjQgMjk2LjUsMjQ1LjVaIiBzdHlsZT0iZmlsbDpyZ2IoMzEsOTEsMTYpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTIxOS41LDI1Mi41QzIyMS42MjEsMjUyLjMyNSAyMjMuNjIxLDI1Mi42NTkgMjI1LjUsMjUzLjVDMjI2LjE2NywyNTMuODMzIDIyNi44MzMsMjU0LjE2NyAyMjcuNSwyNTQuNUMyMjguMzAxLDI1Ni4wNDIgMjI4LjYzNCwyNTcuNzA4IDIyOC41LDI1OS41QzIyOC4yMzgsMjYyLjY5OSAyMjYuNTcyLDI2NC42OTkgMjIzLjUsMjY1LjVDMjIxLjExNCwyNjUuNzQxIDIxOS4xMTQsMjY1LjA3NSAyMTcuNSwyNjMuNUMyMTUuNzA1LDI1OS4yNjEgMjE2LjM3MSwyNTUuNTk1IDIxOS41LDI1Mi41WiIgc3R5bGU9ImZpbGw6cmdiKDI5LDg1LDE1KTsiLz4KICAgIDwvZz4KICAgIDxnPgogICAgICAgIDxwYXRoIGQ9Ik0yOTEuNSwyNTMuNUMyOTEuNDAyLDI1NS41NTMgMjkyLjA2OSwyNTcuMjIgMjkzLjUsMjU4LjVDMjk0LjI2MywyNTkuMjY4IDI5NS4yNjMsMjU5Ljc2OCAyOTYuNSwyNjBDMjk0Ljg2NiwyNjAuNDk0IDI5My4xOTksMjYwLjY2IDI5MS41LDI2MC41QzI3MC42NzMsMjU5LjUwMyAyNDkuNjczLDI1OS4xNjkgMjI4LjUsMjU5LjVDMjI4LjYzNCwyNTcuNzA4IDIyOC4zMDEsMjU2LjA0MiAyMjcuNSwyNTQuNUMyNDguOTA5LDI1NC44MjIgMjcwLjI0MiwyNTQuNDg4IDI5MS41LDI1My41WiIgc3R5bGU9ImZpbGw6cmdiKDExMCwyMTYsNzYpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTIxNy41LDI2My41QzIxOS4xMTQsMjY1LjA3NSAyMjEuMTE0LDI2NS43NDEgMjIzLjUsMjY1LjVDMjE5LjY1NiwyOTIuNDAxIDIxNi4zMjIsMzE5LjQwMSAyMTMuNSwzNDYuNUwyMDcuNSwzNDYuNUMyMTEuMzAzLDMxOC45MzMgMjE0LjYzNiwyOTEuMjY2IDIxNy41LDI2My41WiIgc3R5bGU9ImZpbGw6cmdiKDgyLDE3Nyw1OCk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjkzLjUsMjU4LjVDMjk1LjI5MiwyNTguMzY2IDI5Ni45NTgsMjU4LjY5OSAyOTguNSwyNTkuNUMyOTYuNTE3LDI2OC43NjcgMjk0LjY4NCwyNzguMSAyOTMsMjg3LjVDMjkwLjI1NSwzMDguODcyIDI4Ny40MjIsMzMwLjIwNiAyODQuNSwzNTEuNUMyODIuMjgzLDM1MC42MzEgMjc5Ljk1LDM1MC4yOTggMjc3LjUsMzUwLjVDMjgyLjA5MSwzMjAuNTMgMjg2Ljc1OCwyOTAuNTMgMjkxLjUsMjYwLjVDMjkzLjE5OSwyNjAuNjYgMjk0Ljg2NiwyNjAuNDk0IDI5Ni41LDI2MEMyOTUuMjYzLDI1OS43NjggMjk0LjI2MywyNTkuMjY4IDI5My41LDI1OC41WiIgc3R5bGU9ImZpbGw6cmdiKDY4LDE1Miw0Nyk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjA3LjUsMzQ2LjVMMjEzLjUsMzQ2LjVDMjE3LjUsMzUwLjUgMjE3LjUsMzU0LjUgMjEzLjUsMzU4LjVMMjA3LjUsMzU4LjVDMjA0LjU2NCwzNTcuNDg1IDIwMy4yMzEsMzU1LjMxOCAyMDMuNSwzNTJDMjAzLjExNCwzNDguODg5IDIwNC40NDcsMzQ3LjA1NiAyMDcuNSwzNDYuNVoiIHN0eWxlPSJmaWxsOnJnYigzMSw4NywxOCk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjc3LjUsMzUwLjVDMjc5Ljk1LDM1MC4yOTggMjgyLjI4MywzNTAuNjMxIDI4NC41LDM1MS41QzI4Ny42ODEsMzU2LjI1MSAyODYuNjgxLDM1OS45MTggMjgxLjUsMzYyLjVDMjc5LjM3OSwzNjIuNjc1IDI3Ny4zNzksMzYyLjM0MSAyNzUuNSwzNjEuNUMyNzEuMDM3LDM1Ni44MTcgMjcxLjcwNCwzNTMuMTUgMjc3LjUsMzUwLjVaIiBzdHlsZT0iZmlsbDpyZ2IoMzYsOTQsMjEpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI3NS41LDM2MS41QzI3Ny4zNzksMzYyLjM0MSAyNzkuMzc5LDM2Mi42NzUgMjgxLjUsMzYyLjVDMjc4LjE2NywzODkuMTYxIDI3NC42NjcsNDE1LjgyOCAyNzEsNDQyLjVDMjcwLjUwMSw0NDcuNDg5IDI3MC4zMzQsNDUyLjQ4OSAyNzAuNSw0NTcuNUMyNjguOTU4LDQ1Ni42OTkgMjY3LjI5Miw0NTYuMzY2IDI2NS41LDQ1Ni41QzI2NC4zOTEsNDU1LjEyMSAyNjMuNzI0LDQ1My40NTUgMjYzLjUsNDUxLjVDMjY3Ljk0LDQyMS41MzMgMjcxLjk0LDM5MS41MzMgMjc1LjUsMzYxLjVaIiBzdHlsZT0iZmlsbDpyZ2IoMTIyLDIyMiw4OCk7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjA3LjUsMzU4LjVMMjEzLjUsMzU4LjVDMjIxLjAxNiwzOTEuMjc1IDIyNy42ODMsNDI0LjI3NSAyMzMuNSw0NTcuNUwyMjcuNSw0NTcuNUMyMjIuMzQsNDMzLjUzNyAyMTcuNTA3LDQwOS41MzcgMjEzLDM4NS41QzIxMi4zMzMsMzg0LjE2NyAyMTEuNjY3LDM4Mi44MzMgMjExLDM4MS41QzIwOS44OTIsMzczLjc5NyAyMDguNzI1LDM2Ni4xMzEgMjA3LjUsMzU4LjVaIiBzdHlsZT0iZmlsbDpyZ2IoMTA2LDIwOCw3Nik7Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8cGF0aCBkPSJNMjI3LjUsNDU3LjVMMjMzLjUsNDU3LjVDMjM3LjE2OSw0NTkuNDM4IDIzOC4zMzYsNDYyLjQzOCAyMzcsNDY2LjVDMjMyLjk2MSw0NzEuNjgyIDIyOC45NjEsNDcxLjY4MiAyMjUsNDY2LjVDMjI0LjMzMyw0NjQuNSAyMjQuMzMzLDQ2Mi41IDIyNSw0NjAuNUMyMjYuNDE3LDQ1OS45MjIgMjI3LjI1LDQ1OC45MjIgMjI3LjUsNDU3LjVaIiBzdHlsZT0iZmlsbDpyZ2IoMzMsOTAsMTkpOyIvPgogICAgPC9nPgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTI2NS41LDQ1Ni41QzI2Ny4yOTIsNDU2LjM2NiAyNjguOTU4LDQ1Ni42OTkgMjcwLjUsNDU3LjVDMjczLjgwNSw0NjMuMjMyIDI3Mi4zMDUsNDY3LjIzMiAyNjYsNDY5LjVDMjU5LjEyNyw0NjYuNzc1IDI1Ny45Niw0NjIuNjA4IDI2Mi41LDQ1N0MyNjMuNDQ4LDQ1Ni41MTcgMjY0LjQ0OCw0NTYuMzUxIDI2NS41LDQ1Ni41WiIgc3R5bGU9ImZpbGw6cmdiKDM3LDk2LDIyKTsiLz4KICAgIDwvZz4KICAgIDxkZWZzPgogICAgICAgIDxpbWFnZSBpZD0iX0ltYWdlMSIgd2lkdGg9IjE0MHB4IiBoZWlnaHQ9IjQ4NXB4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUl3QUFBSGxDQVlBQUFBblRCUVlBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBZ0FFbEVRVlI0bk8yZGVYaFYxYm4vUHlmeklBa0pRUkFDQ2JQS0lCQWdBYkVLaXFnZ1drRzB6cld0MXRyYjlyYTF2YlhhU2ZUZVZ2dlREaXBWd2FuRnFZT0NES0pnbUZFRWtUR2dESUVBQ1FRSWdZU0VKT2Y4L3RnREs0Y01KK2ZzdGZiZU9mdnpQSGxZSyt5ejF5TDU4cjd2bXQ3bHd5TVNmTUJOd0VOQUJ1QUg2b0VHNGM4RzRBeXdDOWlxZjIwQkRnSUI5VjJPREovZEhYQXhnNEUvQUtQRC9Qd0pOUEZzQVA0QmJMZW9YMUx4Qk5OMk9nRy9CTzRCWWdDeXNySzRidEoxeE1iRzBsRGZRRU5EQS9YMTllYWZWVlZWYk4rK25aS1NrcGJldXhhWUJjd0ZhaVgvRzhMR0Uwem94QUgzb29rbEhTQXVMbzRIdi84Z2p6ejZDQjA3ZG16MUJjZU9IV1BMNWkxczNyeVpMNzc0Z2syYk5yRmgvUVlDZ1VhZXFSejRPL0FpY01EeWY0V0hFcm9BeTRBSzQydkNoQWtWbTdkc3JxaHJxSXZvYStlWE95dCsrdEJQSzdLeXNpckU5d01sYVBHUmg4dm9CbnlHL292czFidFh4Yi9mL1hmRm1mb3pFWXRGL0RwVmZhcmkxZGRmclJoejZaaGc0ZncvSU1tK2YzNWpQSmZVTWoyQmVVQU93TDNmdXBjLy9mbFBKQ1hKL2YzTm56K2ZlKys1bDJQSGpobmYyb0lXTTMwbHRlRVE4QVRUUEgzUXhOSU40TUh2UDhqVHp6eU56NmZtUjdaLy8zNXV2KzEyMXF4ZVkzeXJDcmdGV0tta0E4MFFhMmZqRHVaQzRIM2dBb0NmUHZSVG5uenFTV1ZpQVVoUFQrZU9PKytndHJhVzFhdFhBeVFBRTRGL0FpZVZkU1FJVHpEbjBnOVlDSFFHZVBSWGovSzd4MzZuVkN3R3NiR3hYSFhWVmVUazVEQjM3bHlBRkdBVThCYmFoS0Q2UHRuUnFJT0pRWnRFNncvd3hQOCt3Y08vZk5nV3NZZ01IVHFVc3JJeTFxOWZEOUFkU0FNK3NxTXZYZ3pUbUR1QnZ3QjgvNysrejlQUFBHMXpkODVTVzF2TDVWKzduUFdmclRlKzlXMDA5NlFVVHpCbnlRTFdBUm5kdTNkbjg5Yk5kT2pRd2U0K05hSzR1SmhSSTBZWm82ZFR3TVZBcGNvK3hLaHN6T0g4RG0wQmthZi85TFRqeEFLUWs1UEQzMTc4bTFFOUQ3aGRkUjg4QzZNeEJsZ0FjTjExMS9IdTNIZHRqMXVhdysvM00yamdJTDdjK1NYQVhpQVBoUUd3Ri9ScXc5VTNnYXprNUdUbXpwdExSa2FHM1gxcUZwL1BoOC9uWTlIQ1JRQWRnWTBvbk5EelhCSk1SNXQzNFpGSEh5RzNWNjZ0blFtRk8rKzZrN1MwTktQNlhaVnRleFlHZmd2MDZ0S2xDMis4OVFheHNjNy9rU1FtSm5MNDhHRSsrZVFUZ0Z6Z1BiUlZidWxFdTRYcEJId040T3MzZloyRWhBU2J1eE02RHo3NG9GaTlYbFc3MFM2WVNlaFc5dWFiYjdhNUsyMmpkNS9lOU9yZHk2Z09WZFZ1dEF2bVJvQXVYYnB3NmRoTDdlNUxteG1STjhJb0RsUFZaalFMSmhPNEhEUjM1SWJZSlpqaGVjT040Z1ZvbTd5a0U4MkNNZDNSdEduVGJPNUtlT1NOeUJPclN0eFNOQXZHZEVkakx4dHJkMS9DWXRpd1JwN0lFNHhFWW9CTEFhNmZjcjByM1JGQXg0NGQ2ZE8zajFGVkVzZEVxMkM2b2UrVEhUcFUyUUJEQ2dQNkR6Q0szVlcwRjYyQzZXc1Urdlh2WjJjL0lpWWxKY1VvS3RrbzdnbW1YN3NSVExLSzlxSmFNTW5KeVhUdnJzU1NTeU1wMlRRc25vV1JTQitBdnYzNkVoUGo3aDlCY3JKcFdEd0xJNUcrQVAzNzliZTdIeEVUNUpLa2IrS0pSc0Vrb0I5TWMzdkFDNDBzVEF3UUw3dTlhQlJNTHZxL3U1MEpCaFRFTWRFb0dIT21xejI0cE9ycWFyRXFQVTFJTkFyR05DdnR3Y0tVbDV2N3BxcndCQ09GdmdDWm1abDA2dFRKN3I1RXpMR2o1b0g5b3lyYWkwYkJuQStRM1NQYjduNVlnbUJoUE1GSUloWGd2UFBPczdzZmxsQisxQlRNc1phZXM0cG9GRXdLUUdwS3F0MzlzSVREWlllTm9tZGhKSkVLa0pycWZzRlVWRlN3Zi85K28vcWxpamFqVVRESjBENEVzM25UNWtaVkZXMUdvMkJTQUZKU1UxcDd6dkZzMnJSSnJHNVIwV1kwQ3FiZHVLU05HemNheFJNb1N0RWFiWUx4MFk1Y2ttQmhOcU1vRFgyMENTWUpmVVZYV09WMUpmdjM3MmZqNTZhRitVSlZ1OUVtR05Pc3VOM0N2UFRpUy9qOWZxUDZqcXAybzAwd3BsbHhzMkRxNnVxWVBXdTJVVjJQbHZKRENWRXJHRGVQa3Q1Nzd6MUtTMHVONml5VmJVZWJZTXpWM0RObnp0alpqNGlZK2R4TW8xZ0IvRnRsMjlFbW1CTkdvZUo0aFozOUNKdWk3VVVzVzdiTXFQNERxRkhaZnJRSnhzdzRXVkhoVHNITW5EbFRyTTV1N2psWlJKdGc2dEhTbGJwU01GVlZWYnorMnV0RzlXTzBhd0dWRW0yQ0FkMHRIVDkrM081K3RKbTMzbnlMeWtyVFNDb05kZzJpVmpBbktrNjA5cHlqQ0FRQ1BQLzg4MGIxRUxESWpuNUVvMkFxQUk1WHVNdkNyUHQwblRpeit3cWFlMVZPTkFybUJMZ3ZocG41dkJuczFnT3YydFdQcUJXTW0xelMwYU5IZWZ2dHQ0M3FmS0MwaGNlbEVvMkMwVnlTaTRMZTExNTlqZHBhYzg3eEpUdjdFcldDcWF5c3BLSEJsanVxMm9UZjd4Zm5YblppOHhWK1VTc1kwRXk5MDFteVpBbTdkKzAycXJOUnRPK2xPYUpSTUh1TXdvNmlIWGIySXlTZWY5WWNTdGNBYjlqWUZTQTZCYlBOS0d6ZHV0WE9mclRLMWkxYm1UZHZubEY5RzJFdHpDNmlVVEFsYU9lUUhTK1lHWS9OTUlwKzRFODJkc1VrR2dVVEFMYURzd1d6ZGN0Vy92bFA4MHJIdDdGaDNhZ3BvbEV3QUVXZy9WSUNBVnRqeUdZSnNpNVAydGlWUmtTcllMWUJIRHQyakxLeU1ydjdjZzVPdFM0UXZZSXBNZ3BPZEV0QjF1VXBHN3R5RHRFcUdIT2t0RzNydHBhZVUwNFQxa1haZlk2aEVLMkNLVU9md051eVJja0owNUJ4c25XQjZCVk1BQ1B3ZFpCTDJycGxLLy82MTcrTXF1T3NDMFN2WUVCM1M5dTJiblBNU09ueEdZOGJmWEdrZFlIb0Zrd3R3S2xUcHh4eDVDUW9kbmtIQjFvWGlGN0IrSUJyQUVhUEdVMWlZcUxOM1hHSGRZSG9GY3hGUUMrQUcyKzgwZWF1TkdsZGxHU1RDb2RvRmN4MG8rQUV3YmpGdW9DQ3l3d2N5QkJnS1JBM1l1UUkxcXhkWTJ0bnRtN1p5ckNod3d6QnZBWGNiMnVIV2lIYUxFd1M4QUlRRnhjWHg3UFBQbXQzZi9pLy8vMC9jWlJtZjRkYUlab0Uwd0Z0UCt5RkFBLy84bUh4M21mYjJMSzEwY1RoTzhCOWdQMVJlRE80OHpyVnRuTXg4QjVRQURCaTVBaG16WjdsaU50a2h3MGR4cHExYXlnL1VnNXdIakFCK0FiYU9mQnRhSEdOWTdEL0p5YVhDNEVmQTgrZ3A0eS8rdXFyZWZ1ZmI5T2hRd2RiTzJhUW5aM05mZmZmUjUrK2ZkaTBhWk9SVlNJTnVBNjRDWWdEaXRFM2ZkbE5ld3Q2NDlCdUs4bEgrMSthYi95RnorZmoxNy81TmI5NCtCZU92YmF2cnE2T1YxNStoY2RuUE02QkE0MlNZallBUzlDQzR2a29UdkVoNG1iQkdPSVlobllyL0ZDMEVkQTVsMHlOR3plT2h4OTVtQ3V1dUVKcEI4UGw5T25UdlBDM0YzajIyV2ZaczN0UDhGK2ZSSE92SzlBT3RCM1d2NDZqd0gyNVJUQWhpOE9nYTlldTNIM1AzWHp6bTk4VWI0OTNGWUZBZ0xWcjF2TDY2Ni96enR2dnRIYTh0eDQ0Z2lhZUE4QnFZQm13RlF1RjVFVEJ4QUg5T1N1TVZzV1JsSlRFSlVNdllmanc0ZVRsNVRGOCtIQXV1dmdpNHVMaTFQUllBYlcxdFN4WXNJQy92L1ozRmk1Y1NGMWRYYWdmUFlvbW5HVkFJVm84RkRaMkM4WVRSeGhVVlZWeG9PUUFwYVdsbEphVlVsWmFwcFZMU3psY2RwanQyN2RUWE55c0xsWUJqd0ZydzJsYnRXQmlnZXVCTVhqaWtNcWUzWHRZc21RSlN6NWF3dEtsU3psMjdKenJsQllETTRCTjUzNjZlVlFLcGl2d0luQlpVMy9waVVNZWZyK2ZUVjlzWXM2Y09Uei8zUFBVMURRYVpMMEwvQWJZRzhxN1ZBbm1hdUI1b0JONDRyQ1RBd2NPOE1UalR6QjcxbXpxNjgyY1JNZUFyeE5DQ25vVmdya2VlTTFvNis1Nzd1YVpQejNUYnE3UWN5dTdkKzNtdDcvNUxYUG16REcrVlFsTUF6NXQ2WE95QlRNRytBK1FtSnFheXN3WFpuTHJyYmRLYnRLakxUejM3SFA4OEFjL05LclZ3QzFvY3p4TkluTnBJQmR0VmpJMUxpNk8vN3ozSDI2NDRRYUp6WG1FdzhoUkk4bkp5ZUg5OTk4bkVBakVveTFIZkFMc2ErcDVtWFBrTTlEV1JIaHgxb3RNbURCQllsTWVrWEQzUFhmeitqOWVOMkxJSkxTRC8vRk5QU3ZMd293QmZndHc1NTEzOHVpdkhwWFVqSWRWREJ3NGtBNGRPckI0OFdLQURLQWM3YWFVUnNpS1lSWURvNUtUazlsV3RJM3M3UFp4cVhoNzU4eVpNd3dhT01oWXZ6cUtObGQyVW54R2hrdnFDWXdDZVBEN0QzcGljUkVKQ1FrOC9zVGpSclVUOEtQZ1oyUUk1bHFqNEkySTNNZTBhZE1ZT1dxa1VYMFE2Q2ordlRUQjlPalJneUdYREpId2VnK1orSHcrZnZuSUw0MXFFc0tlSXBBam1NRUE0Njhjajg5bjk5cW1SemlNSFR0Vy9OMk5FdjlPaG1CaXdOMTNLa1k3NmVucERCdzAwS2hLRjR4SE82Q2dvTUFvamtEYmhnSklGSXhUTWlKNGhNZm9NYU9OWWpMYXFRdEFqbUE4cGJRRFJ1U05FS3RTQmVQUkRraE9UaGFyWmdUc3VTU1BVREIvbVo1TDhtaVM1djdEZXk3Sm8wbVVDOFp6U2U0bTZQZm51U1NQbGxFcEdJOTJ3TDc5alRiY2xSc0ZHWUpKQUJ5UlNzTWpmTFpzYnBTM3hreVhiclZnRXRDM1pYYnUzTm5pVjN1b1JNaVFmaHd0Y3pwZ3ZXQXlqY0w1NTU5djhhczlWQ0prU04rT3hCakdOQ3RabmJNc2ZyV0hLdngrdjNocFI2UGMrbFlMeGxUSitaMDlDK05XaXZjV1UxVmxKcnphTHY2ZE5Bdmp1U1QzRXBTb3NkSDlRTklzak9lUzNNdUJra2JwMGhybERaRWltTGk0T0RwMjdOamFzeDRPSmZXOFJyc2xHNlZqa2VLU09uZnU3TmpFZ3g2dGs1YVdKbFlicFJ1VkloalBIYm1iSU1FMHFsZ3RtRTdnalpEY1RucGF1bGlWYjJHOEVaSzdVV2xoUEpmVUR1aVExc2lvU0xNd3Fmb1hYYnQydGZDMUhxcFJGZlJlWUJROHdiaWJwS1FrTWQrZ05KZDB1Vkc0NktLTExIeXRoMnA4UGgvcDZXYmdLODNDWEEvUXJWczM4a2JrV2ZoYUR6c1E0aGdwZ2lrQXJnQzQ0Y1lidkVtN2RvQVF4MWp1a2hLQkowSHpmVC81NlU4c2VLV0gzY2dTVEN4YWR1L0JBRC83K2MvSXljbUo4SlVlVGtDWXZMUFVKZjBXbUFJdzV0SXhQUFN6aHlKOG5ZZFRFQ3lNWllLSkE3NE5NSGpJWU42Yit4NUpTYzNlTStIaE1tUUV2YjNSbDc1LzhJTWZlTnNaMmhreVlwaGVScUZiOTI0UnZNYkRpUWlDU1VDNEZqa1N3V3hCdnhydW5iZmZpZUExSGs1RW1MZ0R3UzFGSXBnNnRFc3FlZXZOdDd5ejFPMk01aFlnd3hWTVA3UWJMN3FCRnZSNmdtbGZOTGNBR2E1Z2ZnZDBBYmp0dHR0WTlNRWliM2EzbmRIY25waHdya0RyanA2OCthNjc3dUtsMlM5NStYamJJYzN0dWd2SExKZ1I4MFVYWCtTSnBaM1NuSVVKUnpCN2dGMEFUenorQk11WExZK3NaeDZPeE1xZ053QThBUVJPbmp6SnBPc21zV0g5aGdpNzUrRTByTFF3QVA4QzdnY2FhbXBxbURWclZnUmQ4M0FpUWJ2dUxKbUhlUnNvQWlqWlh4TEJhenljaU0vbm8xT25Ua2JWM0g0YjZWajRJTUNCZ3dkYWU4N0RoUXdjYUY1UU1kZ29SQ3FZUXdBSER4eU04RFVlVG1Ub3NLRkdjUUQ2Nk5nU0MzUGt5QkZxYTJzamZKV0gweEFFRXdkY0JCWlpHSUJEaHc2MTlKeUhDeGsyZEpoWUhRd1dDc1p6UysyUGZ2MzdpWmRVREFHTFhCSjRnVzk3SkRZMmx1d2U1cTNBbmNGS2wzVFFjMG50a1lhR0JxTllCNUVMNWhoUUMzRGdnR2RoMmlNTjlhWmdHaUJ5d1FUUU4xRjVNVXo3UkxBd2xnZ0dkTGZreFREdGsvcjZlck1JVmdyR2MwbnRFbW1DT1hqZ29MZE5zNTFSVVZIQjhlUEhqZW9wc0VZd0J3RnFhbXJFbDN1MEF4WXRXaVRHTUlWZ29ZVUJML0J0Yjh4N2I1NVJQQW1zQWdzdERIaUJiM3ZpekprekxGcTB5S2d1QnM2QVoyRThtbUhCZ2dWVVZsWWExWVZHd1FyQmxCb0ZiNlRVUGdnRUFzeDRiSVpSUFFHWXBzWUt3ZFNnaTJiZXZIbmVTS2tkTUhmdVhMN1krSVZSZlJaOWhBUmFRaUFyT0E4WWUralFJZkpHNU5HL2YzK0xYdXVoR3IvZnp4MjMzMEZaV1JsQUJYQXZldndDMXVXNGV4Nm9CUGpkYjMvbldSa1hNM3ZXYkRaOXNjbW8vaFZ0aEdSaWxZV3BSY3NWTS9iUW9VTmtabVl5S24rVVJhLzJVTVcycmR1WU5uV2FNYnRiaW5ZeTVJejRqSlhIRmpzQzY5RDNUYnp5Mml2Y2Z2dnRUVDRZQ0FUWTlkVXVWcXhZd1lybEsxajd5VnJpNCtQcDM2OC8vZnIzbzMvLy92VHIxNC9jWHJta3BxYVNsSlJFWW1LaWQ4cFNJdFhWMVl3dUdHM2M5UmhBUzBXM0l2ZzVxMzhEUTRIM2dmTmlZMlA1eGNPL0lEazVtWnFhR2s2ZlBrMU5UUTJsaDBwWnVYSWxwYVdscmIycmNVZDlQcEtTa2toSlNlR09PKy9ncVQ4K1pYSFhvNWRBSU1EOTk5M1B5N05mTnI3MUI3VERpdWNnNDcvc0dPRGZCTjNrMVFLVndDZG95WW42QXJtRTRDb3JLaXRJVFUxdDdUR1BWZ2dFQXZ6a3h6L2hMMy8raS9HdHRjQms5TVhHWUdUWitLdUI1eER1Z0VTTGMyclJobWlmQWF2UnBwdTNvZSsxMElrSGNvQSthSmtpa29Cay9jL0wwSkpJYzdMcXBKZUVNVUw4Zmo4Lyt1R1BlUDY1NTQxdjdRT3VRWmk5RDBabVVKQUFwS0ROMDV4QlQyOFdJYjhFSHZMNWZOVFcxWG94alVBZ0VHREJnZ1Z0T29XNmV0VnE1c3laWTFUM29GbVdGbWRmdzhrUEV5cG5DSXF3TFNBWklEazUyUk5MRUlzV0xlTEdLVGVHKy9HdjBPNkthSFZqdHR2U1JpVUI0dEVIRDUwSWZpWWIwQ3hMU0x2NFpWb1lHWmdXeHFNeGwxMTJHZG5aMlpTVWxBQnNCcWFHOExFQVVLNy9HUkt1dERCSnlWNndHMHhzYkN5MzMySE9ldzFHeStseXVKV3ZJN1JCTE9BK3dYZ1dwZ1h1dXVzdXNmb05HVzI0VFRCZUROTUMvUWYwSjc4ZzM2aCtBK3VXZmt6Y0poak53aVI1Z21rT3djcDBRNXUzc2hTM0NTWUpJQ1VseGU1K09KYWJwOTlNWXFLWjZOUnl0K1Eyd1hneFRDdGtaR1F3WmNvVW8zb0RRZGZYUklvbm1IYkluWGZmYVJTVDBFUmpHVzRUakRlc0RvRUpFeWFJZDRmZlp1VzczU1NZYlBTOU5wbVptVFozeGRuRXhjVngyKzJtVHNhZzdRQ3dCRGNKNXB2by9iMzU1cHR0N29yekNacVR1ZFdxOTdwRk1JbkFYUUQ1QmZrTUd6NnNsY2M5Qmc0YXlQQzg0VWIxRzFqMHUzYUxZS2FndTZNSHZ2ZUF6VjF4RDRLVnlRRkdXL0ZPdCt3UitBREl6OHJLWXUrK3ZlSThnMGNMbEplWDB6TzdKM1YxZFFEL0FCNk05SjF1c0RDRGdYeUFlNzkxcnllV05wQ1ZsY1drU1pPTTZvMW9HOW9pd2cyQytUWkFURXdNOTkxL245MTljUjNDbkV3cTJ2YkxpSEM2WU5LQjZRQ1RKazBpSnlmSDV1NjRqNGtUSjRvM3hONFU2ZnVjTHBqYjBHZDNIM2pRQzNiRElURXhrUnR1TkNkN0p4RGhVb0dUQlJPRDdvNzY5TzNEbFZkZWFYTjMzTXYwVzZZYnhVVGd1a2plNVdUQlhJWjIxSVFISG5qQXU3VTJBc2FQSHkvT2puODlrbmM1K2Jkd0swQkNRZ0ozM1gxWGE4OTZ0RUI4ZkR3M2Z0MDhVWEFsMnJIbXNIQ3FZSkxRamowd2FkSWtNakl5Yk82Tyt4SGNVand3cVlWSFc4U3BncmtXTGVjTTM3aGR5dGJVcU9QeXl5K25jK2ZPUmpYczBaSlRCVE1kSUQwOW5XdXZ2ZGJ1dnJRTDR1TGl1R21xcVpNcmdFN05QOTA4VGhSTUpuQVZ3RTFUYi9MT1Qxdkk5T21tVzRwRmQvbHR4WW1DdVJITno0cDdPandzNE5LeGwzTEJCZVlGc1dHNUpTY0taanBBZG5ZMlgvdmExK3p1UzdzaU5qYVdxZFBNQTVGamdmUGIrZzZuQ2FZSGVqcVBXMjY5eFp0N2tZRGdsbUlJWTcrdjAzNGo1bGE2MjI3ejNKRU04Z3Z5NmRHamgxRnRzMXR5a21CODZPN280b0VYTTNqSTRGWWU5d2lIbUpnWXB0MDh6YWdXSU54Nkg5TG5MZTlSK0F3QUxnVE51bmo1WCtRaHVDVWYyaUFqWkp3a0dIT3Z4dFNwb1dTcThBaVh2QkY1OU9yZHk2aTJhVzNKY1lMcDE3OGZmZnYxdGJzdjdScWZ6OGROTjVuaHkwamFNRnB5aW1BeWdWR0F1S1hRUXlMQ2NWb2ZNREhVenpsRk1GZWg5MlhTWkU4d0tzZ3Z5QmZYbGtMK29UdEZNTmNBcEtXbGNlbWxsOXJkbDZnZ05qYVc2eWFaZTZtdVFOL1oyQnBPRUV3OCt0clJ4SWtUaVkrUHQ3azcwY09VRzB5M2xBU01DK1V6VGhCTVBsbytOcTZiSE5IdVFZODJjdVdWVjRxTHV5SDk4SjBnbUd0QW0xQzY1cHFJVDBGNHRJSFUxRlN1dXVvcW8zb05JYVE0YzRKZ0pnSVVqQzRnS3l1cnRXYzlMT2I2S2VZdWh5eTBJWGFMMkMyWVBrQS84SWJUZGpGcDhpUnhWcjNWM1dwMkMyYThVYmp1T2k5K3NZTXVYYnFJbVRkYi9TWFlMWmpSb0owQkhqaG9vTTFkaVY2dXY5NTBTLzMwcjJheFV6QSt0T3hJakIwNzFsdHN0QkZoMWhkYWNVdDJDaVlINkFvdzlyS3hObmJEWThDRkEralR0NDlSYmRFdDJTa1lNOEhOMkxHZVlPekU1L09KVmlZZlBYbFRVOWdwbUVzQnpqdnZQQzRaZW9tTjNmQ0FjeFlqcjI3dU9kc3RURUZCQVhGeGJydUZwLzFSTUxxQVRwM01vMHJOem5IWUpaZ3U2QWZ0dmZqRkdjVEZ4WWx6WWVQUU1qMmNnMTJDS1RBS2wxMW0rZjBKSG1FeThWcHpXMHd5ZXBxNFlPd1N6R2pRc2dxTUhOWHFiTFNISXE2ODhrcHhlbU44VTgvWUpaZ3hBQ05HanZEdURYQVFuVHAxSW05RW5sRnRNb09USFlKSkJnWUIzbVlwQjNMMTFlWUFhVEJON1BXMVF6QVhHZTE2R2IyZHg0UUpFOFRxT1p1cTdCQ011V2gweVJCdi9zVnA1QmZrMDZHRG1UZlJFWUlaQkpDVWxDUk9SM3M0aFBqNGVNYU5NM1V5bmlDTjJDYVlnWU1HZWhOMkR1WHFpV1ljY3o1d3NmaDNxZ1hqUXhmTTRNSGUyV21uRWhUSE5Cb3RxUlpNZDdUczNseHlpUmUvT0pYZWZYclR1MDl2bzlwb1BrYTFZQVlaaFNGRGhpaHUycU10Q0ZabU5NS2xGcllKeGt2bjRXeUVPQ1lCZldjQnFCZk1RSUFlUFhwNHVYY2R6aFZYWENFT1NzdzR4aFlMNHdXOHppY3RMWTJDMGVZYXNUbk9WaW1ZQlBRdERaNDdjZ2ZDTXNFQXRBR0xVc0YwTjlycjI5ZkwvK0lHZ29iWDQwR3RZTXpic1hKeXZZdXkzTUN3NGNQbzJORzh4MklVcUJWTVQ2T1FtNU9yc0ZtUGNJbU5qV1hBaFFPTWFoK3dRVEF4TVRGazk4aFcyS3hISlBUcmE1NXI2dzAyQ0NZN085dkxBZU1paEh5RFhZRlU1VEdNRjcrNGk2QUVsYjJWQzZaWGJxL1dudk53RUlKTEF1aWpTakNKNk1kaVBRdmpMdXl5TUdaeSs5emNYRVZOZWxoQldsb2FxYW1wUmpWTGxXRE9EcWs5d2JnTzRhTDBkT1VXcG1kT3o1YWU4M0FnNlIxTndhU3BFb3g1YUxkTGx5NkttdlN3Q21HMlY1bUZ5UUJ0NDdkM2NNMTlwS2VwdHpDWmdKZ2R3TU5GMkdaaE1qSzlUVk51SkNYVjNLR1pvbFF3blRJOUMrTkc2dXZyemFKU3dXUm1aaXBxenNOSzZzN1VHY1V6YWdYVHlST01Hemx6NW94WlZDRVlIM3JRNjFrWWR5SUlSb2xMU2tHLzZkNGJKYm1UdWpxMUxza2NHbmtXeHAzVTF0WWF4VG9WZ2pGVjRnMnIzVW41MFhLamVFeVZTd0swbkx3ZTd1TkF5UUdqZUZDRllNempjMTU2RC9keCt2UnBqaDA3WmxRUEtSVk1mSnkzbDlkdEhEcDRTS3dxc1RDbVNyek4zKzdqd0lFRFl2V1FDaC9odVNTWEVRZ0VXTHAwS2N1WExlZmpqejhXLytxZ1VzRjRGc2JaQkFJQjNuLy9mV1k4Tm9NTjZ6Y0UvM1V0VUtKQ01KNUxjZ0VORFEwODhOMEhlSG4yeStLM0E4QXVZQ3Z3Qm5CS3FXQThsK1JNNnV2cnVmZWVlM25qalRlTWI1MEFuZ2RtQWhYaXMycGptSGhQTUU3azkvLzNlMUVzMjRBYmdjTk5QZXZGTUZGT1NVa0pmL2o5SDR4cUVUQVpPTmJjODBxSDFkVlYxUXFhODJnTGovN3lVYXFyemQvTFQyaEJMS0JHTUZWR1lmeTQ4ZXdvMnFHZ1NZOVFPSG55SkcrOTlaWlJuUWVzYXUwektnVHpiK0JmQUtXbHBjeDRiSWFDSmoxQ1llblNwZUxXaGIrSDhoa1ZncWtGdmcwc0FpZ3NMQ1FRQ0NobzFxTTFGaTFjWkJScmdlV2hmRWJWRnMwQXNCMDBLeVBzci9Dd2lVQWdJQXBtSlhBNmxNK3BUUGN4RExSTHRaT1NraFEyNjlFVTI3WnVvNlNreEtoK0dPcm5WQWttRGhnSk1HYk1HRVZOZXJURW9rV0x4S3JqQkhNeGtBcmV0WDFPWWVHQ2hVWnhEOXIwZjBpb0VveVpVdHF6TVBaVFdWbkpxbFhtQ0RwazZ3SnFabnBCei9IYXVYUG40SXhHanNYdjk3TjQ4V0tLdGhkUlhWMU5WVlVWVlZWVlZGZFhVMTFWYlphcnFzOSt2N2FtbHFuVHB2TEgvL2RIdTd2ZklrdVhMaFZQTXpwU01BVUFvMGVQRnU5RmRpeCt2NS92UGZBOVpyMDBxODJmL2ZPZi9zeERQM3VJcmwyN1N1aVpOUWp1cUFaWTBaYlBxaEJNTnlBYllNeWw3bkJIai96eWthYkVVZ2RVb3cwL3E0US9qZTkxQUM0REtONWI3RmpCQkFJQlBsajBnVkZkaVNhYWtGRWhHRmZGTDRGQWdPZWVmYzZvN2dTbUFZZlFCTk1TQTlHbjFvdjNGWk5ma0MrdGo1R3dkY3RXY2R2bFIyMzl2QXJCNUFNa0ppWXlQRys0Z3VZaTQ5Q2hRMVJWbWN0ZnM0QjlJWDdVbk5UWVZ4enFSOVFUTkp4ZTNOYlBxeGdsRlFEa2pjZ2pNVEZSUVhPUnNYdlg3a2JWTm56MEJIQVNvTGk0Mk1vdVdjckNoV2I4c3B1Mi9mc0ErWUpKUmI5VXl3M3VDR0QzN2tZL3d6MXQvUGgrZ1AzNzlsdldIeXVwckt4azlhclZSclZOb3lNRDJZSVpBY1NDZXdMZXI3NzZ5aWo2Q2QwZEdld0RMWVp4SWt1V0xBbDdPRzBnV3pCbXdEdDY5R2pKVFZtRDRKSktnRE10UE5vVUplRGNHQ1pvT0wweW5IZklGa3crUVA4Qi9jbkt5cExjbERYczJtM09rcmZWSFlIdWtpb3JLNm1vcUdqdFdlVXNXN2JNS0s2aWpjTnBBNW1DOGFHNUpOZFlGNEJkWDBVdUdIQ2VsVGw4K0xCb1BkZUcreDZaZ3NrQTBnQUdEUnJVeXFQTzRQang0eHcvZnR5b2hpTVljMmp0dERqbTAwOC9iVlFOOXoweUJlTzZPeDRqR0ZJYkhEUUtSdzRmaWJnL1ZySjJqV2xVQXNENmNOOGpVekRtcFFKdXVTUHBxMTFmaWRWd0xJd1p1QWlXeWhGOHN2WVRvN2dkT0JYdWU1UUl4aTBXcG1oN2tWZ05SekJWUUFNNFN6RDE5ZldzVzdmT3FJYnRqa0NCWU5MUzBzVFU0NDVHT0lEK0ZjTHhtRFlRUUp2eGRaUmd0bTNkSmk1M3JHdnAyZGFRTHBpYzNCeFhiR2tJQkFKczJHQUtabU1FcjZvQXFEanVuR0gxMnJXTkJrV09GVXdPdU9lTzZvTUhEMUphV21wVVA0L2dWUlhnTEFzanhDOG4wS3huMk1nU2pBL0J3cmdCd2JxQUJSYm1lSVZ6QkxObTdScWp1QTV0eVNOc1pBa21FejE3cGx1dTdBdEtvTE1wZ2xjNXlzSWNQWHFVTDNkK2FWUS9pL1I5c2dUanVoSFMrcy9NcVlrdjBiY3BoSW1qWWhpckp1d01aQW5HVklrYjVtQXNESGpCRUV4RmhTT09CQXZ4QzBRd1lXZmdXUmkwZ0xlc3JNeW9SaXFZRTZDbEFEdDFLdXo1TWNzUVpuaUwwUHNXQ1ZJRms1NmU3b281bUtDQU41SVJFa0JIZ05qWVdOdnZ0MnhvYUJCZFVzVHhDMGdXakJ1c0N6U0tYd0pFRnZDQzdvNTc5T3hoZTA2L291MUZuRHhwaG1NUnh5OGdXVEJ1bVlOWnVjTGNTN1NUQ05aWmRITEFHYkhiSjU4MGlsOGltckF6a0NXWUN3QzZaM2VYOUhycnFLcXFZczBhYzU1aVdVdlBob2cyWWRrcjE0SlhSY2I2OWFibFBBVllrdnBMbG1CU0FEcDA2Q0RwOWRheGF0VXE4Y2F4d2doZmx3cGtBZlRxWmIrRkVkTERGUkhoaEoyQkRNSEU2MStrcHFaS2VMMjFMUGxvaVZIMEUrWStWd0Z6ZE9nRUMxTlVaSzYrZjluU2MyMUJobURNb1VGS1NrcEx6em1DcFV1WEdzWDFRR1dFcjhzMUNuYkhNTWVQSHhlbkNuWmE5VjRaZ2psN0s3YkRCVk5lWHM3R3o4MXBsMElMWG1rT0MrMjJNRHQzTk5LSW93Vnoxc0trT2xzd1FUZDFGRnJ3eWx5QTVPUmt1blRwWXNIcndtZkhqa1l4cnFOZGttc3NqQkMvMUdETnhKWTVRcko3RDVBUXY5UVQzdTdCSnBFcUdLY0h2VXVXbUlKWmhaWjZORkljTXdjampKRDIwSHJtaVpDUmEyR1NuV3RoOW8rOEk4b0FBQmhWU1VSQlZPemV3OTQ5ZTQxcW9RV3Y5T0dnT1ppaUhkYVBrQ0NLUjBrZmZ0am9hSEdoQmEvTVJFLzhhUGNjVEYxZG5YaGt4cktBRjZMWUpmMzdYLzgyaXFWb0YwaEZpbU5HU0x0MzdSWVAzYnRITU1rcDlxN1dOa2Q1ZVRtRmhZVkdkUzdXeklJNlpnK1E0STdBQlM3SjhhT2s5OTU5ajRhR0JxUDZya1d2elRZS2RxL1NCOTBZNHg0TDQxU1g5TTkzL21rVXk0QlBXbmkwTFpqN1lOTFQweTE2WlhnSWdpbkRnazFUSWxLRFhpZmVLVkJlWGk1TzJNMUZQNmxvQWVrQUhUdDJ0SDhPUnRJSUNTUmFtSlNVRkdKaVZONTlFUnB6MzVzcnd4MkJucWtpTFQzTndsZTJuVUFnSUZvWVM5MFJTQmFNRXhIYzBXRWl5SlBTQkthRnNaT3lzakpPbkRDOWtDZVlTRGg2OUtpNE9tMmxPd0pETU9uMkNpWm8wVEdpVTQ1TklTMkdjZUxDbzBSM0JIclFhM2ZBZStEZ0FiRnFlUnFzcUxJd2dqczZBcXhwNGRGd1NBZEk3Mml2WUVvUGxZclZzdWFlQzVlb0VVeDlmVDNMbDV2WEdzN0hXbmNFZXRCcmR3d2pKQlNvSmZJTlllY2dUVENwS2M2YWc5bjExUzVxYXN6RWtSR2ZBQXdpRG4wZHlXN0JsSldhUnVVdzJyRVpTNGthQzdONXkyYXhhc1hha1lnNWxyWTdoaEVzak9YdUNHUUd2VTRUekNaVE1PWU50eFppcXNUMkdLYk1GTXhoR2UrWFoyRWNOa29TQkxPYkVLL2NiUU9taFhHUVMzS05oWEc2UzdMYUhZRm9ZZExzc3pCMWRYV1VsNWNiVlZjSXhvY1I5RHBvNGJHeXNsTGNYU2RWTUhaYW1NT0hHM2toVjdpa1JEVFJPTXJDYk4zU1NDTnlMWXlOTVl6Z2pzQWxGc2FSMnpNM2I1WTZRZ0tIL0x1RmdCZGNZbUVjdVJkR0VFdzFJT01TQUhPQ1I1anJVWTRiTFl3anQyY0tndG1HUllmU2d6QkhYYWVyclI2QWhZNHdCd051c3pCT2NVbUJRSUF0bTdjWVZSbnVDRFRMcFJXcXExdDZUaXFDWUNvSjh6NmsxcEFXd3pqRkplM2Z2MS9jSDdKTlVqTm5MY3hwK3l5TTdEa1lrR2xoSEhLSUxTamczZExjY3hGaXFxVDZ0STBXUnZJc0wwUkIwQ3ZNOElJOEMrTTBsK1JDQytPUUdFYUlYdzRCc3RKem0vR0NuWUlSa2tsTFMwTXVMWVp4eWlocHcrZG1TbFZaN2dnRUMyUG5LRWxBV2tacHF3Vmp2ay9ZQ21rYlI0NGNzVFRQZmd1Y2pXRnN0RERDS1ExcDUxeXNGc3hlb3lCY0dHNGJRZmNFV1hsQ0lCaEh4RENDWUtTZDc3SDZ4ZVovNTZEZDY3YXdaclc1YmRlUDlidnNSTXpjTXA1ZzJzWkI5QUF3S0dXV0xheGV2ZG9vYmlYeWhNMHQ0VWYvZDlzNUQrTkd3ZmpSejhMWWJXSE9uRG5EWit2TXNFV21PektvZ0hNT3dpdEZPS0xybWhnR2RMZTBjNmU5Z3RuNCtVWnFhMDFQWVVtZS9WWllBbHFpSWlHL3YxTGNhR0ZBUDU1WlhGeHNxejhYM0JHb3NUQnpBV3ByYTFtNGNLR0M1czdGRjJNYUZsY0p4aHdlZmZXbGZTTWxJZUF0QlVvVU5GbUlmcFBiZi83MUh3WE5uWXNiaDlVZ2pKUjI3TFRIbndjQ0FkSENyRVhpUkpaQUxiQVFZT0hDaGJZRXYwSU00MDRMWTFmZ1c3eTNXRnhYc1NwaFVDak1CZTJHbE1XTEZ5dHNWc090RnVZVW1odXdUVENyMXpTS1gxUUV2QVpMMEdkOTdYQkxiZzE2UVhkTGRybWsxYXRNd2RRUStRMXJiZUUwc0JSZ3hZb1ZDcHZWY0wxZ2R1N1lhY3ZOcXNLRldSdXdNQXQyaUd3RTJMZHZuN2h4U3dtdUY4ekpreWVEOTVsS3A3S3lVdHpTb0dJNEhZeTVEVFRvZUl0MDNCcjBnbzJCNzZlZmZvcmZiKzd6VmhtL0dKaWJ0SUoyKzBuSHJVRXZDTG5WVk0vNGx1eHZOT1d5VjJuakd2dUFLckJWTUs2ek1DWG9LN2lxRnlFSER4NHNWb2NxYlZ6RGoyNWxQQXNUT2cxb1dSS1V1NlFobHd3Ukx4Z2ZxYlR4czJ3RGJYdW95cURmelJZRzlNQTNLTys5ZE9MajQ4a2JrV2RVUnlsdC9DejdRUXZBVmE2bnFSQ25kTUVVN3kwV1Y0MlZVRkJRWUJRSG9xY1NVMHhYMExKUnFUdzlVVkZoYmdLM1BMZWRnVXpCN0FIdysvMGNQSEJRWWpQblVqRGFGRXdNTUZ4cDR4bzlBWHJtOUd6dE9VczVkdlNZVVhUTnFRR1JvMGJoMkxGakxUMW5PWUtGQVh2Y1VrK0EzSnhjWlEwMk5EU0lGa2JhRDF5bVlFeVZIejEydEtYbkxLZExseTdpSlZlcUExOGZObGlZNDhjYkdSVlhXcGl6Z2ptcVZqQUFvd3RHRzhWUlNCeG1Oa0VHK29HKzNOeGNaWTBLN2doY0twaXpEdldZdFA0M3krZ3hwbUF5Z1Q0S216Yk5pa29MRStUMlhlbVNUSWRxaDRVSmltUHlGVGJkd3lpb2pHR0MzTDRyQlZPSHZtWFJEc0VNSGpKWVRGQTRRV0hUdGxpWW9KK3hLMTBTNkVxM3d5WEZ4Y1V4Y2VKRW8zb1ZrS0NvNlI2Z0pTUG8xS21Ub2liUCtSbTcwc0tBcm5RN0xBekFwT3NuR2NYemdER0ttczBCN2FKUWxWZjVDVDlqUHk2ZHVBTmQ2YXFIMVFiWFhITU5zYkd4WmxWUnMwTUFMaHh3b2FMbU5BVEJIRWRPSGo5QWtXQlVUOXdaWkdSa01IYnNXS042TGZLSDExMkI3Z0FqUjZtZC9oRmNrbFQvcjhRbEJjMFJLR1h5OVpPTllnNHdRSEp6dzR5Q2FzRUlGa2JxRDF1SmhhbW9xS0Mrdmw1eVUwMHplZkprc1hxdDVPYnlRTnNxT1h5NDJpVXN3ZTI3V2pDbWVSVFdPWlRTdDE5ZitnL29iMVJsQzJZNHdJVVhYVWhhbXRycmlBV1hKUFVIclV3d2RycWw2NisvM2lpT0JEcExhc2FIYm1GR2psUy9iNnRkdVNTd0wvQ0ZSbTdKaDd4SnZON29sMVNNR3FWMmdieTJ0cGFxcWlxajJqNEVZOWZRR3JUOU1jTFZlZ1V0UFJzQjVqWS8xUlltNkQraiswZEpZTi9rSFdpenZrSWNreXVwbWVFQWlZbUpEQjR5dUxWbkxTWEkzYmNQQzJQSDhvQkk3MTY5aldLdXBDYnlBSVlOSDBaOGZMeWtKcHFtN0hDalBNNVMvMmZLRmt3bCtxeWpuUllHb0ZmdlhrWXhHNUR4RyswTDV4eHpVVUxReVl6ZE10dVNMUmcvZXQ1N0lWK3VMZlR1YlZxWUdEVFJXRTBDMkpNeVh6ajdkUm90TWFVMFpBc0dZQTNBeHg5L0xCNWhWWTVnWVVDT1c0b0ZMVjVTalpDSThVc2tyaU9CR3NFVWd1YVNObjJoTXZOR1kzcjFraTZZT0xCSk1HY3RqUFJUZzhvRUEvRFJSeDhwYUs1cHNyT3p4VjltcnNXdjkyR1RZS3FxcXRpM2I1OVJsWjVVVUlWZ2l0RVB4Uy81YUltQzVwb21OamFXbk53Y281cHI4ZXZObjZOcXdRVEZodTNDd2dCOERMQnk1VXBiTDlHVU9MUTJSMTJxaDlSQlI1SGJqV0FLUWJ0eFZjZ09wUndoOE0yMStOWG1MaTNWRmtZWVVnZUFYYkxiVXlXWUZlaXBUei82MEw0NFJnaDgwd0VybDVOTmxhZ1dqREJDMm85d0RZOHNWQW5tR0hydXR5Vkw3SXRqT25kdXRGQ2RZZUdyYlJPTTRKS1VUSFNwRWd6b2JtbkQrZzIyclZ4M3pPallxR3JocTIwUmpOL3ZGMTFTK3hSTUlCQ2dzTEJRWWJObnllall5S2hJRVl6S29IZmZ2bjNpSUVKSjVpYVZndmtFL1U0aHUrS1lqQXo1Z29tTmkyM3BPVXNKeWgvWTdnUlRnNzVNWUZjYzA5NWNVdERkVE8zT0pZSHVsbmJ2MnMzZVBYc1ZONjNHd3FnVVRGR1JHZkJXSXZGeWN4RmJCQU93ZE9sU3hVMXJLOG5DTDlSS3dkZ3lEeE8wNktnays2SnF3V3hHMzFSbFJ4emo4L2xFSzJPbFlHeVo2UlVXSFpYdEhWRXRHRCt3RERRTFk4ZDJoL1NPNXQ1ZVY3dWtFeWRPaUduNWxlVzJWUzBZc0htN2d5UUxvMXd3UVFGdit4Y00yTFBkUVppTGNYVU1zMjdkT3JHNlhVbWoyQ01ZVzdjN0pDWW1Ha1VyZjdObkxVeXNHc0dzV0c3ZXgzUVl5ZnQ0UmV3UUREaGt1NE9GbUpHdUNnc1RDQVJZdVhLbFVWMk5vaEVTMkNlWVFyQi91NE9GS0YwYStPckxyeWdyTTQrV3JHN3BXYXV4U3pDTzJPNWdJVXBqbUtEckFhTkNNTWVBTDhEZTdRNFdvblNVdEhLRjZZNU9vRERnQmZzRUEzb2NZK2QyQnd0UktwamxLNVlieFRWb1Z3MHB3MDdCRklLOTJ4MHNSRm5RdTMvL2ZvcjNGaHRWNVFHZ25ZS3hmYnVEaFp5TlllTGxDa1lZSFlIaStBWHNGVXdOK3EydjdTQ09VZWFTaFBtWDAraHhvRXJzRkF6b2NZeGQyeDBzUkoxZ3pvNlExZ0ZucERiV0JIWUxwdEFvMkxIZHdVS1VDT2JJa1NNVWJUZjN3Q2gzUjJDL1lKUnZkeEJtbHEzODM2bEVNS3RXcldwVWxkWlFDOWd0R09YYkhZNVhTTWsycVdTbVY0aGY2b0RQcERYVUFuWUxCaFJ2ZHhCdUxqdGg0V3VWV0JnaGZ2a2NCWWZXbXNJeGdnRTEyeDFPVkpnNmtXSmhaQW1tc3JLU0x6YWFneUpiNGhkd2htQ1ViWGNJQkFLaWhiRlNNT1k4akhEWnVLV3NXYk5HZE5tMnJkZzZRVENnYUx2RHFWT25hR2d3WjlLdEZFdzhhTlpGMXBVM1F2d1NRSisvc2dPbkNLWVE1RzkzQ0xwNTFmSVlSbWI4SXN6d2JzWGF2cmNKcHdoR3lYYUhpdU9OaklybE1ZeXNFVkpaV1JscjE1aEdaV1ZMejhyR0tZSlJzdDBoeU1KWUhzUElzakJ2ekhsRGRLWC9rZEpJaURoRk1LQmd1MFBGQ2JrV1JvWmdBb0VBcjc3NnFsSGRCWHhxZVNOdHdFbUNLUVM1Mngwa3VpUXo2TFdhTHpaK3daYk5XNHpxR3lqY3Y5c1VUaEtNOU8wT3RiVzFZclhPd2xkTHN6Q0NkUWtBYjFyZVFCdHhrbUNrYjNlNG9Oc0ZqYW9XdmxxTFlTemVDM1BtekJuZWZNUFV5SEtneE5JR3dzQkpnZ0hKMngyeXV6ZktHTi9kd2xkTHNUQ0xGaTJpdkx6Y3FMNWg2Y3ZEeEdtQ0tUUUtNclk3WlBkd2wyQmVlK1UxbzFnRnpMWDA1V0hpTk1Gc1JyOWpTVVljazVXVlJWSlNrbEcxOG9JS3k0UGU4dkp5Rml4WVlGVGZCYW90ZTNrRU9FMHdVcmM3K0h3K3VtZWJoc1ZLQzJQNVBNeGJiNzVGWFowWmw4K3g3TVVSNGpUQmdCN0h5TnJ1MENPN2gxRzAzQ1ZaT2RNcmpJNzJZZU5pWXpCT0ZFeWhVWkN4M2FGSEQxTXdWcm9rUzJPWXJWdTI4dm1HejQzcUhDUmZhZE1XbkNnWXFkc2RoTUMzQzlabGNMQlVNRE5uemhTcnRzKzlpRGhSTUtCYkdSbmJIUVFMRXdOMHRlaTFXZ3hqUWFxUEkwZU84TXJMcnhqVmo5RC84emdGcHdybVk1Q3ozVUhTME5xeVVkS3pmMzFXL0UveVRNUXZ0QmluQ2tiYWRnY2g2QVhyQkdPSlN6cDE2aFRQUGZ1Y1VkMkFUU2NEV3NLcGdwRzIzVUVZVm9QRmdvbDBsUFR5N0pmRkxSalBZUE5DWTFNNFZUQWdhYnREeDQ0ZHhadGZyUkpNeFBNd2RYVjFQUE8wNllGMkFmTWo3NWIxT0Zrd2hXRDlkZ2VmenlmR01WWU5yU04yU2UrODg0NTRkK05mVUp6R0kxU2NMQmhwMngwa1RONUZGUFFHQWdHZWV2SXBvM29FaHcybFJad3NHR25iSFFRTFkya01FKzVOSm9zWEwyYnpwczFHZFNiNmZ4UW40bVRCZ0tUdERzSmN6UGxBWWd1UGhrb3NoQi8wUHZVSDA3cFVBYk1zNkk4MG5DNllRcU5nNVhZSFFUQVErVWFxR0hUUmhlT1NQbHYzbVJpanZZSzFXMGN0eCttQzJZeDJ0UXVmZldiZDJYTUxKKzlpZ0tmUjc0Kzg0SUsyYTArSVhlcUJaeVBvaXhLY0xoZy8rcmJFUXdjUFdmWlNDeWZ2Zmd2Y0RURGd3Z0hjLzkzNzIvd0NZWUgxUGVCZ0JIMVJndE1GQTNBSTRGQ3BkWUt4YVBJdUNiZ2ZOTEY4dE9RanNyS3kydlNDK3ZwNlRwd3dEekVxdThJbUV0d2dtREt3MXNKMDZOQ0I5SFR6R3B4d0JUTVVTQUQ0MWE5L1JkZXViVi9IcktpUWR1eEZHbTRRekNIUWpvc0twLzhpeG9MSnUzeWpNR2JNbUxCZUlQR2NsRFRjSUppVEFBME5EVlJYVzdldDFZTEp1d0tBbkp3Y3NyUEQwNXpFbzd2U2NJTmdPZ01rSnlkejNubm5XZmJTQ0NmdmZPZ1dKbHpyQW8zU3A0RW5HTXZvQ3REMWdxNlc1bDRSNW1JeWdlUTJmcnlmL2puR1hCcUJZRHdMSTRXdUFOMjZkYlAwcFJIT3hVUWN2NEFYdzhpZ0k5QWJvTnNGMWdvbWFMYTNyWUlwQUVoTFMyUGdvSUZoOXlGb0tVSGQvY1VSNEdUQlRFRkxiWEVCUUc2dlhFdGZIdUhrWFQ1QWZuNCtzYkhoTFRnQ2RNeG9kTzJrbFhkUVNzT0pxdTRLUEFWTU5yNHhjZUpFZnZ5VEgxdmFTTkRrWFkvbW5tdUNMS0F2UkJhL1FLTWJia0ZmWG5BNlRySXdQdUF1TktzeUdhQlRwMDY4OHRvcnpKcy9yODJ6cUsyUm5Kd3N1cVc3Z0E0aGZuU1VVWWhZTUIwYmFjUVZGc1lwZ3VtRnRwYnlaeUFONEpaYmJtSFRsazNjZnZ2dDBqSlQvdngvZm00VXV3T1BoZml4QW9EWTJGaEdqUnJWMnJNdDRrYVhaTGRnNG9Idm94MEYvUnBBOSs3ZGVYZnV1L3g5enQ4NS8venpwVGIrbmZ1K3c3aHg0NHpxUGNEWUVENldEM0RKMEVzaW5oY0tja21lWUZyQUIxeUxsdEY2QnRwQ0h2ZC85MzQyYmRuRXBFbVRsSFFpSmlhR0YxNTZRYnpMZWtwckh3RXVBU2dvS0lpNC9RNGRPb2lKb1B1aC9Wd2NqUjJDR1FyTVEwdVEwdytnYjcrK0xQMTRLWDk5OXEra3BhVXA3VXh1YnE2WW1hcTF3TE03dXJndnZ2amlpTnVPaVltaGUzY3orTDRMZUIwdHFIWXNLZ1dURGZ3TmJSZmRXTkNPZkR6NTFKTnMvR0lqbDMzdE1vVmRhWXl3Y3QyYVd2c1poZjREK2x2UzlxeVhaOUdsU3hlak9obk5QVjloeWNzbG9FSXdhY0N2Z2ZYQUxhQk5XUDN3Uno5a3g1YzcrTkYvLzBoMENiYlFNZDBNSDlKYmVnNVJNUDJ0RWN5NGNlUFl1R2tqVTZkT05iN1ZHWGdMdU1xU0JpeEdsbUJpZ1F1Qjc2RmQxZkxmNlB0ZXAwNmR5dVl0bTNucWowK1JtWmtwcWZtMjBRWUwweGNnTlRYVjBxV0tyS3dzM25qckRXYS9NdHVZL1UwRS9vRURSV1BWeEYwdllBUXdIQmlHRmhnMld0RExMOGpueVNlZlpQU1kwUlkxYVIxdGRVbjkrdmV6ZktqdjgvbTQ4ODQ3U1U5UDU5YnB0MUpYVjJlSVppbzJwNHNYaWNUQ3BBUDNvaDBGK1J4NEVYZ0FiWjdDRkV0dXIxem12RG1IRlN0WE9GSXNBR25wcGs1Q0VzeUEvZ09rOVdYS2xDbTgrZmFib3FWNUNRZk5BcmZWd3NRQWx3SjNBRGVnanhnTUVoSVNHSExKRVBMeThoZ3hZZ1I1ZVhsY1BQRGlpTlpiVkNCWW1BNW8vOGFtTWo0bG82ODVXUlh3TnNlVUtWUDR5MS8vd25mdi95NW9TeVZQQTkvRUFZZnoyeUtZeTRIZm84VW1KajE3OXVUdWUrNW04dVRKREJvOGlJU0VCRXM3cUFKQk1ENGdGWDJYWHhCOWpJSnN3UURjKzYxN21mLytmT2JObXdkd0k3QUlCeHloRFVVdzNZREhnYThiMzBoSVNPQ0dHMjdnbTkvNkp1UEhqM2U4QldrTklWc2xOSjlTM3R6bDNiTkhUNm45QVMybW1mbkNURDY1NUJNT0h6NE04Q1JhdnBqOTBodHZnWlppbUFUZ0IyaTNsMzRkdE5IQmpNZG5zSzlrSDNQZW5NT0VDUk5jTHhaQVBPcFJCOVEyODVqeXhJVG5uMzgrTDg1NjBhaDJRSnZIc3ZVSDNweGcrcURsdHY4ZGtBSXdmZnAwdG16YndzLy81K2QwNnRSSlZmK1VJQWlta3ViakJQUElncFduRjFyanV1dXU0enYzZmNlb2prRmJlN09OcGdSVGdKYU03MExRRG1sOThPRUgvT09OZjRTOU85N3BWSjZvTklzdFBIWldNSDYxcVZ1ZWZPcEordmJyYTFRZkFZWW83WUJBc0dDbW91VzB6d0J0K1gvRDV4c1lQMzY4OG82cEpNakNOSWN0RmdhMFVPQzExMTR6M0g4ODhBSkJJMVJWR0lMeEFUOUdTeldSRUJjWHgwdXpYbUxHNHpOY09lcHBLeWNxUXhLTUdjT29GZ3pBeUZFamVlVFJSNHpxaGNCdmxIZUNzNEw1TmZBcjBEWTJ6MTg0bjd2dnVkdU8vdGhDV3kyTTFYY2doTXIvL09KL3lDOHdEeXg4bDlEMjcxaEtETnB5K24rQk5xZXlmTVh5ZHUrQ1JQeCtQOGVPbWtrWFd4TE1HYU1RZENaYUdYRnhjYno2NnFza0o1c1Q2WGVvN2tNTTJveHRMTURMcjd3YzBiRUp0K0gzKy9uZUE5L2owQ0h6b0g5eEM0L3ZSRThsdHF4d21leXVOVXVmdm4wWU85WTBMRU5WdHg4RDNBU1FuWjNOMk11VVd6amJNTVF5NnlVelE5Z090UFd3NXFoQjJ5RW81ZEtNdGpBOGI3aFI3STgrN2FHS0dQUXA3M0hqeG9uYkJkc3RmcitmK2ZQbk0zN2MrR0N4VEFHT3R2THhqd0gyN3RuTDdsMjdKZmF5WlhyMzdtMFVyYnd2SVNUaTBNMnNIWkcvVmZqOWZtcHFhcWlxcXFLNnVwclQxYWVwcnE2bXVycWFxdW9xczN6azhCRmVldWtsZGhUdEVEOXVpS1VzaEtZK05nb2ZmdmdoOS9kcGU4WXBLeWd1Tmoybkh6aWdzdTA0dE15TmZQblZsd1FDQVdsSE9scmk0TUdERkJZV2N1VHdrYk8vNktCZmZsVlZGZFducTgyL1AxMTkrdXd6cDArSDAreEpZRFphaXZianJUeHJzQTB0ajI3bkR4WjlFRmFLTWl2NDlCUHpydlA5TkwrVUlRVWYydlQvRHdEbUw1elAxVmRmTGIzUm1wb2FWcTVjeWVJUEZ2UGhoeCtLRjNtcjRDRHdIUEFxVGE5S3Q4Ynp3RGQ4UGgrcjE2eG14TWdSbG5hdU5lYk5tOGROTjk1a1ZGOUhIK0dxd2dkMEFqWUJxVDE2OU9EOStlOXo4Y0RJZDhRYkJBSUJ5c3JLMkZHMGc4OC8vNXdQRjMvSTh1WExXN3NIcVFIdFVzeHE0SFFyNWVhK1Y2WC9HZnk5dzBTMmtOZ2JMZUYwd29pUkkxaTJmSm15eWMwVnkxZHc2eTIzR3F2WEo5Qk9ZWWJpU2kzRDhEOC9STXNJU1hwNk9qTWVuMEYyajJ3eU16TEp5TWdnSXpPRGpJeU1jelpyMTlYVlVWVlZwYm1HS3MxdGxCd29vV2g3RVVWRjJ0ZU9vaDB0elZ2NDBWYkRsK3BmTzlCK3VWYmVXaStEWDZQdFUrYVdXMjdoMWRkZmxicHFmL2p3WWY0MjgyL01lR3lHT0duNFgyZ1dSaWsrNGMvL1JwL3RiWTZVbEJUUzB0TE1BRE5vSDBtb2xBQkw5Sy9sdUNRdlNoREphR3R1SXdHbVRadkdjek9mQ3o3SkdEWit2NS9QTjN6T3dvVUxXYkJnQVordCs0eEF3RnhFcndWK0FieU1EVHZ3Z2lQY205RzJBMXFSRzZ3Y0xaWG9EclJKcnkrQklqVEIyTDdWMEFJeWdJWG9xL3JkdW5YanNjY2ZZL3IwNmVMZDJDRlRXVm5KUng5OXhJTDVDL2hnMFFlVWxwWTI5ZGhPNEZ0b0NhOXRvYWtoVVJKYVRwWU10UE8rR1VIbERqU09HNnFDeWtmUi9tSFdYWExrWERxalhWVnpqZkdOek14TUpsOC9tZDY5ZTVPVG0wTnVUaTQ5YzNyU3ZYdDNUcDgremI3aWZld3Qza3Z4M21MMjd0WCszTE4zRDVzM2JXN09ZbThEUHRDL1BrUExHRzRiamovTDZ3SjhhR3M2ajZKZGR0RWtNVEV4b1M1YTFxQ2REbDJzZjVWRTNrWHI4QVJqSFFuQUpMUXowZ05wUVR3Q1o5RG1Vb3JSclBJU3RQc3VIWHY5alNjWWVTU2paYmJxQWZUVS82eEN1K2wrSDVwSUloM2lLK2YvQXl0VWV4V0ZTSGJiQUFBQUFFbEZUa1N1UW1DQyIvPgogICAgPC9kZWZzPgo8L3N2Zz4K';
+
+// Déclaration des locales disponibles pour l'extension
+const AvailableLocales = ['en', 'fr', 'de'];
+
+//Traductions des textes utilisés par l'extension
+const Message = {
+	x: {
+		'en': ' x',
+		'fr': ' x',
+		'de': 'x'
+	},
+	y: {
+		'en': ' y',
+		'fr': ' y',
+		'de': 'y'
+	},
+	peopleCount: {
+		'en': 'people count',
+		'fr': 'nombre de personnes',
+		'de': 'Zahl der Personen'
+	},
+	nose: {
+		'en': 'nose',
+		'fr': 'nez',
+		'de': 'Nase'
+	},
+	leftEye: {
+		'en': 'left eye',
+		'fr': 'oeil gauche',
+		'de': 'linkes Auge'
+	},
+	rightEye: {
+		'en': 'right eye',
+		'fr': 'oeil droit',
+		'de': 'rechtes Auge'
+	},
+	leftEar: {
+		'en': 'left ear',
+		'fr': 'oreille gauche',
+		'de': 'linkes Ohr'
+	},
+	rightEar: {
+		'en': 'right ear',
+		'fr': 'oreille droite',
+		'de': 'rechtes Ohr'
+	},
+	leftShoulder: {
+		'en': 'left shoulder',
+		'fr': 'épaule gauche',
+		'de': 'linke Schulter'
+	},
+	rightShoulder: {
+		'en': 'right shoulder',
+		'fr': 'épaule droite',
+		'de': 'rechte Schulter'
+	},
+	leftElbow: {
+		'en': 'left elbow',
+		'fr': 'coude gauche',
+		'de': 'linker Ellbogen'
+	},
+	rightElbow: {
+		'en': 'right elbow',
+		'fr': 'coude droit',
+		'de': 'rechter Ellbogen'
+	},
+	leftWrist: {
+		'en': 'left wrist',
+		'fr': 'poignet gauche',
+		'de': 'linkes Handgelenk'
+	},
+	rightWrist: {
+		'en': 'right wrist',
+		'fr': 'poignet droit',
+		'de': 'rechtes Handgelenk'
+	},
+	leftHip: {
+		'en': 'left hip',
+		'fr': 'hanche gauche',
+		'de': 'linke Hüfte'
+	},
+	rightHip: {
+		'en': 'right hip',
+		'fr': 'hanche droite',
+		'de': 'rechte Hüfte'
+	},
+	leftKnee: {
+		'en': 'left knee',
+		'fr': 'genou gauche',
+		'de': 'linkes Knie'
+	},
+	rightKnee: {
+		'en': 'right knee',
+		'fr': 'genou droit',
+		'de': 'rechtes Knie'
+	},
+	leftAnkle: {
+		'en': 'left ankle',
+		'fr': 'cheville gauche',
+		'de': 'linker Knöchel'
+	},
+	rightAnkle: {
+		'en': 'right ankle',
+		'fr': 'cheville droite',
+		'de': 'rechter Knöchel'
+	},
+	getX: {
+		'en': '[PART] x of person [PERSON_NUMBER]',
+		'fr': '[PART] x de la personne [PERSON_NUMBER]',
+		'de': '[PART] x von Person [PERSON_NUMBER]'
+	},
+	getY: {
+		'en': '[PART] y of person [PERSON_NUMBER]',
+		'fr': '[PART] y de la personne [PERSON_NUMBER]',
+		'de': '[PART] y von Person [PERSON_NUMBER]'
+	},
+	goTo: {
+		'en': 'go to [PART] of person [PERSON_NUMBER]',
+		'fr': 'aller à [PART] de la personne [PERSON_NUMBER]',
+		'de': 'gehe zu [PART] von Person [PERSON_NUMBER]'
+
+	},
+	glideTo: {
+		'en': 'glide to [PART] of person [PERSON_NUMBER] in [SECS] seconds',
+		'fr': 'glisser vers [PART] de la personne [PERSON_NUMBER] en [SECS] secondes',
+		'de': 'gleite in [SECS] Sek. zu [PART] von Person [PERSON_NUMBER]'
+	},
+	pointTowards: {
+		'en': 'point towards [PART] of person [PERSON_NUMBER]',
+		'fr': 's\'orienter vers [PART] de la personne [PERSON_NUMBER]',
+		'de': 'drehe dich zu [PART] von Person [PERSON_NUMBER]'
+	},
+	videoToggle: {
+		'en': 'turn video [VIDEO_STATE]',
+		'fr': 'mettre caméra sur [VIDEO_STATE]',
+		'de': 'schalte Video [VIDEO_STATE]'
+	},
+	onfront: {
+		'en': 'front camera on',
+		'fr': 'allumer caméra avant',
+		'de': 'Frontkamera einschalten'
+	},
+	onback: {
+		'en': 'back camera on',
+		'fr': 'allumer caméra arrière',
+		'de': 'Rückfahrkamera einschalten'
+	},
+	off: {
+		'en': 'camera off',
+		'fr': 'arrêter la caméra',
+		'de': 'Stopp Kamera'
+	},
+	video_on_flipped: {
+		'en': 'flip camera image',
+		'fr': 'retourner l\'image de la caméra',
+		'de': 'Kameraspiegel'
+	},
+	title: {
+		'en': 'Body detection',
+		'fr': 'Reconnaissance corporelle',
+		'de': 'Körperdetektion'
+	},
+	activateBodydetection: {
+		'en': 'activate bodydetection',
+		'fr': 'activer la reconnaissance corporelle',
+		'de': 'die Körperdetektion aktivieren'
+	},
+	active: {
+		'en': 'bodydetection activated ?',
+		'fr': 'reconnaissance corporelle activée ?',
+		'de': 'Körperdetektion aktiviert ?'
+
+	}
+}
+
+// Déclaration de la classe principale pour les blocs Scratch de détection corporelle
+class Scratch3BodyDetectionBlocks {
+	// Menu pour sélectionner le nombre de personnes détectées
+	get PERSON_NUMBERS_MENU() {
+		return Array.from({
+			length: 10
+		}, (_, i) => ({
+			text: (i + 1).toString(),
+			value: (i + 1).toString()
+		}));
+	}
+
+	// Menu pour sélectionner la partie du corps
+	get PARTS_MENU() {
+		return [{
+				text: Message.nose[this._locale],
+				value: '0'
+			},
+			{
+				text: Message.leftEye[this._locale],
+				value: '1'
+			},
+			{
+				text: Message.rightEye[this._locale],
+				value: '2'
+			},
+			{
+				text: Message.leftEar[this._locale],
+				value: '3'
+			},
+			{
+				text: Message.rightEar[this._locale],
+				value: '4'
+			},
+			{
+				text: Message.leftShoulder[this._locale],
+				value: '5'
+			},
+			{
+				text: Message.rightShoulder[this._locale],
+				value: '6'
+			},
+			{
+				text: Message.leftElbow[this._locale],
+				value: '7'
+			},
+			{
+				text: Message.rightElbow[this._locale],
+				value: '8'
+			},
+			{
+				text: Message.leftWrist[this._locale],
+				value: '9'
+			},
+			{
+				text: Message.rightWrist[this._locale],
+				value: '10'
+			},
+			{
+				text: Message.leftHip[this._locale],
+				value: '11'
+			},
+			{
+				text: Message.rightHip[this._locale],
+				value: '12'
+			},
+			{
+				text: Message.leftKnee[this._locale],
+				value: '13'
+			},
+			{
+				text: Message.rightKnee[this._locale],
+				value: '14'
+			},
+			{
+				text: Message.leftAnkle[this._locale],
+				value: '15'
+			},
+			{
+				text: Message.rightAnkle[this._locale],
+				value: '16'
+			}
+		]
+	}
+
+	// Menu pour gérer l'état de la caméra vidéo
+	get VIDEO_MENU() {
+		return [
+			'onback', 'onfront', 'video_on_flipped', 'off'
+		].map(key => ({
+			text: Message[key][this._locale],
+			value: key
+		}));
+	}
+
+	// Constructeur de la classe
+	constructor(runtime) {
+		this.runtime = runtime; // Référence au runtime Scratch
+
+		this.poses = []; // Tableau pour stocker les poses détectées
+		this.keypoints = []; // Tableau pour stocker les points clés des parties du corps
+		this.active = false; // Indicateur d'activation de la détection des parties du corps
+		this._locale = this.setLocale(); // Configuration de la langue selon l'environnement
+
+		// Fonction pour détecter les parties du corps
+		this.detectPose = () => {
+			// Configuration de la vidéo
+			this.video = this.runtime.ioDevices.video.provider.video;
+			this.video.width = 480;
+			this.video.height = 360;
+			this.video.autoplay = true;
+
+			// Initialisation de PoseNet via ml5
+			this.poseNet = ml5.poseNet(this.video, () => {
+				console.log('Model Loaded!'); // Indication que le modèle est chargé
+			});
+
+			// Gestion des événements lorsque des parties du corps sont détectées
+			this.poseNet.on('pose', (poses) => {
+				if (poses.length > 0) {
+					this.poses = poses; // Stockage des parties du corps détectées
+					this.keypoints = poses[0].pose.keypoints; // Stockage des points clés
+				} else {
+					this.poses = []; // Pas de partie du corps détectée
+					this.keypoints = [];
+				}
+			});
+		}
+
+	}
+
+	// Fonction pour fournir des informations sur les blocs
+	getInfo() {
+		return {
+			id: 'bodydetection',
+			name: Message.title[this._locale], // Nom de l'extension
+			blockIconURI: blockIconURI, // Icône de l'extension
+
+			//Définition de l'ensemble des blocs de l'extension
+			blocks: [{
+					opcode: 'activateBodydetection',
+					blockType: BlockType.COMMAND,
+					text: Message.activateBodydetection[this._locale],
+				},
+				{
+					opcode: 'activated',
+					text: Message.active[this._locale],
+					blockType: BlockType.BOOLEAN
+				},
+				'---',
+				'---',
+				{
+					opcode: 'videoToggle',
+					blockType: BlockType.COMMAND,
+					text: Message.videoToggle[this._locale],
+					arguments: {
+						VIDEO_STATE: {
+							type: ArgumentType.STRING,
+							menu: 'videoMenu',
+							defaultValue: 'onfront'
+						}
+					}
+				},
+				{
+					opcode: 'setVideoTransparency',
+					text: formatMessage({
+						id: 'videoSensing.setVideoTransparency',
+						default: 'set video transparency to [TRANSPARENCY]',
+						description: 'Controls transparency of the video preview layer'
+					}),
+					arguments: {
+						TRANSPARENCY: {
+							type: ArgumentType.NUMBER,
+							defaultValue: 50
+						}
+					}
+				},
+				'---',
+				'---',
+				{
+					opcode: 'getX',
+					blockType: BlockType.REPORTER,
+					text: Message.getX[this._locale],
+					arguments: {
+						PERSON_NUMBER: {
+							type: ArgumentType.STRING,
+							menu: 'personNumbers',
+							defaultValue: '1'
+						},
+						PART: {
+							type: ArgumentType.STRING,
+							menu: 'parts',
+							defaultValue: '0'
+						}
+					}
+				},
+				{
+					opcode: 'getY',
+					blockType: BlockType.REPORTER,
+					text: Message.getY[this._locale],
+					arguments: {
+						PERSON_NUMBER: {
+							type: ArgumentType.STRING,
+							menu: 'personNumbers',
+							defaultValue: '1'
+						},
+						PART: {
+							type: ArgumentType.STRING,
+							menu: 'parts',
+							defaultValue: '0'
+						}
+					}
+				},
+				'---',
+				{
+					opcode: 'goTo',
+					blockType: BlockType.COMMAND,
+					text: Message.goTo[this._locale],
+					arguments: {
+						PERSON_NUMBER: {
+							type: ArgumentType.STRING,
+							menu: 'personNumbers',
+							defaultValue: '1'
+						},
+						PART: {
+							type: ArgumentType.STRING,
+							menu: 'parts',
+							defaultValue: '0'
+						}
+					}
+				},
+				{
+					opcode: 'glideTo',
+					blockType: BlockType.COMMAND,
+					text: Message.glideTo[this._locale],
+					arguments: {
+						PERSON_NUMBER: {
+							type: ArgumentType.STRING,
+							menu: 'personNumbers',
+							defaultValue: '1'
+						},
+						PART: {
+							type: ArgumentType.STRING,
+							menu: 'parts',
+							defaultValue: '0'
+						},
+						SECS: {
+							type: ArgumentType.NUMBER,
+							defaultValue: '1'
+						}
+					}
+				},
+				{
+					opcode: 'pointTowards',
+					blockType: BlockType.COMMAND,
+					text: Message.pointTowards[this._locale],
+					arguments: {
+						PERSON_NUMBER: {
+							type: ArgumentType.STRING,
+							menu: 'personNumbers',
+							defaultValue: '1'
+						},
+						PART: {
+							type: ArgumentType.STRING,
+							menu: 'parts',
+							defaultValue: '0'
+						}
+					}
+				},
+				'---',
+				{
+					opcode: 'getPeopleCount',
+					blockType: BlockType.REPORTER,
+					text: Message.peopleCount[this._locale]
+				}
+			],
+			menus: {
+				personNumbers: {
+					acceptReporters: true,
+					items: this.PERSON_NUMBERS_MENU
+				},
+				parts: {
+					acceptReporters: true,
+					items: this.PARTS_MENU
+				},
+				videoMenu: {
+					acceptReporters: false,
+					items: this.VIDEO_MENU
+				}
+			}
+		};
+	}
+
+	// Fonction pour obtenir la position X d'une partie du corps
+	getX(args) {
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			if (this.runtime.ioDevices.video.mirror === false) {
+				return -1 * (240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x);
+			} else {
+				return 240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x;
+			}
+		} else {
+			return "";
+		}
+	}
+
+	// Fonction pour obtenir la position Y d'une partie du corps
+	getY(args) {
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			return 180 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.y;
+		} else {
+			return "";
+		}
+	}
+
+	// Fonction pour se déplacer directement vers une partie du corps
+	goTo(args, util) {
+		let targetX = 0;
+		let targetY = 0;
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			if (this.runtime.ioDevices.video.mirror === false) {
+				targetX = -1 * (240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x);
+			} else {
+				targetX = 240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x;
+			}
+		} else {
+			targetX = 0;
+		}
+
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			targetY = 180 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.y;
+		} else {
+			targetY = 0;
+		}
+
+		util.target.setXY(targetX, targetY);
+	}
+	activated(args, util) {
+		return this.active;
+	}
+
+	// Fonction qui permet de déplacer le sprite à partir d'arguments comme la position X,Y et le nombre de secondes
+	// Est utilisée par la fonction glideTo
+	glide(args, util) {
+		if (util.stackFrame.timer) {
+			const timeElapsed = util.stackFrame.timer.timeElapsed();
+			if (timeElapsed < util.stackFrame.duration * 1000) {
+				const frac = timeElapsed / (util.stackFrame.duration * 1000);
+				const dx = frac * (util.stackFrame.endX - util.stackFrame.startX);
+				const dy = frac * (util.stackFrame.endY - util.stackFrame.startY);
+				util.target.setXY(
+					util.stackFrame.startX + dx,
+					util.stackFrame.startY + dy
+				);
+				util.yield();
+			} else {
+				util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
+			}
+		} else {
+			util.stackFrame.timer = new Timer();
+			util.stackFrame.timer.start();
+			util.stackFrame.duration = Cast.toNumber(args.SECS);
+			util.stackFrame.startX = util.target.x;
+			util.stackFrame.startY = util.target.y;
+			util.stackFrame.endX = Cast.toNumber(args.X);
+			util.stackFrame.endY = Cast.toNumber(args.Y);
+			if (util.stackFrame.duration <= 0) {
+				util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
+				return;
+			}
+			util.yield();
+		}
+	}
+
+	// Fonction pour se déplacer en glissant vers la position d'une partie du corps
+	// Utilise la fonction glide
+	glideTo(args, util) {
+		let targetX = 0;
+		let targetY = 0;
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			if (this.runtime.ioDevices.video.mirror === false) {
+				targetX = -1 * (240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x);
+			} else {
+				targetX = 240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x;
+			}
+		} else {
+			targetX = 0;
+		}
+
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			targetY = 180 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.y;
+		} else {
+			targetY = 0;
+		}
+
+		this.glide({
+			SECS: args.SECS,
+			X: targetX,
+			Y: targetY
+		}, util);
+
+	}
+
+	// Fonction qui permet d'orienter le sprite vers la position d'une partie du corps
+	pointTowards(args, util) {
+		let targetX = 0;
+		let targetY = 0;
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			if (this.runtime.ioDevices.video.mirror === false) {
+				targetX = -1 * (240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x);
+			} else {
+				targetX = 240 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.x;
+			}
+		} else {
+			targetX = 0;
+		}
+
+		if (this.poses[parseInt(args.PERSON_NUMBER, 10) - 1] && this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)]) {
+			targetY = 180 - this.poses[parseInt(args.PERSON_NUMBER, 10) - 1].pose.keypoints[parseInt(args.PART, 10)].position.y;
+		} else {
+			targetY = 0;
+		}
+
+		const dx = targetX - util.target.x;
+		const dy = targetY - util.target.y;
+		const direction = 90 - Math.atan2(dy, dx) * (180 / Math.PI);
+		util.target.setDirection(direction);
+	}
+
+	// Fonction permettant de compter le nombre de personnes détectées sur la caméra
+	getPeopleCount() {
+		return this.poses.length;
+	}
+
+	// Fonction pour activer la détection corporelle
+	activateBodydetection(args) {
+		if (!this.runtime.ioDevices.video.videoReady) {
+			alert('Il faut d\'abord activer la vidéo');
+		} else {
+			this.active = true;
+			this.detectPose();
+		}
+
+	}
+
+	// Fonction permettant d'activer la vidéo et de changer de caméra
+	videoToggle(args) {
+		switch (args.VIDEO_STATE) {
+			case 'off':
+				this.runtime.ioDevices.video.disableVideo();
+				if (this.active) {
+					this.poseNet.dispose();
+					this.active = false;
+				}
+				break;
+			case 'onback':
+				this.runtime.ioDevices.video.enableVideo('environment');
+				this.runtime.ioDevices.video.mirror = false;
+				this.active = true;
+				break;
+			case 'onfront':
+				this.runtime.ioDevices.video.enableVideo('user');
+				this.runtime.ioDevices.video.mirror = true;
+				this.active = true;
+				break;
+			default:
+				this.runtime.ioDevices.video.mirror = !this.runtime.ioDevices.video.mirror;
+		}
+
+	}
+
+	// Fonction permettant de changer la transparence d'affichage de la caméra sur la scène
+	setVideoTransparency(args) {
+		const transparency = Cast.toNumber(args.TRANSPARENCY);
+		this.globalVideoTransparency = transparency;
+		this.runtime.ioDevices.video.setPreviewGhost(transparency);
+	}
+
+	// Fonction permettant de définir la langue de l'extension en fonction de la langue définit dans Scratch.
+	// Si la traduction d'une langue n'est pas disponible dans l'extension, c'est l'anglais qui est choisi
+	setLocale() {
+		let locale = formatMessage.setup().locale || 'en';
+		return AvailableLocales.includes(locale) ? locale : 'en';
+	}
+}
+
+module.exports = Scratch3BodyDetectionBlocks;
\ No newline at end of file
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_boost/index.js b/node_modules/scratch-vm/src/extensions/scratch3_boost/index.js
index 21564be..73da54c 100644
--- a/node_modules/scratch-vm/src/extensions/scratch3_boost/index.js
+++ b/node_modules/scratch-vm/src/extensions/scratch3_boost/index.js
@@ -142,6 +142,16 @@ const BoostColorIndex = {
     [BoostColor.BLACK]: 0
 };
 
+/**
+ * Enum for comparison-operator
+ * @type {{LESS: string, GREATER: string, EQUAL: string}}
+ */
+const BoostOperator = {
+    LESS: '<',
+    GREATER: '>',
+    EQUAL: '='
+};
+
 /**
  * Enum for Message Types
  * @readonly
@@ -282,6 +292,7 @@ const BoostMode = {
     TILT: 0, // angle (pitch/yaw)
     LED: 1, // Set LED to accept RGB values
     COLOR: 0, // Read indexed colors from Vision Sensor
+    COLOR_DISTANCE: 8, // Read indexed colors from Vision Sensor and the distance
     MOTOR_SENSOR: 2, // Set motors to report their position
     UNKNOWN: 0 // Anything else will use the default mode (mode 0)
 };
@@ -694,7 +705,8 @@ class Boost {
             tiltX: 0,
             tiltY: 0,
             color: BoostColor.NONE,
-            previousColor: BoostColor.NONE
+            previousColor: BoostColor.NONE,
+            distance: null
         };
 
         /**
@@ -761,6 +773,15 @@ class Boost {
         return this._sensors.previousColor;
     }
 
+    /**
+     *
+     * @returns {number} - the latest distance in float inches received from the vision sensor. Resolution is higher
+     * for closer distances.
+     */
+    get distance () {
+        return this._sensors.distance;
+    }
+
     /**
      * Look up the color id for an index received from the vision sensor.
      * @param {number} index - the color index to look up.
@@ -892,7 +913,8 @@ class Boost {
             tiltX: 0,
             tiltY: 0,
             color: BoostColor.NONE,
-            previousColor: BoostColor.NONE
+            previousColor: BoostColor.NONE,
+            distance: null
         };
 
         if (this._pingDeviceId) {
@@ -1073,7 +1095,7 @@ class Boost {
                 this._sensors.tiltX = data[4];
                 this._sensors.tiltY = data[5];
                 break;
-            case BoostIO.COLOR:
+            case BoostIO.COLOR: {
                 this._colorSamples.unshift(data[4]);
                 if (this._colorSamples.length > BoostColorSampleSize) {
                     this._colorSamples.pop();
@@ -1086,7 +1108,15 @@ class Boost {
                 } else {
                     this._sensors.color = BoostColor.NONE;
                 }
+                const distance = data[5];
+                const partialDistance = data[7];
+                let totalDistance = distance;
+                if (partialDistance > 0) {
+                    totalDistance = totalDistance + (1 / partialDistance);
+                }
+                this._sensors.distance = totalDistance;
                 break;
+            }
             case BoostIO.MOTOREXT:
             case BoostIO.MOTORINT:
                 this.motor(portID).position = int32ArrayToNumber(data.slice(4, 8));
@@ -1162,7 +1192,7 @@ class Boost {
             mode = BoostMode.MOTOR_SENSOR;
             break;
         case BoostIO.COLOR:
-            mode = BoostMode.COLOR;
+            mode = BoostMode.COLOR_DISTANCE;
             delta = 0;
             break;
         case BoostIO.LED:
@@ -1203,6 +1233,7 @@ class Boost {
         }
         if (type === BoostIO.COLOR) {
             this._sensors.color = BoostColor.NONE;
+            this._sensors.distance = null;
         }
         this._ports[portID] = 'none';
         this._motors[portID] = null;
@@ -1452,6 +1483,35 @@ class Scratch3BoostBlocks {
                         }
                     }
                 },
+                {
+                    opcode: 'whenDistance',
+                    text: formatMessage({
+                        id: 'boost.whenDistance',
+                        default: 'when distance [OPERATOR] [THRESHOLD]',
+                        description: 'when distance fulfils the given condition'
+                    }),
+                    blockType: BlockType.HAT,
+                    arguments: {
+                        OPERATOR: {
+                            type: ArgumentType.STRING,
+                            menu: 'OPERATOR',
+                            defaultValue: BoostOperator.LESS
+                        },
+                        THRESHOLD: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 5
+                        }
+                    }
+                },
+                {
+                    opcode: 'getDistance',
+                    text: formatMessage({
+                        id: 'boost.getDistance',
+                        default: 'distance',
+                        description: 'the distance returned by the vision sensor'
+                    }),
+                    blockType: BlockType.REPORTER
+                },
                 {
                     opcode: 'whenTilted',
                     text: formatMessage({
@@ -1722,6 +1782,23 @@ class Scratch3BoostBlocks {
                             value: BoostColor.ANY
                         }
                     ]
+                },
+                OPERATOR: {
+                    acceptReporters: true,
+                    items: [
+                        {
+                            text: BoostOperator.LESS,
+                            value: BoostOperator.LESS
+                        },
+                        {
+                            text: BoostOperator.GREATER,
+                            value: BoostOperator.GREATER
+                        },
+                        {
+                            text: BoostOperator.EQUAL,
+                            value: BoostOperator.EQUAL
+                        }
+                    ]
                 }
             }
         };
@@ -2083,6 +2160,35 @@ class Scratch3BoostBlocks {
         return args.COLOR === this._peripheral.color;
     }
 
+    /**
+     * Edge-triggering hat function, for when the vision sensor is detecting a distance (in float inches)
+     * for the given condition.
+     * @param {object} args - the block's arguments
+     * @return {boolean} - true when the distance fulfils the condition, false otherwise.
+     */
+    whenDistance (args) {
+        const threshold = Cast.toNumber(args.THRESHOLD);
+
+        if (this._peripheral.distance === null) {
+            return false;
+        } else if (args.OPERATOR === BoostOperator.LESS) {
+            return this._peripheral.distance < threshold;
+        } else if (args.OPERATOR === BoostOperator.GREATER) {
+            return this._peripheral.distance > threshold;
+        } else if (args.OPERATOR === BoostOperator.EQUAL) {
+            return this._peripheral.distance === threshold;
+        }
+    }
+
+
+    /**
+     *
+     * @returns {number} the distance (in float inches)
+     */
+    getDistance () {
+        return this._peripheral.distance;
+    }
+
     /**
      * Set the LED's hue.
      * @param {object} args - the block's arguments.
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_facemesh/index.js b/node_modules/scratch-vm/src/extensions/scratch3_facemesh/index.js
new file mode 100644
index 0000000..a337722
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_facemesh/index.js
@@ -0,0 +1,326 @@
+// Importation des modules nécessaires pour l'extension Scratch
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const ml5 = require('ml5'); // Bibliothèque ml5 pour utiliser les modèles de machine learning
+const formatMessage = require('format-message'); // Gestion des messages multilingues
+// Icone pour l'extension
+const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDM1NyAzNTciIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM6c2VyaWY9Imh0dHA6Ly93d3cuc2VyaWYuY29tLyIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxLjU7Ij4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsLTEyOC43NDQsLTUuNjQ2NTEpIj4KICAgICAgICA8cmVjdCBpZD0iUGxhbi1kZS10cmF2YWlsMSIgc2VyaWY6aWQ9IlBsYW4gZGUgdHJhdmFpbDEiIHg9IjEyOC43NDQiIHk9IjUuNjQ3IiB3aWR0aD0iMzU2LjMwMSIgaGVpZ2h0PSIzNTYuMzAxIiBzdHlsZT0iZmlsbDpub25lOyIvPgogICAgICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuMDAxMzQsMCwwLDEsLTAuMTcxOTQ4LDYuMjE3MjVlLTE1KSI+CiAgICAgICAgICAgIDxjbGlwUGF0aCBpZD0iX2NsaXAxIj4KICAgICAgICAgICAgICAgIDxyZWN0IHg9IjEyOC43NDQiIHk9IjUuNjQ3IiB3aWR0aD0iMzU2LjMwMSIgaGVpZ2h0PSIzNTYuMzAxIi8+CiAgICAgICAgICAgIDwvY2xpcFBhdGg+CiAgICAgICAgICAgIDxnIGNsaXAtcGF0aD0idXJsKCNfY2xpcDEpIj4KICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDUuNTE4MjIsMCwwLDEwLjkyODUsLTU1My4yNTQsLTE5My45NjcpIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB4PSIxMjMuNTk0IiB5PSIxOC4xNjkiIHdpZHRoPSI2Ni4zMTIiIGhlaWdodD0iMzMuMTM3IiBzdHlsZT0iZmlsbDpyZ2IoMzgsMTY0LDI1Myk7c3Ryb2tlOnJnYigxOTksMCwxMjMpO3N0cm9rZS13aWR0aDowLjEycHg7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik00NDQsMTgwQzQ0NCwxMDguNzU1IDM4NS43OTcsNTEgMzE0LDUxQzI0Mi4yMDMsNTEgMTg0LDEwOC43NTUgMTg0LDE4MEMxODQsMjUxLjI0NSAyNDIuMjAzLDMwOSAzMTQsMzA5QzM4NS43OTcsMzA5IDQ0NCwyNTEuMjQ1IDQ0NCwxODBaIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6cmdiKDE4LDUsMTAyKTtzdHJva2Utd2lkdGg6OXB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iTGlnbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzIwLDE3M0wzMDgsMTI2IiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6OXB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDEiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzU0LDI2M0wzMjksMjczIiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6OXB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDIiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjY0LDI1MUwzMDQsMjcwIiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6MXB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLW1pdGVybGltaXQ6MjsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNzYsMTIwLjVDMjc2LDExMy41OTYgMjcwLjQwNCwxMDggMjYzLjUsMTA4QzI1Ni41OTYsMTA4IDI1MSwxMTMuNTk2IDI1MSwxMjAuNUMyNTEsMTI3LjQwNCAyNTYuNTk2LDEzMyAyNjMuNSwxMzNDMjcwLjQwNCwxMzMgMjc2LDEyNy40MDQgMjc2LDEyMC41WiIgc3R5bGU9ImZpbGw6d2hpdGU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOnJnYigxOCw1LDEwMik7c3Ryb2tlLXdpZHRoOjlweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IkVsbGlwc2UtY29waWUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzczLDExMi41QzM3MywxMDUuNTk2IDM2Ny40MDQsMTAwIDM2MC41LDEwMEMzNTMuNTk2LDEwMCAzNDgsMTA1LjU5NiAzNDgsMTEyLjVDMzQ4LDExOS40MDQgMzUzLjU5NiwxMjUgMzYwLjUsMTI1QzM2Ny40MDQsMTI1IDM3MywxMTkuNDA0IDM3MywxMTIuNVoiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpyZ2IoMTgsNSwxMDIpO3N0cm9rZS13aWR0aDo5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTYiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNDY2LDEyMC41QzQ2NiwxMTMuNTk2IDQ2MC40MDQsMTA4IDQ1My41LDEwOEM0NDYuNTk2LDEwOCA0NDEsMTEzLjU5NiA0NDEsMTIwLjVDNDQxLDEyNy40MDQgNDQ2LjU5NiwxMzMgNDUzLjUsMTMzQzQ2MC40MDQsMTMzIDQ2NiwxMjcuNDA0IDQ2NiwxMjAuNVoiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpyZ2IoMTgsNSwxMDIpO3N0cm9rZS13aWR0aDo5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTciIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTg3LDEyMC41QzE4NywxMTMuNTk2IDE4MS40MDQsMTA4IDE3NC41LDEwOEMxNjcuNTk2LDEwOCAxNjIsMTEzLjU5NiAxNjIsMTIwLjVDMTYyLDEyNy40MDQgMTY3LjU5NiwxMzMgMTc0LjUsMTMzQzE4MS40MDQsMTMzIDE4NywxMjcuNDA0IDE4NywxMjAuNVoiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpyZ2IoMTgsNSwxMDIpO3N0cm9rZS13aWR0aDo5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTIiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzM2LDE4NS41QzMzNiwxNzguNTk2IDMzMC40MDQsMTczIDMyMy41LDE3M0MzMTYuNTk2LDE3MyAzMTEsMTc4LjU5NiAzMTEsMTg1LjVDMzExLDE5Mi40MDQgMzE2LjU5NiwxOTggMzIzLjUsMTk4QzMzMC40MDQsMTk4IDMzNiwxOTIuNDA0IDMzNiwxODUuNVoiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpyZ2IoMTgsNSwxMDIpO3N0cm9rZS13aWR0aDo5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTMiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjY0LDI0MC41QzI2NCwyMzMuNTk2IDI1OC40MDQsMjI4IDI1MS41LDIyOEMyNDQuNTk2LDIyOCAyMzksMjMzLjU5NiAyMzksMjQwLjVDMjM5LDI0Ny40MDQgMjQ0LjU5NiwyNTMgMjUxLjUsMjUzQzI1OC40MDQsMjUzIDI2NCwyNDcuNDA0IDI2NCwyNDAuNVoiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpyZ2IoMTgsNSwxMDIpO3N0cm9rZS13aWR0aDo5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTQiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzI5LDI3NS41QzMyOSwyNjguNTk2IDMyMy40MDQsMjYzIDMxNi41LDI2M0MzMDkuNTk2LDI2MyAzMDQsMjY4LjU5NiAzMDQsMjc1LjVDMzA0LDI4Mi40MDQgMzA5LjU5NiwyODggMzE2LjUsMjg4QzMyMy40MDQsMjg4IDMyOSwyODIuNDA0IDMyOSwyNzUuNVoiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpyZ2IoMTgsNSwxMDIpO3N0cm9rZS13aWR0aDo5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoNCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xODcsMTI1TDI1MSwxMjAiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoNSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xODQsMTI5TDIzOSwyMjgiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoNiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNTIsMjI4TDI2NCwxMzMiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoNyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNzYsMTIwTDM0OCwxMTIiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoOCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNzMsMTEyTDQ0MSwxMTYiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoOSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik00NDksMTMzTDM4MCwyNDgiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTAiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzYxLDI0NEwzMjksMTk4IiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6MnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDExIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAuNzQ0MzM1LDAuNjQ2NTA4KSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMyOSwxNzVMMzYxLDEyNiIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6cmdiKDkzLDg2LDE0Myk7c3Ryb2tlLXdpZHRoOjNweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgxMiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNjgsMTI1TDM2OCwyNDAiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTMiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzIwLDI2M0wzMjAsMTk4IiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6M3B4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDE0IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAuNzQ0MzM1LDAuNjQ2NTA4KSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMwNCwyNzNMMjY0LDI0OCIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6cmdiKDkzLDg2LDE0Myk7c3Ryb2tlLXdpZHRoOjlweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgxNSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMTEsMjYzTDI2NCwxMzkiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTYiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTgxLDEyNUwzMTEsMjYzIiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6MnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDE3IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAuNzQ0MzM1LDAuNjQ2NTA4KSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQ0MSwxMjBMMzM2LDE4MCIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6cmdiKDkzLDg2LDE0Myk7c3Ryb2tlLXdpZHRoOjJweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgxOCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMDgsMTg1TDE4NywxMjkiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTkiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNDQxLDEyNkwzMjQsMjYzIiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6MnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDIwIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAuNzQ0MzM1LDAuNjQ2NTA4KSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0NiwyNTNMMjI1LDI3NyIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6cmdiKDkzLDg2LDE0Myk7c3Ryb2tlLXdpZHRoOjJweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgyMSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMDQsMjc2Ljk5OUwyMzAsMjc3IiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6MnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDIyIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAuNzQ0MzM1LDAuNjQ2NTA4KSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMyMCwyODhMMzI5LDMwOSIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6cmdiKDkzLDg2LDE0Myk7c3Ryb2tlLXdpZHRoOjJweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgyMyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNzMsMjY5TDMyOSwzMDkiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjQiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjM2LDI0MEwxODEsMjAxIiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoOTMsODYsMTQzKTtzdHJva2Utd2lkdGg6MnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDI1IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAuNzQ0MzM1LDAuNjQ2NTA4KSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE3NSwxMzNMMTgxLDIwMSIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6cmdiKDkzLDg2LDE0Myk7c3Ryb2tlLXdpZHRoOjJweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgyNiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLjc0NDMzNSwwLjY0NjUwOCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zODAsMjYwTDQxNywyNTYiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjciIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzYxLDEwMEwzMTQsNTEiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjgiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjY0LDEwOEwzMTcsNTEiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjkiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTc1LDEwOEwzMTQsNTEiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMzAiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNDQxLDEwOEwzMjAsNTEiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOnJnYig5Myw4NiwxNDMpO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMC43NDQzMzUsMC42NDY1MDgpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzgwLDI1Ni41QzM4MCwyNDkuNTk2IDM3NC40MDQsMjQ0IDM2Ny41LDI0NEMzNjAuNTk2LDI0NCAzNTUsMjQ5LjU5NiAzNTUsMjU2LjVDMzU1LDI2My40MDQgMzYwLjU5NiwyNjkgMzY3LjUsMjY5QzM3NC40MDQsMjY5IDM4MCwyNjMuNDA0IDM4MCwyNTYuNVoiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpyZ2IoMTgsNSwxMDIpO3N0cm9rZS13aWR0aDo5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==';
+
+// Déclaration des locales disponibles pour l'extension
+const AvailableLocales = ['en', 'fr', 'de'];
+
+//Traductions des textes utilisés par l'extension
+const Message = {
+	activateFacemesh: {
+		'en': 'activate facemesh',
+		'fr': 'activer le maillage du visage',
+		'de': 'facemesh aktivieren'
+
+	},
+	please_wait: {
+		'en': 'Setup takes a while. The browser will get stuck, but please wait.',
+		'fr': 'Le temps de chargement peut être un peu long, merci de patienter.',
+		'de': 'Die Ladezeit kann etwas länger dauern, bitte haben Sie etwas Geduld.'
+	},
+	videoToggle: {
+		'en': 'turn video [VIDEO_STATE]',
+		'fr': 'mettre caméra sur [VIDEO_STATE]',
+		'de': 'schalte Video [VIDEO_STATE]'
+	},
+	onfront: {
+		'en': 'front camera on',
+		'fr': 'allumer caméra avant',
+		'de': 'Frontkamera einschalten'
+	},
+	onback: {
+		'en': 'back camera on',
+		'fr': 'allumer caméra arrière',
+		'de': 'Rückfahrkamera einschalten'
+	},
+	off: {
+		'en': 'camera off',
+		'fr': 'arrêter la caméra',
+		'de': 'Stopp Kamera'
+	},
+	video_on_flipped: {
+		'en': 'flip camera image',
+		'fr': 'retourner l\'image de la caméra',
+		'de': 'Kameraspiegel'
+	},
+	getX: {
+		'en': 'x position of keypoint [KEYPOINT] of person [PERSON_NUMBER]',
+		'fr': 'abscisse x du point [KEYPOINT] de la personne [PERSON_NUMBER]',
+		'de': 'x-Position des Keypoints [KEYPOINT] der Person [PERSON_NUMBER]'
+	},
+	getY: {
+		'en': 'y position of keypoint [KEYPOINT] of person [PERSON_NUMBER]',
+		'fr': 'ordonnée y du point [KEYPOINT] de la personne [PERSON_NUMBER]',
+		'de': 'y-Position des Keypoints [KEYPOINT] der Person [PERSON_NUMBER]'
+	},
+	peopleCount: {
+		'en': 'people count',
+		'fr': 'nombre de personnes',
+		'de': 'Zahl der Personen'
+	},
+	active: {
+		'en': 'facemesh activated ?',
+		'fr': 'maillage du visage activée ?',
+		'de': 'facemesh aktiviert ?'
+
+	}
+}
+
+function createMenu(count) {
+	return Array.from({
+		length: count
+	}, (_, i) => ({
+		text: (i + 1).toString(),
+		value: (i + 1).toString()
+	}));
+}
+
+// Déclaration de la classe principale pour les blocs Scratch des points du visage
+class Scratch3FacemeshBlocks {
+	// Menu pour sélectionner le nombre de personnes détectées
+	get PERSON_NUMBER_MENU() {
+		return createMenu(10);
+	}
+
+	get KEYPOINT_MENU() {
+		return createMenu(468);
+	}
+
+	// Menu pour gérer l'état de la caméra vidéo
+	get VIDEO_MENU() {
+		return [
+			'onback', 'onfront', 'video_on_flipped', 'off'
+		].map(key => ({
+			text: Message[key][this._locale],
+			value: key
+		}));
+	}
+
+	constructor(runtime) {
+		this.runtime = runtime; // Référence au runtime Scratch
+
+		this.faces = []; // Tableau pour stocker les points du visage
+		this.ratio = 0.75;
+		this.active = false; // Indicateur d'activation de la détection des points du visage
+		this._locale = this.setLocale();
+
+		// Fonction pour détecter les points du visage
+		this.detectFace = () => {
+			// Configuration de la vidéo
+			this.video = this.runtime.ioDevices.video.provider.video
+			this.video.width = 480;
+			this.video.height = 360;
+			this.video.autoplay = true;
+			alert(Message.please_wait[this._locale]);
+
+			// Initialisation de FaceMesh via ml5
+			this.facemesh = ml5.facemesh(this.video, function() {
+				console.log("Model loaded!") // Indication que le modèle est chargé
+			});
+
+			// Gestion des événements lorsque des points du visage sont détectés
+			this.facemesh.on('predict', faces => {
+				if (faces.length < this.faces.length) {
+					this.faces.splice(faces.length);
+				}
+				faces.forEach((face, index) => {
+					this.faces[index] = {
+						keypoints: face.scaledMesh
+					}; // Stockage des points du visage
+				});
+			});
+		}
+
+	}
+
+	// Fonction pour fournir des informations sur les blocs
+	getInfo() {
+
+		const COLORS = {
+			primary: '#26a4fd',
+			secondary: '#055c9a'
+		};
+
+		return {
+			id: 'facemesh',
+			name: 'Facemesh',
+			color1: COLORS.primary,
+			color2: COLORS.secondary,
+			blockIconURI: blockIconURI,
+			blocks: [{
+					opcode: 'activateFacemesh',
+					blockType: BlockType.COMMAND,
+					text: Message.activateFacemesh[this._locale],
+				},
+				{
+					opcode: 'activated',
+					text: Message.active[this._locale],
+					blockType: BlockType.BOOLEAN
+				},
+				'---',
+				'---',
+				{
+					opcode: 'videoToggle',
+					blockType: BlockType.COMMAND,
+					text: Message.videoToggle[this._locale],
+					arguments: {
+						VIDEO_STATE: {
+							type: ArgumentType.STRING,
+							menu: 'videoMenu',
+							defaultValue: 'onfront'
+						}
+					}
+				},
+				{
+					opcode: 'setVideoTransparency',
+					text: formatMessage({
+						id: 'videoSensing.setVideoTransparency',
+						default: 'set video transparency to [TRANSPARENCY]',
+						description: 'Controls transparency of the video preview layer'
+					}),
+					arguments: {
+						TRANSPARENCY: {
+							type: ArgumentType.NUMBER,
+							defaultValue: 50
+						}
+					}
+				},
+				'---',
+				'---',
+				{
+					opcode: 'getX',
+					blockType: BlockType.REPORTER,
+					text: Message.getX[this._locale],
+					arguments: {
+						PERSON_NUMBER: {
+							type: ArgumentType.STRING,
+							menu: 'personNumberMenu',
+							defaultValue: '1'
+						},
+						KEYPOINT: {
+							type: ArgumentType.STRING,
+							menu: 'keypointMenu',
+							defaultValue: '1'
+						}
+					}
+				},
+				{
+					opcode: 'getY',
+					blockType: BlockType.REPORTER,
+					text: Message.getY[this._locale],
+					arguments: {
+						PERSON_NUMBER: {
+							type: ArgumentType.STRING,
+							menu: 'personNumberMenu',
+							defaultValue: '1'
+						},
+						KEYPOINT: {
+							type: ArgumentType.STRING,
+							menu: 'keypointMenu',
+							defaultValue: '1'
+						}
+					}
+				},
+				{
+					opcode: 'getPeopleCount',
+					blockType: BlockType.REPORTER,
+					text: Message.peopleCount[this._locale]
+				}
+			],
+			menus: {
+				personNumberMenu: {
+					acceptReporters: true,
+					items: this.PERSON_NUMBER_MENU
+				},
+				keypointMenu: {
+					acceptReporters: true,
+					items: this.KEYPOINT_MENU
+				},
+				videoMenu: {
+					acceptReporters: true,
+					items: this.VIDEO_MENU
+				}
+			}
+		};
+	}
+
+	getKeypointPosition(personNumber, keypoint, axis) {
+		const person = this.faces[parseInt(personNumber, 10) - 1];
+		if (person && person.keypoints[keypoint]) {
+			return axis === 'x' ? person.keypoints[keypoint][0] * this.ratio : person.keypoints[keypoint][1] * this.ratio;
+		}
+		return '';
+	}
+
+	getX(args) {
+		const keypointPosition = this.getKeypointPosition(args.PERSON_NUMBER, args.KEYPOINT, 'x');
+		return this.runtime.ioDevices.video.mirror ? 240 - keypointPosition : -1 * (240 - keypointPosition);
+	}
+
+	getY(args) {
+		return 180 - this.getKeypointPosition(args.PERSON_NUMBER, args.KEYPOINT, 'y');
+	}
+
+	getPeopleCount() {
+		return this.faces.length;
+	}
+
+	activateFacemesh(args) {
+		if (!this.runtime.ioDevices.video.videoReady) {
+			alert('Il faut d\'abord activer la vidéo');
+		} else {
+			this.active = true;
+			this.detectFace();
+		}
+	}
+	activated(args, util) {
+		return this.active;
+	}
+
+	// Fonction permettant d'activer la vidéo et de changer de caméra
+	videoToggle(args) {
+		switch (args.VIDEO_STATE) {
+			case 'off':
+				this.runtime.ioDevices.video.disableVideo();
+				if (this.active) {
+					this.facemesh = null;
+					this.active = false;
+				}
+				break;
+			case 'onback':
+				this.runtime.ioDevices.video.enableVideo('environment');
+				this.runtime.ioDevices.video.mirror = false;
+				this.active = true;
+				break;
+			case 'onfront':
+				this.runtime.ioDevices.video.enableVideo('user');
+				this.runtime.ioDevices.video.mirror = true;
+				this.active = true;
+				break;
+			default:
+				this.runtime.ioDevices.video.mirror = !this.runtime.ioDevices.video.mirror;
+		}
+
+	}
+
+	// Fonction permettant de changer la transparence d'affichage de la caméra sur la scène
+	setVideoTransparency(args) {
+		const transparency = Cast.toNumber(args.TRANSPARENCY);
+		this.globalVideoTransparency = transparency;
+		this.runtime.ioDevices.video.setPreviewGhost(transparency);
+	}
+
+	// Fonction permettant de définir la langue de l'extension en fonction de la langue définit dans Scratch.
+	// Si la traduction d'une langue n'est pas disponible dans l'extension, c'est l'anglais qui est choisi
+	setLocale() {
+		let locale = formatMessage.setup().locale;
+		return AvailableLocales.includes(locale) ? locale : 'en';
+	}
+}
+
+module.exports = Scratch3FacemeshBlocks;
\ No newline at end of file
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_handpose/index.js b/node_modules/scratch-vm/src/extensions/scratch3_handpose/index.js
new file mode 100644
index 0000000..883bf9c
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_handpose/index.js
@@ -0,0 +1,471 @@
+// Importation des modules nécessaires pour l'extension Scratch
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const ml5 = require('ml5'); // Bibliothèque ml5 pour utiliser les modèles de machine learning
+const formatMessage = require('format-message'); // Gestion des messages multilingues
+// Icone pour l'extension
+const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDM0NyAzNDciIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM6c2VyaWY9Imh0dHA6Ly93d3cuc2VyaWYuY29tLyIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxLjU7Ij4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsLTE0Mi4zNTMsMTMuMTg1MikiPgogICAgICAgIDxyZWN0IGlkPSJQbGFuLWRlLXRyYXZhaWwxIiBzZXJpZjppZD0iUGxhbiBkZSB0cmF2YWlsMSIgeD0iMTQyLjM1MyIgeT0iLTEzLjE4NSIgd2lkdGg9IjM0Ni4zMDUiIGhlaWdodD0iMzQ2LjMwNSIgc3R5bGU9ImZpbGw6bm9uZTsiLz4KICAgICAgICA8Zz4KICAgICAgICAgICAgPGNsaXBQYXRoIGlkPSJfY2xpcDEiPgogICAgICAgICAgICAgICAgPHJlY3QgeD0iMTQyLjM1MyIgeT0iLTEzLjE4NSIgd2lkdGg9IjM0Ni4zMDUiIGhlaWdodD0iMzQ2LjMwNSIvPgogICAgICAgICAgICA8L2NsaXBQYXRoPgogICAgICAgICAgICA8ZyBjbGlwLXBhdGg9InVybCgjX2NsaXAxKSI+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCg1LjUxODIyLDAsMCwxMC45Mjg1LC01MzkuNjQ1LC0yMTIuNzk5KSI+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgeD0iMTIzLjU5NCIgeT0iMTguMTY5IiB3aWR0aD0iNjYuMzEyIiBoZWlnaHQ9IjMzLjEzNyIgc3R5bGU9ImZpbGw6cmdiKDExNCw0OSwyNDQpOyIvPgogICAgICAgICAgICAgICAgICAgIDxjbGlwUGF0aCBpZD0iX2NsaXAyIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHJlY3QgeD0iMTIzLjU5NCIgeT0iMTguMTY5IiB3aWR0aD0iNjYuMzEyIiBoZWlnaHQ9IjMzLjEzNyIvPgogICAgICAgICAgICAgICAgICAgIDwvY2xpcFBhdGg+CiAgICAgICAgICAgICAgICAgICAgPGcgY2xpcC1wYXRoPSJ1cmwoI19jbGlwMikiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjE4MTIxOCwwLDAsMC4wOTE1MDM5LDEyMy41OSwxOC4yNjU0KSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMC4wMjEsMEwzNDYuMzA1LDBMMzQ2LjMwNSwzNDYuMzA1TDAuMDIxLDM0Ni4zMDVMMC4wMjEsMFpNNzEuNzYxLDE4NC41NzZDNzQuNjExLDE4Mi42OTggNzYuNDkxLDE3OS40NyA3Ni40OTEsMTc1LjgwMkM3Ni40OTEsMTcwLjAwMyA3MS43OSwxNjUuMzAyIDY1Ljk5MSwxNjUuMzAyQzYwLjE5MiwxNjUuMzAyIDU1LjQ5MSwxNzAuMDAzIDU1LjQ5MSwxNzUuODAyQzU1LjQ5MSwxODEuNjAxIDYwLjE5MiwxODYuMzAyIDY1Ljk5MSwxODYuMzAyQzY4LjEyMiwxODYuMzAyIDcwLjEwNSwxODUuNjY3IDcxLjc2MSwxODQuNTc2Wk0yNzcuNDQsMTE0LjY4NkMyNzguNTQ5LDExNS4wODUgMjc5Ljc0NSwxMTUuMzAyIDI4MC45OTEsMTE1LjMwMkMyODYuNzksMTE1LjMwMiAyOTEuNDkxLDExMC42MDEgMjkxLjQ5MSwxMDQuODAyQzI5MS40OTEsOTkuMDAzIDI4Ni43OSw5NC4zMDIgMjgwLjk5MSw5NC4zMDJDMjc1LjE5Miw5NC4zMDIgMjcwLjQ5MSw5OS4wMDMgMjcwLjQ5MSwxMDQuODAyQzI3MC40OTEsMTA5LjM1NSAyNzMuMzg5LDExMy4yMyAyNzcuNDQsMTE0LjY4NlpNMjM1LjAyMiwyNDQuOTQ5QzIzMi44NTYsMjQ2Ljg3MiAyMzEuNDkxLDI0OS42NzggMjMxLjQ5MSwyNTIuODAyQzIzMS40OTEsMjU4LjYwMSAyMzYuMTkyLDI2My4zMDIgMjQxLjk5MSwyNjMuMzAyQzI0Ny43OSwyNjMuMzAyIDI1Mi40OTEsMjU4LjYwMSAyNTIuNDkxLDI1Mi44MDJDMjUyLjQ5MSwyNDcuMDAzIDI0Ny43OSwyNDIuMzAyIDI0MS45OTEsMjQyLjMwMkMyMzkuMzE3LDI0Mi4zMDIgMjM2Ljg3NiwyNDMuMzAyIDIzNS4wMjIsMjQ0Ljk0OVpNMTgwLjk5NiwxNzUuODY5QzE4MS45NDUsMTc2LjE1MSAxODIuOTUxLDE3Ni4zMDIgMTgzLjk5MSwxNzYuMzAyQzE4OS43OSwxNzYuMzAyIDE5NC40OTEsMTcxLjYwMSAxOTQuNDkxLDE2NS44MDJDMTk0LjQ5MSwxNjAuMDAzIDE4OS43OSwxNTUuMzAyIDE4My45OTEsMTU1LjMwMkMxNzguMTkyLDE1NS4zMDIgMTczLjQ5MSwxNjAuMDAzIDE3My40OTEsMTY1LjgwMkMxNzMuNDkxLDE3MC41NiAxNzYuNjU3LDE3NC41OCAxODAuOTk2LDE3NS44NjlaTTE0My42NDcsMTc2LjE3MkMxNDguNjU5LDE3NS4zNzggMTUyLjQ5MSwxNzEuMDM4IDE1Mi40OTEsMTY1LjgwMkMxNTIuNDkxLDE2MC4wMDMgMTQ3Ljc5LDE1NS4zMDIgMTQxLjk5MSwxNTUuMzAyQzEzNi4xOTIsMTU1LjMwMiAxMzEuNDkxLDE2MC4wMDMgMTMxLjQ5MSwxNjUuODAyQzEzMS40OTEsMTcxLjYwMSAxMzYuMTkyLDE3Ni4zMDIgMTQxLjk5MSwxNzYuMzAyQzE0Mi41NTUsMTc2LjMwMiAxNDMuMTA4LDE3Ni4yNTggMTQzLjY0NywxNzYuMTcyWk04Ni42OTQsMjAyLjM5OUM4NC4xNDIsMjA0LjMxNSA4Mi40OTEsMjA3LjM2NiA4Mi40OTEsMjEwLjgwMkM4Mi40OTEsMjE2LjYwMSA4Ny4xOTIsMjIxLjMwMiA5Mi45OTEsMjIxLjMwMkM5NS42MjMsMjIxLjMwMiA5OC4wMjksMjIwLjMzNCA5OS44NzIsMjE4LjczNEMxMDIuMDg5LDIxNi44MDggMTAzLjQ5MSwyMTMuOTY5IDEwMy40OTEsMjEwLjgwMkMxMDMuNDkxLDIwNS4wMDMgOTguNzksMjAwLjMwMiA5Mi45OTEsMjAwLjMwMkM5MC42MjksMjAwLjMwMiA4OC40NDgsMjAxLjA4MiA4Ni42OTQsMjAyLjM5OVpNMTE0LjExLDIzNC44N0MxMTEuODkzLDIzNi43OTYgMTEwLjQ5MSwyMzkuNjM1IDExMC40OTEsMjQyLjgwMkMxMTAuNDkxLDI0OC42MDEgMTE1LjE5MiwyNTMuMzAyIDEyMC45OTEsMjUzLjMwMkMxMjYuNzksMjUzLjMwMiAxMzEuNDkxLDI0OC42MDEgMTMxLjQ5MSwyNDIuODAyQzEzMS40OTEsMjQwLjA3NCAxMzAuNDUxLDIzNy41ODggMTI4Ljc0NCwyMzUuNzIxQzEyNi44MjQsMjMzLjYyIDEyNC4wNjIsMjMyLjMwMiAxMjAuOTkxLDIzMi4zMDJDMTE4LjM1OSwyMzIuMzAyIDExNS45NTMsMjMzLjI3IDExNC4xMSwyMzQuODdaTTE1NC41NDMsMjA2LjE3TDE2My40LDIyOC4xMkwxMzEuNDkxLDI0Mi4zMDJMMjAzLjQ0LDI0OS40OTdMMTk0LjQ5MSwyOTAuMzAyTDIyOC44MDgsMjMzLjY1M0wyMzUuNDkxLDI0Mi4zMDJMMjMyLjA4MywyMjguMjQ1TDI1Ny40OTEsMTg2LjMwMkwyMjUuMzc2LDIwMC41NzZMMjE5LjQ5MSwxNzYuMzAyTDE5Ni44MjksMTkyLjI2OUwxODQuNDkxLDE3Ni4zMDJMMTg2LjE0LDE5OS43OTlMMTgwLjQwNiwyMDMuODRMMTY2LjAyNiwxOTMuMDE2TDE1NC41NDMsMjA2LjE3Wk0xNDcuNDkxLDExNC44MDJDMTQ3LjQ5MSwxMDkuMDAzIDE0Mi43OSwxMDQuMzAyIDEzNi45OTEsMTA0LjMwMkMxMzEuMTkyLDEwNC4zMDIgMTI2LjQ5MSwxMDkuMDAzIDEyNi40OTEsMTE0LjgwMkMxMjYuNDkxLDEyMC42MDEgMTMxLjE5MiwxMjUuMzAyIDEzNi45OTEsMTI1LjMwMkMxNDIuNzksMTI1LjMwMiAxNDcuNDkxLDEyMC42MDEgMTQ3LjQ5MSwxMTQuODAyWk0xOTIuNDkxLDEwOC44MDJDMTkyLjQ5MSwxMDMuMDAzIDE4Ny43OSw5OC4zMDIgMTgxLjk5MSw5OC4zMDJDMTc2LjE5Miw5OC4zMDIgMTcxLjQ5MSwxMDMuMDAzIDE3MS40OTEsMTA4LjgwMkMxNzEuNDkxLDExNC42MDEgMTc2LjE5MiwxMTkuMzAyIDE4MS45OTEsMTE5LjMwMkMxODcuNzksMTE5LjMwMiAxOTIuNDkxLDExNC42MDEgMTkyLjQ5MSwxMDguODAyWk0xNDEuNDkxLDU5LjgwMkMxNDEuNDkxLDU0LjAwMyAxMzYuNzksNDkuMzAyIDEzMC45OTEsNDkuMzAyQzEyNS4xOTIsNDkuMzAyIDEyMC40OTEsNTQuMDAzIDEyMC40OTEsNTkuODAyQzEyMC40OTEsNjUuNjAxIDEyNS4xOTIsNzAuMzAyIDEzMC45OTEsNzAuMzAyQzEzNi43OSw3MC4zMDIgMTQxLjQ5MSw2NS42MDEgMTQxLjQ5MSw1OS44MDJaTTE5Mi40OTEsNDguODAyQzE5Mi40OTEsNDMuMDAzIDE4Ny43OSwzOC4zMDIgMTgxLjk5MSwzOC4zMDJDMTc2LjE5MiwzOC4zMDIgMTcxLjQ5MSw0My4wMDMgMTcxLjQ5MSw0OC44MDJDMTcxLjQ5MSw1NC42MDEgMTc2LjE5Miw1OS4zMDIgMTgxLjk5MSw1OS4zMDJDMTg3Ljc5LDU5LjMwMiAxOTIuNDkxLDU0LjYwMSAxOTIuNDkxLDQ4LjgwMlpNMjcxLjQ5MSwxNzUuODAyQzI3MS40OTEsMTcwLjAwMyAyNjYuNzksMTY1LjMwMiAyNjAuOTkxLDE2NS4zMDJDMjU1LjE5MiwxNjUuMzAyIDI1MC40OTEsMTcwLjAwMyAyNTAuNDkxLDE3NS44MDJDMjUwLjQ5MSwxODEuNjAxIDI1NS4xOTIsMTg2LjMwMiAyNjAuOTkxLDE4Ni4zMDJDMjY2Ljc5LDE4Ni4zMDIgMjcxLjQ5MSwxODEuNjAxIDI3MS40OTEsMTc1LjgwMlpNMjM4LjQ5MSwxMTAuODAyQzIzOC40OTEsMTA1LjAwMyAyMzMuNzksMTAwLjMwMiAyMjcuOTkxLDEwMC4zMDJDMjIyLjE5MiwxMDAuMzAyIDIxNy40OTEsMTA1LjAwMyAyMTcuNDkxLDExMC44MDJDMjE3LjQ5MSwxMTYuNjAxIDIyMi4xOTIsMTIxLjMwMiAyMjcuOTkxLDEyMS4zMDJDMjMzLjc5LDEyMS4zMDIgMjM4LjQ5MSwxMTYuNjAxIDIzOC40OTEsMTEwLjgwMlpNMjAyLjQ5MSwzMDAuODAyQzIwMi40OTEsMjk1LjAwMyAxOTcuNzksMjkwLjMwMiAxOTEuOTkxLDI5MC4zMDJDMTg2LjE5MiwyOTAuMzAyIDE4MS40OTEsMjk1LjAwMyAxODEuNDkxLDMwMC44MDJDMTgxLjQ5MSwzMDYuNjAxIDE4Ni4xOTIsMzExLjMwMiAxOTEuOTkxLDMxMS4zMDJDMTk3Ljc5LDMxMS4zMDIgMjAyLjQ5MSwzMDYuNjAxIDIwMi40OTEsMzAwLjgwMlpNMjMxLjQ5MSwxNjUuODAyQzIzMS40OTEsMTYwLjAwMyAyMjYuNzksMTU1LjMwMiAyMjAuOTkxLDE1NS4zMDJDMjE1LjE5MiwxNTUuMzAyIDIxMC40OTEsMTYwLjAwMyAyMTAuNDkxLDE2NS44MDJDMjEwLjQ5MSwxNzEuNjAxIDIxNS4xOTIsMTc2LjMwMiAyMjAuOTkxLDE3Ni4zMDJDMjI2Ljc5LDE3Ni4zMDIgMjMxLjQ5MSwxNzEuNjAxIDIzMS40OTEsMTY1LjgwMlpNMjgxLjQ5MSwxMzkuODAyQzI4MS40OTEsMTM0LjAwMyAyNzYuNzksMTI5LjMwMiAyNzAuOTkxLDEyOS4zMDJDMjY1LjE5MiwxMjkuMzAyIDI2MC40OTEsMTM0LjAwMyAyNjAuNDkxLDEzOS44MDJDMjYwLjQ5MSwxNDUuNjAxIDI2NS4xOTIsMTUwLjMwMiAyNzAuOTkxLDE1MC4zMDJDMjc2Ljc5LDE1MC4zMDIgMjgxLjQ5MSwxNDUuNjAxIDI4MS40OTEsMTM5LjgwMlpNMjQ1LjQ5MSw2NC44MDJDMjQ1LjQ5MSw1OS4wMDMgMjQwLjc5LDU0LjMwMiAyMzQuOTkxLDU0LjMwMkMyMjkuMTkyLDU0LjMwMiAyMjQuNDkxLDU5LjAwMyAyMjQuNDkxLDY0LjgwMkMyMjQuNDkxLDcwLjYwMSAyMjkuMTkyLDc1LjMwMiAyMzQuOTkxLDc1LjMwMkMyNDAuNzksNzUuMzAyIDI0NS40OTEsNzAuNjAxIDI0NS40OTEsNjQuODAyWiIgc3R5bGU9ImZpbGw6cmdiKDE0Niw0MCwyMDApOyIvPgogICAgICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMTgxMjE4LDAsMCwwLjA5MTUwMzksMTIzLjU5LDE4LjI2NTQpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IHg9IjAuMDIxIiB5PSItMS4wNTQiIHdpZHRoPSIzNjUuOTI0IiBoZWlnaHQ9IjM2Mi4xMzgiIHN0eWxlPSJmaWxsOnJnYigxMTQsNDksMjQ0KTsiLz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8cmVjdCB4PSIxMjMuNTk0IiB5PSIxOC4xNjkiIHdpZHRoPSI2Ni4zMTIiIGhlaWdodD0iMzMuMTM3IiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTpyZ2IoMTMsMTg5LDE0MCk7c3Ryb2tlLXdpZHRoOjAuMTJweDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJfSW1hZ2UyXyIgc2VyaWY6aWQ9Il9JbWFnZTIiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTkyLjE2MywxOC40KSI+CiAgICAgICAgICAgICAgICAgICAgPGNsaXBQYXRoIGlkPSJfY2xpcDMiPgogICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMjUwIiBoZWlnaHQ9IjI4NSIvPgogICAgICAgICAgICAgICAgICAgIDwvY2xpcFBhdGg+CiAgICAgICAgICAgICAgICAgICAgPGcgY2xpcC1wYXRoPSJ1cmwoI19jbGlwMykiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLC0wLC0wLDEsLTQ5LjgxLC0zMS41ODUyKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNfSW1hZ2U0IiB4PSI0OS44MSIgeT0iMzEuNTg1IiB3aWR0aD0iMjUwcHgiIGhlaWdodD0iMjg1cHgiLz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJMaWduZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5OCwxOTZMMjE1LDIxNCIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjRweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgxIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE1Ljg0NDIsLTIyLjg4MzIpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjI2LDIyOEwyNDEsMjQ1IiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDExIiBzZXJpZjppZD0icGF0aDEiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsLTEzLjAxMTMsLTU3Ljg4NDQpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjI2LDIyOEwyNDEsMjQ1IiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDIiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNjgsMTY1TDI2NCwxMzUiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI2MSwxMTRMMjU4LDgwIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDQiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMDgsNjlMMzA4LDEwOCIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjRweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGg1IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE1Ljg0NDIsLTIyLjg4MzIpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzA4LDEyOUwzMDksMTY1IiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDYiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNTUsMTMxTDM1MSwxNjUiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoNyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTM1NSwxMTBMMzU4LDg1IiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NHB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0icGF0aDgiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik00MDQsMTI0TDQwMiwxMzkiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoOSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTM5NywxNjBMMzkyLDE3NSIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjRweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgxMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI1MywyNjJMMzA4LDMwNSIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjRweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9InBhdGgxMTEiIHNlcmlmOmlkPSJwYXRoMTEiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMjksMzA1TDM2MiwyNzMiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTIiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNzIsMjUyTDM4NywxOTYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTMiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNjksMTg2TDMxNSwzMDAiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTQiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMTksMzAwTDMxMSwxODYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMjEsMzAwTDM0NiwxODYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTYiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zMjEsMzAwTDM4NCwxOTYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTciIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNjIsMjUyTDM0NiwxODYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTgiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNjIsMjUyTDMxMSwxODYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMTkiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNjIsMjU1TDI2OSwxODUiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjAiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNTgsMjYyTDI1OCwyNTIiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjEiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNTMsMjQzTDI2OCwxODYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjIiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNTMsMjQ4TDMwOCwxODUiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjMiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNTgsMjQ4TDM0NiwxODYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJwYXRoMjQiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNTgsMjUyTDM4NCwxOTYiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE1Ljg0NDIsLTIyLjg4MzIpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjY4LDY5LjVDMjY4LDYzLjcwMSAyNjMuMjk5LDU5IDI1Ny41LDU5QzI1MS43MDEsNTkgMjQ3LDYzLjcwMSAyNDcsNjkuNUMyNDcsNzUuMjk5IDI1MS43MDEsODAgMjU3LjUsODBDMjYzLjI5OSw4MCAyNjgsNzUuMjk5IDI2OCw2OS41WiIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjZweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IkVsbGlwc2UtY29waWUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNzQsMTI0LjVDMjc0LDExOC43MDEgMjY5LjI5OSwxMTQgMjYzLjUsMTE0QzI1Ny43MDEsMTE0IDI1MywxMTguNzAxIDI1MywxMjQuNUMyNTMsMTMwLjI5OSAyNTcuNzAxLDEzNSAyNjMuNSwxMzVDMjY5LjI5OSwxMzUgMjc0LDEzMC4yOTkgMjc0LDEyNC41WiIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjZweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IkVsbGlwc2UtY29waWUtMiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI3OSwxNzUuNUMyNzksMTY5LjcwMSAyNzQuMjk5LDE2NSAyNjguNSwxNjVDMjYyLjcwMSwxNjUgMjU4LDE2OS43MDEgMjU4LDE3NS41QzI1OCwxODEuMjk5IDI2Mi43MDEsMTg2IDI2OC41LDE4NkMyNzQuMjk5LDE4NiAyNzksMTgxLjI5OSAyNzksMTc1LjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0zIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE1Ljg0NDIsLTIyLjg4MzIpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzE5LDU4LjVDMzE5LDUyLjcwMSAzMTQuMjk5LDQ4IDMwOC41LDQ4QzMwMi43MDEsNDggMjk4LDUyLjcwMSAyOTgsNTguNUMyOTgsNjQuMjk5IDMwMi43MDEsNjkgMzA4LjUsNjlDMzE0LjI5OSw2OSAzMTksNjQuMjk5IDMxOSw1OC41WiIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjZweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IkVsbGlwc2UtY29waWUtNCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMxOSwxMTguNUMzMTksMTEyLjcwMSAzMTQuMjk5LDEwOCAzMDguNSwxMDhDMzAyLjcwMSwxMDggMjk4LDExMi43MDEgMjk4LDExOC41QzI5OCwxMjQuMjk5IDMwMi43MDEsMTI5IDMwOC41LDEyOUMzMTQuMjk5LDEyOSAzMTksMTI0LjI5OSAzMTksMTE4LjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS01IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE1Ljg0NDIsLTIyLjg4MzIpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzIxLDE3NS41QzMyMSwxNjkuNzAxIDMxNi4yOTksMTY1IDMxMC41LDE2NUMzMDQuNzAxLDE2NSAzMDAsMTY5LjcwMSAzMDAsMTc1LjVDMzAwLDE4MS4yOTkgMzA0LjcwMSwxODYgMzEwLjUsMTg2QzMxNi4yOTksMTg2IDMyMSwxODEuMjk5IDMyMSwxNzUuNVoiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo2cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTYiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNzIsNzQuNUMzNzIsNjguNzAxIDM2Ny4yOTksNjQgMzYxLjUsNjRDMzU1LjcwMSw2NCAzNTEsNjguNzAxIDM1MSw3NC41QzM1MSw4MC4yOTkgMzU1LjcwMSw4NSAzNjEuNSw4NUMzNjcuMjk5LDg1IDM3Miw4MC4yOTkgMzcyLDc0LjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS03IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE1Ljg0NDIsLTIyLjg4MzIpIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzY1LDEyMC41QzM2NSwxMTQuNzAxIDM2MC4yOTksMTEwIDM1NC41LDExMEMzNDguNzAxLDExMCAzNDQsMTE0LjcwMSAzNDQsMTIwLjVDMzQ0LDEyNi4yOTkgMzQ4LjcwMSwxMzEgMzU0LjUsMTMxQzM2MC4yOTksMTMxIDM2NSwxMjYuMjk5IDM2NSwxMjAuNVoiIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOndoaXRlO3N0cm9rZS13aWR0aDo2cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJFbGxpcHNlLWNvcGllLTgiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTUuODQ0MiwtMjIuODgzMikiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNTgsMTc1LjVDMzU4LDE2OS43MDEgMzUzLjI5OSwxNjUgMzQ3LjUsMTY1QzM0MS43MDEsMTY1IDMzNywxNjkuNzAxIDMzNywxNzUuNUMzMzcsMTgxLjI5OSAzNDEuNzAxLDE4NiAzNDcuNSwxODZDMzUzLjI5OSwxODYgMzU4LDE4MS4yOTkgMzU4LDE3NS41WiIgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjZweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IkVsbGlwc2UtY29waWUtOSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQxOCwxMTQuNUM0MTgsMTA4LjcwMSA0MTMuMjk5LDEwNCA0MDcuNSwxMDRDNDAxLjcwMSwxMDQgMzk3LDEwOC43MDEgMzk3LDExNC41QzM5NywxMjAuMjk5IDQwMS43MDEsMTI1IDQwNy41LDEyNUM0MTMuMjk5LDEyNSA0MTgsMTIwLjI5OSA0MTgsMTE0LjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0xMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQwOCwxNDkuNUM0MDgsMTQzLjcwMSA0MDMuMjk5LDEzOSAzOTcuNSwxMzlDMzkxLjcwMSwxMzkgMzg3LDE0My43MDEgMzg3LDE0OS41QzM4NywxNTUuMjk5IDM5MS43MDEsMTYwIDM5Ny41LDE2MEM0MDMuMjk5LDE2MCA0MDgsMTU1LjI5OSA0MDgsMTQ5LjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0xMSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTM5OCwxODUuNUMzOTgsMTc5LjcwMSAzOTMuMjk5LDE3NSAzODcuNSwxNzVDMzgxLjcwMSwxNzUgMzc3LDE3OS43MDEgMzc3LDE4NS41QzM3NywxOTEuMjk5IDM4MS43MDEsMTk2IDM4Ny41LDE5NkMzOTMuMjk5LDE5NiAzOTgsMTkxLjI5OSAzOTgsMTg1LjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0xMiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIwMywxODUuNUMyMDMsMTc5LjcwMSAxOTguMjk5LDE3NSAxOTIuNSwxNzVDMTg2LjcwMSwxNzUgMTgyLDE3OS43MDEgMTgyLDE4NS41QzE4MiwxOTEuMjk5IDE4Ni43MDEsMTk2IDE5Mi41LDE5NkMxOTguMjk5LDE5NiAyMDMsMTkxLjI5OSAyMDMsMTg1LjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0xMyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIzMCwyMjAuNUMyMzAsMjE0LjcwMSAyMjUuMjk5LDIxMCAyMTkuNSwyMTBDMjEzLjcwMSwyMTAgMjA5LDIxNC43MDEgMjA5LDIyMC41QzIwOSwyMjYuMjk5IDIxMy43MDEsMjMxIDIxOS41LDIzMUMyMjUuMjk5LDIzMSAyMzAsMjI2LjI5OSAyMzAsMjIwLjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0xNCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI1OCwyNTIuNUMyNTgsMjQ2LjcwMSAyNTMuMjk5LDI0MiAyNDcuNSwyNDJDMjQxLjcwMSwyNDIgMjM3LDI0Ni43MDEgMjM3LDI1Mi41QzIzNywyNTguMjk5IDI0MS43MDEsMjYzIDI0Ny41LDI2M0MyNTMuMjk5LDI2MyAyNTgsMjU4LjI5OSAyNTgsMjUyLjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0xNSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTMyOSwzMTAuNUMzMjksMzA0LjcwMSAzMjQuMjk5LDMwMCAzMTguNSwzMDBDMzEyLjcwMSwzMDAgMzA4LDMwNC43MDEgMzA4LDMxMC41QzMwOCwzMTYuMjk5IDMxMi43MDEsMzIxIDMxOC41LDMyMUMzMjQuMjk5LDMyMSAzMjksMzE2LjI5OSAzMjksMzEwLjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iRWxsaXBzZS1jb3BpZS0xNiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNS44NDQyLC0yMi44ODMyKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTM3OSwyNjIuNUMzNzksMjU2LjcwMSAzNzQuMjk5LDI1MiAzNjguNSwyNTJDMzYyLjcwMSwyNTIgMzU4LDI1Ni43MDEgMzU4LDI2Mi41QzM1OCwyNjguMjk5IDM2Mi43MDEsMjczIDM2OC41LDI3M0MzNzQuMjk5LDI3MyAzNzksMjY4LjI5OSAzNzksMjYyLjVaIiBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTp3aGl0ZTtzdHJva2Utd2lkdGg6NnB4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZGVmcz4KICAgICAgICA8aW1hZ2UgaWQ9Il9JbWFnZTQiIHdpZHRoPSIyNTBweCIgaGVpZ2h0PSIyODVweCIgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFQb0FBQUVkQ0FZQUFBQWwybnF6QUFBQUNYQklXWE1BQUE3RUFBQU94QUdWS3c0YkFBQWdBRWxFUVZSNG5PMmRlWFJzV1YzdlArZFVWVkpWbVpON2s5eWhBV2xwQmh0YXBHbHBIRkNhNmRrTzhCNnVoVDdVcHk1RnQvaEViWjlLMDdUUUNBZzBhTFBjQ1BJRWg4WUh0cXpYYWkrUTU3REVBZG9Xb1JFQnNYTzc3NzI1eWIycERGV1phenp2anpvN2ZWSTNsZFI4OXFuOFBtdGwzU1MzNnB5ZHBMNzFHL2J2OTlzT3dyRkNhNTBDYmdLZUFGeFQ4d0dRcWZtNEFIeEtLYlhZKzlVS25jSUpld0ZDNzlCYTN3TGNDWnh1NGVrUEFYOEdmRUlwbGUzb3dvU3VJMEkvQm1pdFR3TnZCRjRFa00vbjJkblpvVkFvVUN3V0tSYUxGQW9GQU9MeE9MRllqSGc4VGp3ZUo1VktNVHc4ak91NjVuSmw0SytCdHl1bExvVHc0d2d0SUVMdlk3VFdMdkJqd004QnFYSzVUQ2FUSVp2TjRubGV3OWR4WFplUmtSRkdSMGNaR2hyQ2NSeUFYZUE5d0llVlV1VnVyRi9vSENMMFBrVnI3VkIxMDE4TnNMNit6cFVyVnlpVlNtMWROeDZQTXowOXpkalltUG5XdndHL3FwVDZhbHNYRnJxS2UvUkRoSWp5V3VEVmxVcUYrZmw1TGwyNjFMYklBVXFsRWdzTEMxeThlSkZpc1Fqd1RPQityZldQdEgxeG9XdUlSZTlEdE5ZL0NMelo4end1WGJyRXhzWkdWKzdqdWk3VDA5Tk1URXhBTlhhL1ZTbjFTRmR1SnJTRldQUStRMnY5WXVCTkFKY3ZYKzZheUFFcWxRcVhMMTltYlcwTklBYTgwUThaQk1zUW9mY1JXdXM0Y0FmZ21LUmJMOGhrTWlZc2VEN3cwcDdjVkdnS0VYcC84ZDNBNlh3K3ovTHljczl1V2k2WGcvZjc0WjdkV0dnWUVYcWY0RytsdlFaZ2RYVzE1L2ZQNVhKVUtoV0FtN1RXWjN1K0FPRlFST2o5dzNjQVR5bVZTdVJ5dVo3ZnZGS3BzTDI5YmI1OFpzOFhJQnlLQ0wxLytCR29Xdk5taW1FNlNibThWemN6RU1vQ2hMckV3MTVBMVBDenlsOEgzQXpNQXFPQmp6aXdUTFVaWk1uL3VBaDhVU25WTmZYNWE3b0JDTVdhR3dKdk1JblFGaUVjaUFpOUFYd2hmVHZ3RXVEYmFMNHA1Qkd0OVllQSs1VlN1NTFlSDNBU0dDNlh5MEdyR2lZaWRNc1FvUitCMXZxWndPdUI1NXJ2bGN0bHRyYTJ5T2Z6bE10bEtwWEtuc0NDRFNIeGVKeDBPazA4SHY5NjROZUIyN1RXSHdZK29KUXFkbkNaVHdZb0ZBcWh1ZTFnajBYWFdvOVIzZGN2QUVXZ3FKU3FoTG1tc0JHaDEwRnJQVXAxVC9vVlVDMzlYRnRiWTNOems5M2R4bzJ5NHppTWpvNHlPVGxKTXBtY0FINGV1RVZyL2JvT2RuOWRDOVd1dERBSlMraGE2K3VBRjFBTlg1N0YxUjZYcDdYK0d2QjU0Ri85ZngvclpqaGxHeUwwQTlCYWp3TWZCcTZ2VkNxc3JhMnhzckxTa2x2c2VSNjVYSTcxOVhYUzZUU25UcDBpa1VnOEMvZ0xyZlVkU3FuN083RGtZeWwwcmZYMVZHdjZYeFQ4ZnFWU3dmTThITWN4SHc3d1ZQL2pWZjdESHROYWZ4VDR1RkpxcFJmckRSTVJlZzFhNnduZ0Q0Q25Gd29GTGw2OHVOZXIzUTZlNTdHMXRjV2pqejdLN093c282T2phZUJ1cmZXd1V1cmVOaTkvRXVoSTAwbzdCSVRlMWF5NzF2b0U4RmJnaFZBVjl2cjZPanM3TzN0OTlzRVF4blZka3Nra3lXU1NkRHBOS3BVaUhvOC9DZmhsNEJlMTFwOEM3bFZLUGRqTmRZZUpiSzhGMEZvbmdUL0VGL241OCtjN0l2SWc1WEtaaFlVRkxsKytiTDUxcDliNmhXMWVOZytZUHZIUTZJVkYxMW8vSGZnNDhNSktwY0xLeWdwemMzTXNMaTZTeldiSjUvTlg1U25NSHYvcTZpcno4L004OHNnalhMeDRrWTJORFR6UGl3UGZCZHlydFZiZFduZllpTkQzbzRDbkdaRjN5MEo2bnNmYTJocVpUQWFxZjRQZjBsby9xNDFMSGd1aGE2MWZCSHdNT0wyenM4UGMzQnhMUzB0Ti81MDh6Mk56YzVQNStYbm01dVpZWGw0MmEvOEZyZldQZG1IcG9TTkM5OUZhWHd2OEpNREN3a0pQM09DVmxSV3o3NTBDN3RGYUQ3WjRxVHdRSFBjVUN0MFV1dGI2QmNEN2dGUXVsK1BDaFFzZCtSc1ZpMFV5bVV6UXc3cGRhLzBEYlYvWU1rVG83TzJUM3dYRXM5a3NPenM3UGJtdjUza3NMaTZhSk5wWjRJZGF2TlF1OUs5RjExby9rZXJZS21kbFpZWEZ4VVZUVjk4eHN0bHNVT3h2MWxxL3ZLTTNDQmtSZXBXYmdadEtwUkpMUzBzOXZiSG5lY0Y3S2ovajN5eDk2N3BycmRQQTd3Q2pHeHNiTEMwdGRhMVdZRzF0emZ3dEhPQWRXdXVYZGVWR0lTQkNyL0lLcUw2cmgxRlp0clcxeGRiV0ZsVExhSCttaFV2WTVycDNNdXQrRi9DVVFxSEF3c0pDQnk5N01Dc3JLNmJsMWdYZXJiVSswL1diOW9CakwzVC9RSU9YUW5oMTRwN25tY1FjK0Z0R1RkS1hGbDFyZlNQd2ZXYnVYYWZkOVhvc0x5K3p2cjRPMVRlczEvWGtwbDNtMkFzZGVER1FOdnV2WVJFb2RwbHVZUnpUTGxobDBkc1d1dDlmLzZ0UTdjanJaVEdRZWVQMWY1NlgrMXQ2a1VhRURyZEN1RjFmVUgxeCtSWXJCUXczK1hRckxIcUFUbGowVzRFYlNxVVNLeXU5TDF3ckZBcG1GcDREM05iekJYUVlFYm8vSk1HUGtVUEQ4N3pnZHRGMGswKzNJdXNlY0szYkVycldPb0V2cmt3bTB6T1h2WlpBMmZNTHROYlBDMlVSSGVKWUM5MHZwWnl1VkNxaHV1MEdmMDQ2d0V5VFQ3VWlHUmVnM1dUY000QXpoVUloVkUrclZDb0Z4M0w5cnloUHVMWG1sUkVTVHdPYTZrYnJKZ0dMM3BMUSs4V2lVejNwbGQzZDNWRGJicUdhSC9EL0xzOENiZ3gxTVcxdzNJWCtEQWkvNjhzUTJOcUxwTkFEdEN2MGEyQ2ZoeE1hTmQ1ZVpBZHFISGVoWHdmMldQVEFDN3ZaR04wSzE3MkRGdDBhb1VQMXZEbWZ6R0dQczVuakx2UWkyR01KbzU2TUM5QnUrN05WUW8vRll1WlRFWHBFV1lKOWY4aFFhVGRHdDhpaXQ1dU1Pd3RZa1NCMVhkZThQa3JBZXNqTGFSa1JPdnRjczFCcHczVzN6YUszN0xyN3gwcWQ5anpQQ29zZU1BTExVWjQ3ZDl5RnZnejJDRDJZalBNcnd4ckZpbVJjaHlyalRnRnVxVlFLUGVNTy9SR2Znd2g5Q1NDUnNDT1pHcGdtR3dlYTZXTHJKNkUvQWV5SnowWG8vVUVHN0luUm9lVTR2UURWZURKTXNYZEk2TmJFNTdCUDZMMDd0YklMSEhlaDc3bnVZVnREUXl1WmQ2VlVtV3F5S0ZRNkpIVEp1SGVCWXkxMC85U1VEY2R4UXM5WUc5cmRZZ3Y3NS9ERkh0TmF0K29tV1NWMGNkMzdCMXN6NzVHcmpxdEpuclg2QzdWVjZPSzZSeHlyTXU5dFdQUVM5RVZDN2dsZ1pZd3VGajNpV0dYUkEwS2ZiZktwNGU5RjBaN1F0ZGJEd0hqd0xMdXdFYUgzRHhtd1V1ak5XdlRJQzUyQTIyN0RIanFJMFBzSkVYb0hhWE5BNUZtd0p6NVBKQkltRkZwUlN2Vm1CbmlYRUtIYjY3cWZhREp6N1VIa1kzU3JFbkdCUXFyNU1OZlJDVVRvZmpMT2xxS1p3RWdwRjVocTVxbm0rV0hTQ2FIYmtvZ1RvZmNYVnBYQlFsdGRiR0xSTzRnSXZiL29sekpZMjJMMGZyTG9sOEpjUnljUW9VTU9LTVZpc2RDcnlnekhVZWorNEVYcmtuRStZdEdqamxMS3c3TE1lNHQ5NmJZSnZkbXMrMGxnc0Z3dWh6YmV1WmFCZ2IwZlFTeDZuMkRycEpsbWhGNkJTTWZvVnNYbmp1TUUzL2hGNkgxQ0J1eEp5TFU0RGRZMmk5N3NMOU82OWxUL1RUUGpOejlGR2hGNkZhc1NjbjNpdWpjcmRLc0dUdlJUSWc1RTZBYXJZdlEyNnQxRHAxOHNlajhsNHFEOXNiejlnblZDOXp3UHgzSEd0ZFlEU3FsR1h2MjJXZlJtazNHMld2U3VDdDJ2Zm53cThNM0FVNEJScW9kc3BvRlZZTUgvT0FkOFZpbTEzY3A5N0hobGg0OVZaYkJRRmJ2L1lwdW1zUmViRlNXd0FjU2lINExXK2h1Qi93RzhBQmhwOEdrbHJmVkR3S2VCUDFkS1hXNzBmdmE4c3NQRnFwNTBhRjNvVVN5QjFWb1BBTE0xSjhxR1NtQnJyV05DOTJzRlhnejhCUEJzOC8xaXNjajI5alk3T3p1WTdjVktwVUk4SGljZWo1TklKRWlsVWlTVHliampPRGNETndPM2FhMC9BWHhJS2ZYd1VmZTI1NVVkTGxaYWRKOUdFM0pXV1BRV1kvVFRnR1BMaUdlZzQxdHJXdXRaNEM3Z082RzZzNUxOWnNsbXN3MTdNYkZZaktHaElVWkdSaGdaR1lrNWp2UGR3SGRycmY4RmVOMWhGdDZlVjNhNDdEVzJPSTVqeFl1dGhlcTQ4QmROeTBLM2JnODk0TG92dEhNdDM0cS9FcmdkR0M2WHkyUXlHWEs1WE5PRlFlVnltZlgxZGRiWDEwa2tFa3hNVERBK1BrNHNGcnNSZUwvVytsWDEybWtsNnc0b3BZcEExbkVjYTdiWVdyWG9ZZE9PMEcySnp3Tjc2RXRLcVphUDJ2VVRiWGNDYndPR056WTJPSGZ1SEd0cmEyMVgveFdMUlphV2xwaWJtek52a044QXZMUGV3UjhpOU1leHluMlA2aFpiaTFsM3F5eDZKeEp4V3VzazhGN2cxWlZLaFlXRkJTNWR1dFR4SEVTNVhPYml4WXVteU9wbHdNOGU5RGdSK3VOWXRjWFdRdEdNV1BRTzBhN1EvZlBqUGd5OHhBZ3hsOHQxTFNUTTUvTXNMQ3lZNjc5V2EzMTk3V05FNkk5amxkQ1BXVExPS292ZWdXYVdid2R1TEpWS25EOS9udTN0bHJhK20ySnpjNU8xdFRVQUI3akR6dzNzSVVKL0hLdktZRnROeG9XZFNBemN2NWxmcEZWQ0Q3elp0K3E2M3dLd3RyWkdQdDl5aU44MHk4dkw1blh6SE9DN2d2OG5RbjhjcXliTlZDb1ZJNXBoclhXNmdhZlk4UTcxT0EydFIyczlCb3phTk9LNW5UcDNQeG4yblZDMXNyM0VaUFI5ZnNXdlR3QkU2RUZzblIwSGpibnZBK1o1WWRLQ1JkOGJOaEgyMmcxdEZzdGNEMHdYaThXZVduTkRMcGN6OXowRnZOQjhYNFQrT0ZabDNhSHA0NW1zRUhxQVJvVnVWU0l1MElmdTBkb2UrZ3VoYXMzRCtGdDRua2MybXpWZnZzSjhJa0ovSEN2TFlIMGFFWG9Dd2hkNkN4YmR1dmc4c0lmZXlydlBMZEI3dHozSSt2cTYrVHQ4aDlaNkFrVG9RYXl6NkUyNjdyWUp2ZEZmcEZWejR0cHgyN1hXWjRDblZ5b1Z0cmEyT3JxdVppaVZTdWIrTWZ5a25BajljVGFCWGRkMW96b2tNcXF1dTFXSEtyWTVjR0l2Q1JmMjMyRmpZOE44ZWlPSTBQZndoMFJhNWI1SDNLSTNuWXl6Z1lEUUw3VHc5QmRCdUc2N1lYZDNiL3JWTTBDRVhvdFY3bnVUMVhHUnMraitWcFN0UXIvWXpQUDhrMkNmNTNsZXFHNjdvVkFvbU5mQzEybXRreUwwL2RoYUhYZW82KzQzVDdnMmlMeEppejROSkVxbGtvMGpucHUxNk44S3hIZDJkcXpvcWE5VUtpWWNjb0duaU5EM1k2M1FhMHNhYTlpejVqYUkzYWNSb1Z1VmNZZTJYUGZRcysyMUJONDh4MFRvKzdGSzZHYlNDREJJZFpaWVBld281Nk5waTI3VkhycnJ1dVp2bjZlSjg5QjlqeXFVYXJoNnVLNUxNcGtFS0FOZkVLSHZ4Nm9ZSFJwT3lDVUFhOXhmbjBaK2lWWlo5T0RXbWxLcW1WL21Od0hqaFVMQm1qZXRkRHB0NmdHK3BKVGFGS0h2eDZxc096UWNwemM3Y2JWcnRHTFJiUkY2d0cwLzMrUlRRNjJHTzRoMGVxODk0ak1nV2ZkYXJMUG9EV2JlcmJIb1VYYmRXODI0WTJGOEhoRDZaMEdFWG90VnJhclFzT3R1emRaYWxDMTZLeGwzcmZYWEFVOHVsOHM5NlR0dmhGZ3NadUx6RXZBNUVLSFhzZ0o0Wmtpa0RUUTRVc3FhWkZ5QVE0WHVqMXFhdG5URWN6TVczVXEzM1gvOWZzRU1peFNoQjFCS2xZR1ZDQTZKaktKRlB3TjJ0YWUydUxWbXM5ditHZk9KQ1AxcXJOcGlheVlaWjBPTUh1QW9vVnZsdHRlTWVHNm9vVVZyUFE0OHg1WnFPTVBRMEpENTlMUG1FeEg2MVZoMWhISXoyMnMyMElSRnQwcm9OZTJwalI2VC9BSWd0cjI5YmMxMG5IZzh6dURnSUZSckFiNWd2aTlDdnhxckVuSkJvZGViMlkyZEZ2MG9sOGlxakhzZ1BtOW1hODFtdC8xZmd6UHBSZWhYWTVYckhwaWxGZ01tNmp6TWlzNjFtalVjOWRxeXlxSTN1N1dtdFU1UXRlaTJDdjJ6d2UrTDBLOG1pbnZwMWlUakFoejFDN1NxYTYyRnJiV2JnS0Y4UG0rTlZ3SUhKK0pBaEg0UVZsbDBhR2lMelVhTFhqZjI4UnQwYkIwNDBlalcyaTJ3YjhCRDZBVGk4eDNnaThIL0U2RmZqYzFDdDk2aU41aU1Hd09HQWswN29kTk1qTzYvVWUzdG45dENJTnYra0ZKcVgzR0NDUDFxYkJaNnZTMjJJYkF1R1hlWTBQZXN1UTF2VHRDMFJiOE9PRnNxbGRqWk9mRHcwbENvRjUrRENQMGc5b1J1WVhWY1BZcytBbllJdlVHTGJsVjhIb3ZGekM3TE5yRGF3Rk9zUzhKQi9mZ2NST2hYb1pUYUJyWWR4N0Z4U0dROW9RK0RIVUlQY0tSRnQwWG93VVNjUHp2d0tKNExXRlBiRGxXUHhQODVOb0F2MS82L0hhOWsrN0FxODk3QVFRN1dDTDNCY2M5bndjcEUzSkVaZDMvSWhIVkNEMWp6aC94UzduMkkwQS9HcWppOTBSamRodXFzQnZmUm83eUgvbFJndUZBb1dMTisySmVJdThwdEJ4RjZQYXdTZXJsY05nS2E4cy9lcnNVYWl4N0FPYVNTenlxaE43bUhmaE5nVlJMT2NaeERFM0VnUXErSFZhNjc1M25HV2p2QWlRTWVZcFhRRDdQcXZ1dTcxN2xtQTAwSzNUcTNQWkZJR0s4a0MvekhRWThSb1I5TTFFWktXU1gwQUFmOUFtZUJtRTBqbmh1TjBmMzk4NXZBTHFFSHJYbTlXWGNpOUlOWkFuc2FXK0RJTWxpcmhIN0VGcHRWelN5QjAxTXJISDE2NnJYQVJLbFVzc1liZ2FQamN4Q2gxOE9xR0IzMkpkcnFDdDJHWkJ3MEpuUmJoSkpJSkV5OXhJSlM2cWhGN1Zseld3cDlHb25QUVlSZUQrdUVYbStMelhjbnJiTG9BYXkzNkUyT2o3SXVQaDhZR0RDdjB3eHdydDdqUk9nSFk1M1FENG5SazBDc1VxbFlZMldPc09oV1ZjWDFXWHhlOXdVZ1FqK1lOYUJzNlpESVdxSGJhczNoWUtIYldoVjNsRVUvQzh5VXkyWHkrZndSRCswZGpianRJRUkvRUQ5enVRTDJXUFZEeW1DdEUvb1IxWEhXeGVnK1IzV3RmVFBZWmMyaHNVUWNpTkFQdzZxOTlJZ0tmZC9yUzJ1ZEFxWTh6N05SNkVkWmRPdmk4MlF5YVhhR0ZqbGkvU0wwK2xnbmRGOUE0MXJyd2NCL1daVnhyNkgybDJlVk5YY2NwNWxpR1p2ajg4OGMxWXdqUXErUHpVVXpKd1BmdHE0WC9aREtPS3VhV1dLeG1PbFF6Q21sMXVzOVRtczlDMXhUcVZTc2lzOFBHdXRjRHhGNmZheXk2RkIzcEpSMXJudUEybCtlVlltNEpycldJcnQvYmhDaDE4Zm1MYlpnbkc2ZDBBL1pYclBLb2plUmNiY3VQaDhjSERUZXlBV2wxRkVWZlNMMFE3Qlo2TUV0TnV1RUhxQlc2RThBYkR4ckxYTHhlVE51TzRqUUQ4T3FneHlnYnIyN2RVS1Bpa1Z2eEhYWFdrOEIxMVlxRlhaM0d6M0FwZnNjTmpicUlFVG85Ykhab2dlRlBnTFdadDMzaE81WGxsbVZkVzh3UnI4UnF2M25Oc1hucVZUS2ZQbGdJODhSb2RmSFpxRmI3YnJYc2VpVFFLcGNMbHZ6cHRSZ2pHN2RvSW5BL3ZtY1VtcXBrZWVJME92Z24xdTFIb0VqbE8xNUo3cWE0TnF1Qlh1c3VldTY1azI4QkZ3KzVLRTNBZGFmbG5vVUl2VERzZlZrMWVEMldoYXdabUl0MU4xSHZ4N3NzWXpCSTVJUEdxWUlvTFVlQlo3bWVWNms0M01Rb1IrRlZRbTV3TWttYWEyMWVWc2ZBR3VGSHJUbzF3UFdDS2JCalB0ekFHZG5aOGVhME1oMTNhYmpjN0RiN2JNQnE0cG1QTStqVkNxWkYrbU1iM0ZlQm5ZZEpuQ1lSYmRGNkEzV3VEOFg3UEZDQUZLcGxIbFQvNnBTYXEzUjU5bGpCdXpFNWpMWVB3SHVBMGEydHJhc0tzMGNHUmt4bjM0bmdOYjY2Y0NUYlNvaGJmQ3NOZXM2MWxweDIwR0VmaFJXV1hUWVp4SEhLcFVLS3lzcnpNL1BoN21rdy9nQnYyUHREb0JzTm12TkZ0VlJGdDFmOS9XZTU5a3E5SVlUY1NDdSsxRll0OFcydExSRUxwZWpYQzRITzlxczR0eTVjeno1eVU4MlgvNHBjRjJwVkdKNWVUbkVWZTJuZ1JqOUZpQzJ1N3RyWTN4ZUFSNXE2cmxkV1ZIL1lKM1FUUWE0V0N4YUtYS0FmRDdQdVhQbnpINzVkUURMeTh2VzdKOURRekg2OXdQa2NybWVyS2NSVXFtVW1YajA3NGQxMngyRUNQMXdyQk42Vk1qbjh5d3NMT3k5TVdXejJiQ1h0RWRnOHV1eWY2am1QclRXWjRIblZ5b1YxdGViMGxOWGFXWC8zQ0N2NE1NUm9iZkI1dVltYzNOendTT2xyS0FCYS81ZkFXZHpjOU1xTDZUVlJCeUlSVCtLSEZCMFhkZXFmZW9vVVN3V3JZbHhEWWZGNS81NWNmOE5zTW9MaWNWaUpKTkpnREx3TDgwK3Z5bFRwYlZPQXQ4RVRBQmp3S2ovci9sODFGOUlydVpqM2Y5M0VmaFNnMmRRaDQ1U3l0TmFaNERUOFhqY21xNHJvVDJPYUdhNUdUaFRMQmF0S250TnA5TW0zSGo0b0hEaktCb1d1dGI2MmNEZCtEM0ZiZkN3MXZvZTROTVJFYndJdmM4SUNIMWZRNGpmWWZkVFlGY1NEbHJmVmpNY0tYU3RkUUw0bjhCckFMZFFLR0MySEV3blV2Qnowd1RpdWk2eFdHenZ3MndOeE9QeEc0RC9UWFFFTDNGNm54RW8ycmtaK09QQWY3MGN1TGxVS3JHNnV0cnpkUjFHTy9FNUhDRjB2K24rQThBTm51ZXh1cnBLSnBOcE9iSGl1aTRURXhOTVRrN1dDdjUxU3FsR2pzUUpBK3NPWEJUYVkzMTluZW5wYVlCYnROYkRTcWxOcmZVRWNEdFVheFZzU3NMRllqRUdCd2NCaXNEblc3bEczUXlUdjhYd1VlQ0dZckhJaFFzWFdGcGFhaXQ3YWlxNTV1Ym1XRnBhTXVXY053RDMrdmV6RWV2S1lJWDJLQmFMcHRwdEVOOVZCMTRQakc5dGJWbTFwUWI3NHZQUEs2VmFhaFk0VU9oYTY2OEhQZ1k4YVhkM2w4Y2VlNnlqWllCQndmc05BNmVCajFncWR1dktZSVgyV1ZsWk1VYnJwL3dROGhXVlNvWExseTlidFJVSWpaL0djaGhYQ2QxMzF6OEVURzl2YjNQaHdvV3VEZk9yVkNwY3VIQWhLSFliTGJ2RTZIM0k1dVltaTR1TFJ0VGZCVlh4MjVod2JUY1JCMWNmbVJNRDdnRk83ZXpzY1BIaXhhN0hLalZpUDBOVjdBZWRBUjRXSXZRK0paZkw3WWw5ZDNlWGxaV1ZzSmQwRmZGNDNNVG51OEFYV3IxT3JVVy9EZmptVXFuRS9QeDh6d29kS3BVS0Z5OWVESXI5Ti8wM0hSc1ExNzJQeWVWeVBQTElJNXcvZjk0Nmx4MzJXZk4vVVVxMVBJZHJUK2grWFA3am51ZHg2ZEtsbnMvZUxwZkx6TS9QbS92ZUJMeTJwd3VvendwVU01KzJIS0VzZEpaU3FXUmQ5WjZoRTI0NzdMZm92d1M0Mld3MnRQN2JVcW0wMXdnQnZGWnIvZnhRRmhMQWZ4ZGRzMmxJcEhCODZFUWlEbnloYTYyZkE5eFNMcGREN3huZTJ0b3lhM0NBZDJ1dFQ0UzZvQ29TcHdzOUo1RkltTHI4TGVCTDdWekxXUFJYQWF5dHJWbHhYTTdLeW9xcE16NEIzRzFCdkM1eHV0QnpBbTc3UDllYlZOc29ybC9pZWd2WVU5L3JlUjRMQ3d2bVRlZGJxSmJmaG9rVXpRZzlwMVB4T1ZRdCt2T0EwWHcrYjlVZVlxbFVZbkZ4MFh6NU9xMzFjME5jamxoMG9lZDBLajZIcXRDZkQ3Q3hzZEh1dFRyTzV1YW0yZHQwZ2QvU1drK0d0QlNKMFlXZU1qQXdZTHJzY3NCWDI3MmVpOTkyYXNzWTNsb3ltWXpaQlpnRzN1a1BCdWo1TWtBYVc0VGVFWERiSDFSS3RiMzN0eWQwbTl6MklEWHgrZ3VBSHc5aEdlSzZDejJsay9FNVZJVnUxVkcyQjFFc0ZvUHgrbTMrRUl4ZXNnejJuTUVtOURlTzQ3UTFDUElnWFB5amJXMHMvd3V5dWJscGhnSEVxTWJyNHoyOC9WNVB1bFRIQ2QwbWtVZ1k3M0VWK005T1hOTUY4a0FrWHNCTFMwdkJUcmUzKzZOL2VzRVdzT3U2YmlSK1QwSzBDVnJ6VGsxZjJoTjZGS2FjbW5qZDc2aDdFZkFqdmJpdi84dVd6THZRRTlvZEczVVFMbFZyRlFtaFF6VnBHSWpYZjBWci9jd2UzVnFFTG5RZHgzRTZub2lEcXREbkFOUHpHZ2syTmpaWVcxdUQ2c3k3ZTdUV0kwYzhwUk5JNWwzb09nTURBK1kxdGdRODFxbnJ1dmliOGY1dytNaXd0TFJrVGhhOUJuaGJEK0oxS1lNVnVrNndHcTZUMDVGZDREOGdXaFlkcXNNcUxsMjZaT0wxbHdFLzJPVmJpa1VYdWs0MzNIYW9DdjJMUUdWb2FDaHlWcjFRS0hENThtWHo1ZTFhNjZkMzhYWVNvd3RkcFNZKzcxZ2lEc0JWU2kwQXYrODREcWRPbllyYzl0SDYrcm81STJzQWVLL1dldWlJcDdTS0NGM29Lb09EZzZiTWVsNHBOZC9KYTV0VSs3dUIrV1F5eWRUVVZDZXYzeE91WExsaTR2VW5BWGQxS1Y2WGd4eUVydExKYnJWYVhBQ2wxQTcrS1JWVFUxT1JqTmNYRmhiTTNLL3ZCVjdaaGR0SUdhelFWYm9WbjBOZ1pweFM2aCtCKzF6WFpYWjJ0dFAzNlRyNWZENFlyOStwdGI2dXc3ZFlBU3BTQml0MGcyN3RueHRxcTJUZUJtVFM2VFFURXhPZHZsZlh5ZVZ5Smw1UFVvM1hVNTI2dGovS1p4VWtUaGM2VHpLWk5FVnJqeXFscm5UNit2dUVycFRLQVc4Q21KNmVqcVNiZXVYS0ZkTmJmeTF3WjRjdkwzM3BRbGZvcGpXSEE0NWtVa3A5RXZoTDQ4Skh6VTJ0aWRkZnFiVitlUWN2TDVsM29TdDBNeEVIOVU5VGZST3dQanc4ek9qb2FEZnUyMVYyZDNlNWNtWFArN2xMYTMxdGh5NHRSVE5DeDNFY2gxUnFMOHA4c0J2M09GRG9TcWtscXZFNjA5UFRrWHhoNTNJNWMveHRpbXIvZWllcWdjU2lDeDBubFVxWitQeHJTcW11SEFCM1dNdmFmY0EveGVOeFptWm11bkh2cnVKNUhvdUxpMlpFMXRQd3R3L2JSSVF1ZEp4T1Q1TTVpTHBDOXd2cWJ3ZDJSMGRIR1JucFJZTllaekgxOEg2OC9nTmE2MXZidktTNDdrTEg2WFlpRGc2MzZDaWxMbEt0bW1ObVppWXlQZXRCZG5kM1dWcGFNbCsrVld2OXhEWXVKeDFzUWtkeFhkZjBtSGpBUDNmdFBnMDg1dmVCaHhPSkJOUFROaDFiM2pqWmJOYkU2ME5VKzljSFdyeVVXSFNob3dUaTg2OG9wYkxkdXMrUlF2Y0xSVjRQbENjbUpvSnVSbVR3UEkvTGx5K2JlUDBiZ0Y5cDhWSjdNWHJVdGgwRk8rbFd0MW90RGZuaVNxbi9BRFRBcVZPbkl1bkNsOHRsTGwyNlpLYmQvckRXK2lYTlhzUHZDZGh5SENlU3Z3UEJQbnFSaUlNR2hlN3pQbUJ1WUdDQUV5ZHNPTW00ZVdyaTliZHJyYysyY0JuSnZBc2RJUkNmbDRHSHVucXZSaCtvbENwUWRYbTl5Y25KeUEycE1LeXRyWmx6NWthcDdxODNXK2NyUWhjNlFqcWROaUhnbDVSU205MjhWMVArcDFMcTg4QWZSSFZJQlR5K3YrNmZUSE1EY0Z1emw0Qm96TUVYN0taWDhUazBLWFNmdTRGTHlXU1N5Y213RGpkdGo1cDQvY2UxMWk5czVIbitRSXVuQW1iUWhTQzBUSy9pYzJoQjZFcXBiZndxc3hNblRqQXcwT3BPVmJqczdPeVF5V1RNbCsvUVdwOXE0R21uZ0xGeXVXeUdVZ3BDUzhSaU1UUGdwUVI4cnR2M2F5bDFySlQ2QitEanJ1dHk2bFFqK3JDVGxaVVZOamMzQWNhQjM5UmFIOVYvK2d5b1duUGJ6Nm9UN0NZUW4zL2UzODNwS3Uzc0ViMFZXSW5xa0FyRDR1S2lPWkw1T2NCYmpoZ3V1U2QwUVdpSFhwUzlCbWxaNkg0Vno2OEJuRHg1TXBKREtnQktwVkl3WHY5KzRQOXByVitodGQ3M3UvR24xWHcvWUE1NkZJU1c2WGIvZVMzdDdoRjlFdmlyV0N6Mm9wbVptYUJnSXNYMjlqYm56NTluWm1hR1ZDbzFEYndUZUxYVyttN2c4OEFFMVdrMXAzWjNkNDI3THdndEVZL0hUWHllQjc3UWkzdTJ2VWVrdFo0Ry9oSVl1WFRwa3FrcGp5eGpZMk4xZS9ETDVUSVhMbHdRMTExb2k5SFJVYzZjT1FQVlk1ZCtxQmYzYkx1TzB4OVM4WGFvZHJoRmZaNWFMcGRqYm02TzVlWGx2YVJidVZ4bWMzT1R4eDU3VEVRdXRFMHY5ODhOblNyditoandQZkY0L0hrek16TXNMQ3gwNkxMaFVLbFV5R1F5WkRLWnZjS1lLSVlrZ3AzME9oRUhIYkRvc0c5SVJYNXNiSXpoNGVGT1hOWUtQTThUa1FzZEl4Q2Y3MUE5OTdBbmRLd0ZTeWwxSG5nUHdPenNySFIzQ2NJQkJMTHREeW1sU3IyNmI2ZlYrQ0hnUzFFZVVpRUkzU1NNK0J3NkxIUi9TTVd2QXVYeDhmRklEcWtRaEc3U3kvcjJJQjMzcjVWU1h3SGU3emlPdVBDQ0VDQ1JTSmpDc2czZ3k3MjhkN2RVK052QTNPRGdZQ1NQWVJhRWJoQ3c1di9zZTc4OW95dENWMHJscWM2Wjg2SjRETE1nZElNd3R0VU1YZk9ybFZLZkEvNG95a01xQktGVDFCeUwzTk5FSEhSUjZEN3ZBaFpUcVZTa085d0VvVjBDOFhrVytGcXY3OTlWb1N1bHRvQTNRTFhETGFwREtnU2hYWUp1dTFLcTB1djdkejBscnBUNk8rQitNNlJDWEhqaE9OTHJ0dFJhZXJYMzlSWmdOWjFPTXpZMjFxTmJDb0lkMU1UblBVL0VRWStFcnBSYUE5NE0wVDJHV1JCYVpXQmd3THptTThDNU1OYlF5MnFXQjRDL2lkK0lNeGNBQUF1cFNVUkJWTVZpek03T2lnc3ZIQnRxNHZOUU9xUjZKblQvQjN3anNEVXlNaExKWTVnRm9SWEMzRll6OUxRK1ZTbDFtVDRhVWlFSWpSQldmWHVRTUFyUlB3bzhGSS9IbVptWkNlSDJndEE3a3Nta01XZ0x3TVd3MXRGem9mdDdpSy9ISDFJUmVMY1RoTDdEaHZnY3dySG9LS1VlQmU2QjZCN0RMQWlOWUlQYkRpRUozZWVEd0pjVGlVUmtqMkVXaE1Pd1lmL2NFSnJRL1RhOTF3T1ZLQi9ETEFqMUdCd2NOTjdxQmFWVXFCTlRRL1dabFZKZkFuNWZPdHlFZmlUc3N0Y2dOZ1RIN3dFV2tzbWtkTGdKZllVdGJqdFlJSFQvR09ZN29Yb01jMVRQY0JPRUlJN2prRXFsekpjaWRBQ2wxTjhDbjRqRllzek16SWdMTDBTZVZDcGw5cy9ubEZLWnNOZGpoZEI5N2dJMnBEeFc2QWRzY3R2QklxSDdaN2k5QTZROFZvZytOaVhpd0NLaCszd1UrRnc4SHVma3laTmhyMFVRV3NKMTNlQjI4WU5ocnNWZ2xkRDk4dGczQUtXSmlRazVBRUtJSktsVXl1eWZmOFdmeFJBNlZna2RRQ24xbjhEN0FlbGJGeUtKYmZFNVdDaDBIdzA4SmdkQUNGSEVodjd6V3F3VXVuOEF4QjBBVTFOVE1qMVdpQXl1NjVyOTh3cndVTWpMMmNOS29RTW9wVDREL0tsTWp4V2l4TkRRa0htdC9wdFNhaVBzOVJpc0ZiclAyNEMxZERyTjZPaG8yR3NSaENNSnZFNC9HZVk2YXJGYTZFcXBMUERySU5OakJmdHhYVGU0Zi82Sk1OZFNpOVZDOTdrZitNZDRQTTcwOUhUWWF4R0V1Z3dQRDV0Q3I0ZVZVdk5ocnllSTlVTDN4Ky9jZ1l5ZUVpd25VTHB0bFRXSENBZ2RRQ2wxQVhndlZQZldaZlNVWUJ1dTZ6SThQR3krRktHM3dRZUJydzBNRE1qb0tjRTZob2VIalFGNldDbDFLZXoxMUJJWm9TdWxTbFJIVDNreWVrcXdqWURiL2tDWTY2aEhaSVFPb0pUNkF2QVJ4M0dZblowTmV6bUNBRnpsdGx1MXJXYUlsTkI5M2dVc3BWSXBHVDBsV01IbzZLaHgyejhYOWhESWVrUk82SDYxMFpzQVRwNDhLWHZyUXFnNGpzUGs1S1Q1OGlOaHJ1VXdJaWQwbjA4QmYyMUdUd2xDV0NTVFNRWUhCd0ZXc1REYmJvaWswUDI5OVY4RHRrZEhSMlgwbEJBYWdmRHhZMHFwUXBock9ZeElDaDFBS2JVSTNBM1YwVk95dHk3MG1uZzhibXJiSzhBZmg3eWNRNG02T3Y0SStHSWlrWkRSVTBMUEdSOGZONTFxZjJ2ajNubVFTQXZkUDlicGRxQThNVEVoZSt0Q3ozQWNoL0h4Y2ZQbEg0YTVsa2FJdE5BQmxGSmZBWDVQam5VU2Vzbnc4TEE1Yk9RODhFOGhMK2RJSWk5MG4zdUFlVG5XU2VnVmdTMjFQL0tIbWxwTlh3aGRLYlVEdkJHcWUrc3lla3JvSnVsMDJzeUZXd2Z1QzNrNURkRVhRZ2RRU24wYStIUFhkZVZZSjZGck9JNFRUUHgrMEtaeFVZZlJOMEwzK1hWZ2ZYaDRXUGJXaGE0UXNPWlo0QTlDWGs3RDlKWFFsVkxMd050QmpuVVNPczhCMW53enpQVTBRMThKM2VjKzRDRVpQU1YwbW5RNmJVWTVaNG5BbGxxUXZoTjY0RmluNHZqNHVCenJKSFNFR212K3UwcXByVERYMHl4OUozUUFwZFFjOEQ2UVk1MkV6akEwTkdTcytSb1JzK2JRcDBMMytSM2czT0Rnb0l5ZUV0cWl4cHAvUUNtMUhlWjZXcUZ2aGU1M0V0ME8xZUlHdjVWUUVKcG1mSHpjbEZkZnB0cGZFVG42VnVnQVNxbUhnRDl4WFZkR1R3a3RFWS9IZzliOExYNXhWdVRvYTZINy9BYXdrazZuZzAwSWd0QVFKMCtlTk51MC93RDhaY2pMYVptK0Y3cC9yTk5iUUk1MUVwb2psVW9aNDFBQzN1UVBQSWtrZlM5MG43OEEvajRXaThuZXV0QVFOWk9HZjFjcDlXaVk2Mm1YWXlIMHdMRk91Mk5qWThIUnZJSndJSUVFM0NLZ1ExNU8yeHdMb1FQNGg5NzlGc2pvS2VGdytpVUJGK1M0dmRvL0JIeGxZR0JBUms4SkIySmNkajhCOS9kVUp3NUhubU1sZFA5WXA5dUJ5dVRrcExqd3dsV01qWTJaenNjdDRJNG9KK0NDSEN1aEF5aWx2Z2k4QitEVXFWTm1ISkFnTURBd0VFelczbW5iR2VmdGNPeUU3dk4rNE5QeGVKd3paODVJTGJ5QTR6aWNQbjNhdU93UEFQZUh2S1NPY2l5RjduZTQvU0p3SlpWS3laYWJ3SWtUSjB6VHlpTHd4bjV4MlEzSFV1Z0FTcWsxNEdlQjh1VGtwRXlrT2Nha1VpbW1wcVlBUE9BMnBWUXU1Q1YxbkdNcmRBQ2wxTDhDNzRCcXZDNURKWThmcnV0eSt2UnBFNzc5cmxMcXdiRFgxQTJPdGRCOWZnLzRxMWdzRnZ5REM4Y0FjeGFBL3diLzcvaEoybjdrMkF2ZGo4VitHWmhQcFZLY1BuMDY3Q1VKUFdKcWFzcWNuYllOL0lKU3FoanlrcnJHc1JjNmdCK1RLV0JyZEhSVXB0SWNBMFpHUmt6UmxBZTh6cDlLMUxlSTBIMlVVbDhHWGdNVUp5WW1aQ3BOSHpNNE9NaXBVNmZNbCs5U1N2MU5tT3ZwQlNMMEFFcXB6d0kvQjFST25EZ2h4enYxSWZGNG5HdXV1Y2JzbDk4UGZDRGtKZlVFRVhvTlNxbFA0WStnbXBtWk1UR2MwQWM0anNPWk0yZE1OZVREd092N2JiKzhIaUwwQTFCSy9RbndUbE10SlRYeDBjYzBxL2pqdjY4QVA2MlV5b2U4cko0aFFxL1BCNEFQR2lzZzgrR2p6ZVRrcEprV2t3ZCtTaW0xRlBLU2Vvb0l2UTYrUy9jYndIMnU2M0xOTmRlSUd4OVJKaWNuVFptekIveVNVdXJmUWw1U3o1SER5UTdoZ1FjZTROWmJiLzFiWU5KeG5HZU5qSXhRcVZUWTJZbjhISUpqdy9qNGVIQWsxTzFLcWY4YjVuckNRb1IrQkE4ODhJQjM2NjIzL2gyUWR4em5XNGFIaDRuRllteHRSZXBFbm1QSjJOZ1lwMDZkTWpVUmR5bWxQaEwybXNKQ3FrS2FRR3Y5ZlZScjQyUHI2K3NzTEN6Z2VjY2lhUnM1UmtaR2dpM0k3MUpLL1U3WWF3b1RFWHFUYUsyL0ZmaHRZR2g3ZTV2NStYbks1WExZeXhJQ0RBOFBjL2JzV1NOeXJaUjZkOWhyQ2h0SnhqV0pVdW9mZ0ZjQm1YUTZ6Uk9mK0VRNTdza2lob2FHZ3BiOHcvUnhvMG96aUVWdkVhMzFHYXFkYjlkV0toV1dscGJJWnJQaXlvZkl5TWdJcDArZk5oTitQd3E4NGJnVXhCeUZDTDBOdE5acDRJM0FLd0UyTmpaWVhGd1VWejRFVEhiZHQrVC9oK3JNTi9sRCtJalFPNERXK2xhcXh6Nk5sRW9sRmhZV0pDdmZJeHpIWVdwcUtqaSsreDdndldMSjl5TkM3eEMrSzM4M2NLUG5lYXl1cnBMSlpNU1Y3eUtPNHpBek0yT2FqenlxVnZ6WWJxRWRoZ2k5ZzJpdFk4QlBVNTFGRjl2ZDNlWEtsU3RzYjIrSHZMTCt3L1FoK05XS1JlRG5sVktmREhsWjFpSkM3d0phNjJkVHpmYWVCVmhmWDJkcGFZbGlzVzhIbVBRVTEzVTVlL1lzUTBOREFKdkFhL3AxMWx1bkVLRjNDVDlSOTVQQVR3Q0RsVXFGMWRWVlZsWldxRlFxSWE4dXVveU1qREF6TTJOYVRUUEFqeW1sdmhMeXNxeEhoTjVsdE5hbmdkdUE3d1VvbFVwa01obXkyV3k0QzRzWWlVU0MyZG5aWU12d3Z3TS8wMCtucVhRVEVYcVA4TjM1TndBM0FPenU3cExKWk5qYzNBeDNZWmJqT0E2VGs1T2NPSEhDN0k5dkF1OEc3cFh0czhZUm9mY1FyYlVMZkEvd1M4QXNRS0ZRWUhWMWxWd3VKeTU5QU1keFNLZlR6TXpNQkNzUC93SjQ2M0hySmU4RUl2UVEwRnFuZ1A4Ty9EQndHcUJjTHBQTlpsbGJXenZXU1R2SGNSZ2FHZ29la1FUd0dQQnJmdm14MEFJaTlCRHh0K05lQXZ3WThHd0F6L1BZMk5oZ2RYWDFXUFc5TzQ3RDhQQXdVMU5UUVlGbmdROENIenBPWTUrNmdRamRFclRXTndBL0N2d1gvRGtCK1h5ZWpZME4xdGZYS1JRS2ZWbDg0emdPSXlNalRFMU5rVXdtemJkWHFBcjhYcVdVRkNGMEFCRzZaV2l0WjRGWFUrMlFHemZmTHhRS2U2TFA1L09SRnIzak9Bd09EakkrUHM3bzZLZ1p2UXl3UkhWVzMwZVZVc2ZIbmVrQkluUkwwVm9uZ09jQkx3TmVERXlhL3lzV2kyeHNiTEM1dWNuT3prNWtrbmp4ZUp5eHNUSEd4c1pxVzN1L0J0d0wzQ2N1ZW5jUW9VY0FQNWEva2Fyb1h3cnNIZWp1ZVI3NWZKNmRuUjIydDdmWjNkMmxXQ3hhWWZGZDF5V1ZTcEZPcHhrYUdpS1pUQWFQdWxvRC9nejRPUEJsYVVMcExpTDBpT0Z2MFQyTHF1aS9EYmlPbXI5anFWUmlaMmVIblowZGRuZDN5ZWZ6bE12bHJvcy9Gb3N4T0RoSU9wMG1uVTZUU3FYTTN2ZmUwb0Mvb1NydXYrdm5RdzF0UTRRZWNiVFd3MVNGLzJ6Z0cvMS94MnNmVjZsVUtCUUtGQW9GaXNYaTN1ZmxjcGxLcGJMM2NkQ2JnYkhDcnV2aXVpNnhXSXhFSXNIQXdNQytqM2c4ZnRBU3Z3cDh4djk0U0NtMTBhbWZYV2djRVhxZm9iVjJnQ2Z5dVBDdjk3KytTdndIRVJTOTR6aDc0bTd3ZE5rODhDandPZUN6d0lOS3FkVldmZzZoczRqUWp3bGE2M0dxZ24rUy82LzVHQUdHZ1RRd1JQMDVna1ZnaStwWjR0dkFJbFZSbjZOYTBISU91S3lVaWtabThKZ2hRaGYyOEwyQkpGWEJEMUVWOXphd0pmRjB0UG4vZlAzWEJXOU80NmtBQUFBQVNVVk9SSzVDWUlJPSIvPgogICAgPC9kZWZzPgo8L3N2Zz4K';
+
+// Déclaration des locales disponibles pour l'extension
+const AvailableLocales = ['en', 'fr', 'de'];
+
+//Traductions des textes utilisés par l'extension
+const Message = {
+	activateHandpose: {
+		'en': 'activate handpose',
+		'fr': 'activer position des doigts',
+		'de': 'handpose aktivieren'
+	},
+	getX: {
+		'en': 'x of [LANDMARK]',
+		'fr': 'abscisse x de [LANDMARK]',
+		'de': 'x von [LANDMARK]'
+	},
+	getY: {
+		'en': 'y of [LANDMARK]',
+		'fr': 'ordonnée y de [LANDMARK]',
+		'de': 'y von [LANDMARK]'
+	},
+	getZ: {
+		'en': 'z of [LANDMARK]',
+		'fr': 'cote z de [LANDMARK]',
+		'de': 'z von [LANDMARK]'
+	},
+	videoToggle: {
+		'en': 'turn video [VIDEO_STATE]',
+		'fr': 'mettre caméra sur [VIDEO_STATE]',
+		'de': 'schalte Video [VIDEO_STATE]'
+	},
+	onfront: {
+		'en': 'front camera on',
+		'fr': 'allumer caméra avant',
+		'de': 'Frontkamera einschalten'
+	},
+	onback: {
+		'en': 'back camera on',
+		'fr': 'allumer caméra arrière',
+		'de': 'Rückfahrkamera einschalten'
+	},
+	off: {
+		'en': 'camera off',
+		'fr': 'arrêter la caméra',
+		'de': 'Stopp Kamera'
+	},
+	video_on_flipped: {
+		'en': 'flip camera image',
+		'fr': 'retourner l\'image de la caméra',
+		'de': 'Kameraspiegel'
+	},
+	please_wait: {
+		'en': 'Setup takes a while. The browser will get stuck, but please wait.',
+		'fr': 'Le temps de chargement peut être un peu long, merci de patienter.',
+		'de': 'Die Ladezeit kann etwas länger dauern, bitte haben Sie etwas Geduld.'
+	},
+	active: {
+		'en': 'handpose activated ?',
+		'fr': 'position des doigts activée ?',
+		'de': 'handpose aktiviert ?'
+
+	},
+
+	landmarks: [{
+			'en': 'wrist',
+			'fr': 'poignet',
+			'de': 'Handgelenk'
+		},
+		{
+			'en': 'the base of thumb',
+			'fr': 'base du pouce',
+			'de': 'Daumenwurzel'
+		},
+		{
+			'en': 'the 2nd joint of thumb',
+			'fr': '2ème articulation du pouce',
+			'de': 'das 2. Daumengelenk'
+		},
+		{
+			'en': 'the 1st joint of thumb',
+			'fr': '1ère articulation du pouce',
+			'de': 'das 1. Daumengelenk'
+		},
+		{
+			'en': 'thumb',
+			'fr': 'pouce',
+			'de': 'Daumen'
+
+		},
+		{
+			'en': 'the 3rd joint of index finger',
+			'fr': '3ème articulation de l\'index',
+			'de': 'das 3. Gelenk des Zeigefingers'
+		},
+		{
+			'en': 'the 2nd joint of index finger',
+			'fr': '2ème articulation de l\'index',
+			'de': 'das 2. Gelenk des Zeigefingers'
+		},
+		{
+			'en': 'the 1st joint of index finger',
+			'fr': '1ère articulation de l\'index',
+			'de': 'das 1. Gelenk des Zeigefingers'
+		},
+		{
+			'en': 'index finger',
+			'fr': 'index',
+			'de': 'Zeigefinger'
+		},
+		{
+			'en': 'the 3rd joint of middle finger',
+			'fr': '3ème articulation du majeur',
+			'de': 'das 3. Gelenk des Mittelfingers'
+		},
+		{
+			'en': 'the 2nd joint of middle finger',
+			'fr': '2ème articulation du majeur',
+			'de': 'das 2. Gelenk des Mittelfingers'
+		},
+		{
+			'en': 'the 1st joint of middle finger',
+			'fr': '1ère articulation du majeur',
+			'de': 'das 1. Gelenk des Mittelfingers'
+		},
+		{
+			'en': 'middle finger',
+			'fr': 'majeur',
+			'de': 'Mittelfinger'
+		},
+		{
+			'en': 'the 3rd joint of ring finger',
+			'fr': '3ème articulation de l\'annulaire',
+			'de': 'das 3. Gelenk des Ringfingers'
+		},
+		{
+			'en': 'the 2nd joint of ring finger',
+			'fr': '2ème articulation de l\'annulaire',
+			'de': 'das 2. Gelenk des Ringfingers'
+		},
+		{
+			'en': 'the 1st joint of ring finger',
+			'fr': '1ère articulation de l\'annulaire',
+			'de': 'das 1. Gelenk des Ringfingers'
+		},
+		{
+			'en': 'ring finger',
+			'fr': 'annulaire',
+			'de': 'Ringfinger'
+		},
+		{
+			'en': 'the 3rd joint of little finger',
+			'fr': '3ème articulation de l\'auriculaire',
+			'de': 'das 3. Gelenk des kleinen Finger'
+		},
+		{
+			'en': 'the 2nd joint of little finger',
+			'fr': '2ème articulation de l\'auriculaire',
+			'de': 'das 2. Gelenk des kleinen Finger'
+		},
+		{
+			'en': 'the 1st joint of little finger',
+			'fr': '1ère articulation de l\'auriculaire',
+			'de': 'das 1. Gelenk des kleinen Finger'
+		},
+		{
+			'en': 'little finger',
+			'fr': 'auriculaire',
+			'de': 'kleiner Finger'
+		}
+	]
+}
+
+function createMenu(items, locale) {
+	return items.map((item, index) => ({
+		text: `${item[locale]} (${index + 1})`,
+		value: String(index + 1)
+	}));
+}
+
+// Déclaration de la classe principale pour les blocs Scratch des points de la main
+class Scratch3HandposeBlocks {
+	get LANDMARK_MENU() {
+		return createMenu(Message.landmarks, this._locale);
+	}
+
+	// Menu pour gérer l'état de la caméra vidéo
+	get VIDEO_MENU() {
+		return [
+			'onback', 'onfront', 'video_on_flipped', 'off'
+		].map(key => ({
+			text: Message[key][this._locale],
+			value: key
+		}));
+	}
+
+	get INTERVAL_MENU() {
+		return [{
+				text: '0.1',
+				value: '0.1'
+			},
+			{
+				text: '0.2',
+				value: '0.2'
+			},
+			{
+				text: '0.5',
+				value: '0.5'
+			},
+			{
+				text: '1.0',
+				value: '1.0'
+			}
+		]
+	}
+
+	get RATIO_MENU() {
+		return [{
+				text: '0.5',
+				value: '0.5'
+			},
+			{
+				text: '0.75',
+				value: '0.75'
+			},
+			{
+				text: '1',
+				value: '1'
+			},
+			{
+				text: '1.5',
+				value: '1.5'
+			},
+			{
+				text: '2.0',
+				value: '2.0'
+			}
+		]
+	}
+
+	constructor(runtime) {
+		this.runtime = runtime; // Référence au runtime Scratch
+
+		this.landmarks = []; // Tableau pour stocker les points du visage
+		this.ratio = 0.75;
+		this.active = false; // Indicateur d'activation de la détection des points de la main
+		this._locale = this.setLocale();
+
+		// Fonction pour détecter les points de la main
+		this.detectHand = () => {
+			// Configuration de la vidéo
+			this.video = this.runtime.ioDevices.video.provider.video;
+			this.video.width = 480;
+			this.video.height = 360;
+			this.video.autoplay = true;
+			alert(Message.please_wait[this._locale]);
+
+			// Initialisation de HandPose via ml5
+			const handpose = ml5.handpose(this.video, function() {
+				console.log("Model loaded!")
+			});
+
+			// Gestion des événements lorsque des points de la main sont détectés
+			handpose.on('predict', hands => {
+				hands.forEach(hand => {
+					this.landmarks = hand.landmarks;
+				});
+			});
+		}
+	}
+
+	getInfo() {
+
+		return {
+			id: 'handpose',
+			name: 'Handpose',
+			color1: '#7231f4',
+			color2: '#4b15b6',
+			blockIconURI: blockIconURI,
+			blocks: [{
+					opcode: 'activateHandpose',
+					blockType: BlockType.COMMAND,
+					text: Message.activateHandpose[this._locale],
+				},
+				{
+					opcode: 'activated',
+					text: Message.active[this._locale],
+					blockType: BlockType.BOOLEAN
+				},
+				'---',
+				'---',
+				{
+					opcode: 'videoToggle',
+					blockType: BlockType.COMMAND,
+					text: Message.videoToggle[this._locale],
+					arguments: {
+						VIDEO_STATE: {
+							type: ArgumentType.STRING,
+							menu: 'videoMenu',
+							defaultValue: 'onfront'
+						}
+					}
+				},
+				{
+					opcode: 'setVideoTransparency',
+					text: formatMessage({
+						id: 'videoSensing.setVideoTransparency',
+						default: 'set video transparency to [TRANSPARENCY]',
+						description: 'Controls transparency of the video preview layer'
+					}),
+					arguments: {
+						TRANSPARENCY: {
+							type: ArgumentType.NUMBER,
+							defaultValue: 50
+						}
+					}
+				},
+				'---',
+				'---',
+				{
+					opcode: 'getX',
+					blockType: BlockType.REPORTER,
+					text: Message.getX[this._locale],
+					arguments: {
+						LANDMARK: {
+							type: ArgumentType.STRING,
+							menu: 'landmark',
+							defaultValue: '1'
+						}
+					}
+				},
+				{
+					opcode: 'getY',
+					blockType: BlockType.REPORTER,
+					text: Message.getY[this._locale],
+					arguments: {
+						LANDMARK: {
+							type: ArgumentType.STRING,
+							menu: 'landmark',
+							defaultValue: '1'
+						}
+					}
+				},
+				{
+					opcode: 'getZ',
+					blockType: BlockType.REPORTER,
+					text: Message.getZ[this._locale],
+					arguments: {
+						LANDMARK: {
+							type: ArgumentType.STRING,
+							menu: 'landmark',
+							defaultValue: '1'
+						}
+					}
+				}
+			],
+			menus: {
+				landmark: {
+					acceptReporters: true,
+					items: this.LANDMARK_MENU
+				},
+				videoMenu: {
+					acceptReporters: true,
+					items: this.VIDEO_MENU
+				},
+				ratioMenu: {
+					acceptReporters: true,
+					items: this.RATIO_MENU
+				},
+				intervalMenu: {
+					acceptReporters: true,
+					items: this.INTERVAL_MENU
+				}
+			}
+		};
+	}
+
+	getCoordinate(args, axis) {
+		const landmarkIndex = parseInt(args.LANDMARK, 10) - 1;
+		const axisMap = {
+			x: 0,
+			y: 1,
+			z: 2
+		};
+
+		if (this.landmarks[landmarkIndex]) {
+			const coordinate = this.landmarks[landmarkIndex][axisMap[axis]];
+			if (axis === 'x') {
+				return this.runtime.ioDevices.video.mirror ?
+					240 - coordinate * this.ratio :
+					-1 * (240 - coordinate * this.ratio);
+			}
+			return axis === 'y' ? 180 - coordinate * this.ratio : coordinate;
+		}
+
+		return "";
+	}
+
+	getX(args) {
+		return this.getCoordinate(args, 'x');
+	}
+
+	getY(args) {
+		return this.getCoordinate(args, 'y');
+	}
+
+	getZ(args) {
+		return this.getCoordinate(args, 'z');
+	}
+
+	activated(args, util) {
+		return this.active;
+	}
+	activateHandpose(args) {
+		if (!this.runtime.ioDevices.video.videoReady) {
+			alert('Il faut d\'abord activer la vidéo');
+		} else {
+			this.active = true;
+			this.detectHand();
+		}
+	}
+
+	// Fonction permettant d'activer la vidéo et de changer de caméra
+	videoToggle(args) {
+
+		switch (args.VIDEO_STATE) {
+			case 'off':
+				this.runtime.ioDevices.video.disableVideo();
+				if (this.active) {
+					this.active = false;
+				}
+				break;
+			case 'onback':
+				this.runtime.ioDevices.video.enableVideo('environment');
+				this.runtime.ioDevices.video.mirror = false;
+				this.active = true;
+				break;
+			case 'onfront':
+				this.runtime.ioDevices.video.enableVideo('user');
+				this.runtime.ioDevices.video.mirror = true;
+				this.active = true;
+				break;
+			default:
+				this.runtime.ioDevices.video.mirror = !this.runtime.ioDevices.video.mirror;
+		}
+
+	}
+
+	// Fonction permettant de changer la transparence d'affichage de la caméra sur la scène
+	setVideoTransparency(args) {
+		const transparency = Cast.toNumber(args.TRANSPARENCY);
+		this.globalVideoTransparency = transparency;
+		this.runtime.ioDevices.video.setPreviewGhost(transparency);
+	}
+
+	// Fonction permettant de définir la langue de l'extension en fonction de la langue définit dans Scratch.
+	// Si la traduction d'une langue n'est pas disponible dans l'extension, c'est l'anglais qui est choisi
+	setLocale() {
+		let locale = formatMessage.setup().locale;
+		return AvailableLocales.includes(locale) ? locale : 'en';
+	}
+}
+
+module.exports = Scratch3HandposeBlocks;
\ No newline at end of file
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_ic/index.js b/node_modules/scratch-vm/src/extensions/scratch3_ic/index.js
new file mode 100644
index 0000000..eb14ef2
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_ic/index.js
@@ -0,0 +1,410 @@
+// Importation des modules nécessaires pour l'extension Scratch
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const ml5 = require('ml5'); // Bibliothèque ml5 pour utiliser les modèles de machine learning
+const formatMessage = require('format-message'); // Gestion des messages multilingues
+// Icone pour l'extension
+const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDE5MiAxOTIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM6c2VyaWY9Imh0dHA6Ly93d3cuc2VyaWYuY29tLyIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxLjU7Ij4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDUuNTE4MjIsMCwwLDEwLjkyODUsLTY4MS45OTgsLTE5OS42MTQpIj4KICAgICAgICA8cmVjdCB4PSIxMjMuNTk0IiB5PSIxOC4xNjkiIHdpZHRoPSI2Ni4zMTIiIGhlaWdodD0iMzMuMTM3IiBzdHlsZT0iZmlsbDpyZ2IoMTMsMTg5LDE0MCk7c3Ryb2tlOnJnYigxMywxODksMTQwKTtzdHJva2Utd2lkdGg6MC4xMnB4OyIvPgogICAgPC9nPgogICAgPHBhdGggaWQ9InRvaWxlIiBkPSJNOTcsOTZMODUuODkxLDExNS43MUw2My43MTMsMTIwLjE4NEw3OS4wMjUsMTM2Ljg0TDc2LjQyOCwxNTkuMzE2TDk3LDE0OS45TDExNy41NzIsMTU5LjMxNkwxMTQuOTc1LDEzNi44NEwxMzAuMjg3LDEyMC4xODRMMTA4LjEwOSwxMTUuNzFMOTcsOTZaIiBzdHlsZT0iZmlsbDp3aGl0ZTtzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjdweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgPGcgaWQ9IkNhbHF1ZS1jb3BpZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0NCwzKSI+CiAgICAgICAgPHVzZSB4bGluazpocmVmPSIjX0ltYWdlMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwNXB4IiBoZWlnaHQ9IjkycHgiLz4KICAgIDwvZz4KICAgIDxnIGlkPSJSZWN0YW5nbGUtY29waWUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNiw4NykiPgogICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI19JbWFnZTIiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzlweCIgaGVpZ2h0PSI4OXB4Ii8+CiAgICA8L2c+CiAgICA8ZGVmcz4KICAgICAgICA8aW1hZ2UgaWQ9Il9JbWFnZTEiIHdpZHRoPSIxMDVweCIgaGVpZ2h0PSI5MnB4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUdrQUFBQmNDQVlBQUFCdE5ac2tBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBUmxrbEVRVlI0bk8yZGUyd1UxM3JBZnpNZW0zMzR1UnRldG96dGlLY2hoSmZzVUFpRUpEY2hDWEVDVVc1VDBwdGVWZUtmS0NUU1RkS2tLRlhWcGxLYUI2TEtwWFZVb1NhME1xVnBJU0hBZFhKTERIa0RBZXlrTnM4QVpzSDRnZGRlci9lOU03UDk0OWhncjJmQmEzdlhHUFluamZ5WTNaa3o1NXZ2bk85ODV6dmZrVWcrRXBBQlpBRUZRR0hQVVF6TTZQbDlQSkFKakFQU0VseWVDQkFDL0VBSDBBS2NBYzRDRHVBaWNBbTRBZ1FBUGNIbEdZQ1U1UHZkQlR5RkVFZytVQXJZQWJtbkxMMC9lOHVWclBKRit2enNQZlNlbjM2RXdINEJPb0UvQWw4QXZpU1ZMZUdWWUVGb3hYTGdjV0FXY0NkZ1R2QjlFMFVFYUFaT0FkOEN1NER6Z0lzRWFsaWloSlNKMEpySGdWOGhCSk1GS0FtOFp6TFJFUnJXQWh3RTlnQmY5ZndkdWM3M2Jnb3NRQm13RWFnRnd2UnZRbTdGUXdmYWdQOEdmbzFvT2VUaFZtUmZSdXF0VmhEOXpCcmd0MEFKWUJyRTkzVEFaN2ZidmJObXpWS0xpNHNWbTgyV2xwNmVqaVFsVitFaWtRaXFxa1pjTHBmbWNEakNKMCtlbEpxYm15MUFOdUw1Ym5nSmhMRDJBLzhDMUFFZVJrQ3pobHNURWtJWUR3Qi9oZENpY2JFK25KYVdwbWRtWnFxNXVibmRDeGN1RE54Nzc3MTZlWG01T21QR0RLdk5acnVERVg0RGg0UEg0MmwzT0J6dWt5ZFBwaDg3ZGl4OTM3NTk4dG16WjdOY0xsZUdxcXE5Qms0c0xnT2JnZjhDR2hsbWZ6VWNJVW5BSk9CM3dKOERFMk5kejJReWFZc1dMUXBXVkZRRVZxeFlZUzRzTE5Uc2RudUdvaWdadzdoL1V2RjZ2YjRMRnk3d3pUZmZ1SGZ1M0puKzdiZmZadnA4dmd4aTE2RVAwVSs5QTN5SGFQcVRTaG93SGFIYU1kdnJ6TXhNZmNXS0ZhRTllL1owNmJxdVIyNGhmdnp4eHdzVkZSWGQyZG5aSVVtU3J0ZG50U0g2S2tzeUJhUUFxNEdqZ0dwVU1FVlI5RWNlZWFUajg4OC9kL3Y5ZnQ5b1YyaWlDSWZEM29NSER6clhyVnQzUGljblI0c2hwRjdENGgrQjNHUUl5QVNzQlk1emJiQjM5WkFrU2MvTHl3dFVWbFplSE8wS1REYUhEaDI2VUZwYTJxMG9TaXhodVlFUEVJUDNoRmxGSnVBbDRCd0dHaVJKa3Y3b280KzJuRHAxcWxQVE5IVzBLMjAwNk9qbzZOeXdZVU9qMld6MnhSQ1VGMkZNVEV1RW9CVGdONGpSOVlDYm0weW04R3V2dlhiQzdYYTdSN3VpUmh0VlZjTzdkKzgrUG43OCtEWkprZ2EwTmtBUStGZUUzM0xFQkpVT1BJTndoUXhRNVlLQ0F2KzJiZHV1YUpvV0hPMEt1cGs0ZXZSbzA2SkZpeTVpM0c5M0EvK0VjQ1lQR3dtWUM5UWIzQ2d5YmRvMDM3Rmp4NXBIdTBKdVZpNWZ2dHk0Y09IQzg1SWtHZlZUYm1BRFlCMnVnSW9RTnY2QXQySGF0R20rcjcvKzJqWGFGWEd6YytiTW1hYkZpeGRmeHNEUVFreUIvQVZpNm1aSVpBTC9abkRoU0VGQlFTQ2xRWU9udmIzOWw3dnZ2dHNaWXp6VkFDd1lpb0F5RUtaMmUvUkZUU2FUV2xWVjVSenRCeDlySEQ5K3ZHWE9uRGwrQXlFRmdmOEU4dUlWVWluQ1FSaHRaa2RlZWVXVk02cXFoa2I3b2NjaXg0NGRhN1JZTEVZekF4MEk5OXFncmIwY3hGUkQ5TVgwaHg5KytFcFhWMWYzYUQvc1dHYno1czFPczlrY2lxcGJEZUhCdVd1d1Fub1k0Ym50SisyY25KeGdmWDE5NTJnLzVGakg0L0Y0bHk5ZjNtU2dUVUdFTS9hRzJqUWVZU3dNVU1rTkd6WTBxcXFhR2d1TkFJY1BINzZVazVQVEdkMVNJYXk5dTRpYXN1a2JpU01ESzREbkFWdmZEODJmUDk5VlZWV1ZxU2pLV0kxTnVLa29LQ2pJYm0xdFBYL3c0TUU4cmdsRVFuakt4d0g3aURHMWtRdHNJY3FlTjV2Tit2YnQyMVBqb1JIbTlPblRMWk1uVCs1Z1lMUFhDcFQzRlV4ZnRacUVpT3JwMXlZdVhMaFFYYlZxMVppWm5Cc3JsSlNVNUQ3eHhCUE5CcWZzd0ovUXA1WHJLNlJmSXdSMWxZeU1EUDJsbDE3U3JGWnJxcGtiWVJSRkdmZkNDeStZTEJhTE8rcFVHdkFrd2dFTDlHOFBseEkxZXpoMzd0emdVMDg5RlRObUljWHdLQzB0TFZtOWV2VUpHQkNzc2hCaHhBSFhoRlNCQ0Z6c3ExbjYwcVZMUFZLeXczWnVJeVJKa3RhdVhadVRrWkhoanpwbFFVUmQ1WUVRU2hvaTJtZHkzMCtaeldadDVjcVZpWTdEdnUwcEt5dkxMeWdvOEVUOVd3SWVRL1JQeUlpUTM0bEVCY2JuNXVaNlpzeVlrWjZNZ3Q3TzVPVGtwTStiTjYvYjRGUTJQVTJlM1BQTGpPaFB6SnMzejVlZm41OFNVb0pSRk1YOHpEUFBxQWFuTE1BaUVFS2Fnb2pWN2t2ay92dnZsekl5TWdZVGhacGlHRWlTeEpJbFN6S3RWbXQwQUtVSk1ZV1IzaXVrNkhGUW9MeTgzRWk2S1JKQWZuNys1TEt5TWxmVXZ5VkVuNVFsSTJaZisvbUs3SGE3cDdTME5EVTJTaEtTSk1rTEZpem9ORGlWQTJUTGlQNm9uNWs5YTlhc2NFOXNkb29rTVdYS0ZLL0J2KzJBWFVIRWdQWFRwT0xpNHJSRWpJK0N3YURXME5DZzFkVFU2QzB0TFJRV0Z2TEFBdzlJczJmUHpoaksvWFJkanpRMk5vWjI3TmloTlRRMFJMS3lzbGk1Y3FXOGJOa3lPU3NyYTBpRDhQYjI5dkQrL2Z2VjJ0cGFDYUNzckV4ZXRtd1pOcHN0b2E0eHE5VnE1RkRONnptdVJ2MWZkZkt0WDcrK0xSRk94UzFidG5UYWJEWTFMUzN0YWppeXpXWUw3OW16WjBqQmxQWDE5ZDJscGFWQlJWRjBlbWFPTFJhTHRtN2RPcmZINHduRWV6MU4weUtQUC82NHoyUXlhYjN4Q0dheldYL3NzY2NDemMzTmNWOHZIclp1M1hxUWdjN1dMdUFKZW43cEo2U1hYMzc1eWtnWHd1UHhxTE5uenc0WUZDUlNWbGFtdWx5dXVBTDZ3K0Z3ZU5XcVZWNmo2MlZsWldrMU5UWCtlTXY0OXR0dmQ4dXliQlRWRTZtc3JBd25jczNCMXExYmZ6QzRieEQ0VXhsaDZ2VnJhbVJaanZZbERadjYrbnJmNmRPbkRadU1NMmZPcERrY2pyZ1dDcmUydG5idTM3L2ZjS1dDeCtPUmYvamhoMUE4MXd1SHcrRlBQdmtrWGRkMXcyYjN3SUVEYWFxYU9JTzM1K1dJUmdHVXBDM2E4dnY5YUpwbWVDNFlET0oydStOYXYrUDMrelcvUDlybGRZMUFJQkRYaXlaSmtwU2VuaDZ6WHd3R2cvRmNMbTU2bXRkb0lpQU1odTdlUDNyUk5HM0VqWWJwMDZjckV5Wk1NRnp4WnJmYkl5VWxKVm54WEcvaXhJbVdrcElTdzFjN0l5TWpNblBtekxpOEpZcWlLS3RYcjQ1NXZyUzBOQ0xMaVh1bmRWMDN1bmdJQ01tSVBxbi9tVkJveEp1Ny9QeDg4OU5QUHgxS1MrdnZzMVVVaFlxS0NzMXV0OGRWQTFsWldkblBQLys4MTJLeDlDdXJKRW5Nbno5ZlhiNThlZHd1clJkZmZER2pvcUtpMzRza1NSSkZSVVg2MDA4L3JVZVhmU1NKUkNKR3p4OEVnbW1JTU5kSjlPbVhwazJiNWw2elprMWNiL1pnV0xwMGFWcDJkcmEvdmIxZENRYUQwdFNwVS9YMTY5ZDdYMy85OVhGV3F6VnU3VjJ3WUVGR1lXRmhvTFcxVmZINy9WSitmajVyMTY0TmJ0NjhPWDN5NU1scDhWcjFzaXl6Wk1rU3JidTdXM081WEdsWldWbFVWRlNvSDM3NG9UUno1c3k0cnhjUHRiVzFsM2Z0MmxVUTllOHU0SDlBSkl6b0YrdDl6ejMzT0hSZER5Zktrdkg3L2VGTGx5NTVmRDdmaUppMTRYQllhMnBxOG5aMWRjVnQwY1dpbzZQRDUzUTZrN1pLY2ZQbXpVY1lhTjJkQmhiTHdBbWlWa2VmUEhsUzd1enNiRTNVVzJNeW1aU0NnZ0tyMld3ZWtWbGZSVkhrL1B4OFMzWjI5b2c1aFBQeThzdzJteTFwcmpHSHcyRlVGMDdBS1FNWGlESWNYQzVYNXZIang1T1dPK2QyUjlkMTdjaVJJMGJyYWJ1QUxobVJpU3JhTnM0NmRPaFFLa0lvU1hSMmRyWWVPblJvb3NFcEYrQ1dFVzZodHFpVDhvRURCMUJWTlpEb0FxYUFob1lHajlmcmpiWkdRNGlVYmdFWmtiMmpQdnFMUC8vOHM4bnBkTVkxYWs4UlA1RklSUDNpaXkrTWJIc2ZJaE5ZUkVia3YybGxZTCtVMjlqWW1Jb1VTakErbnk5WVhWMmRhWEFxZ0VpSWlJd3d2MzlHck9HOGlzZmpTZCszYjUvUkhFZUtFY1RoY1BnZERvZlJ1dG1mRU91V2tCRWE5Qi9BU2Zwb2s2N3I4dTdkdTAyYXBxV2F2QVJTWFYzZDdIUTZvMDM5TVBBK1lxWGwxY20rVHNUS3ZuNWV4R1BIamxuMzd0M3JUSFJCYjFmY2JuZlhsaTFiN0F6TU0zdVdhMGxOcmdvcEF1eWtSNzE2Q1lmRDZlKysrMjVlSUJBd2lndExNUXdpa1Vpa3VycTYvY1NKRTVPaVR3SFZpTFZLUVA5cDg1OFJTd0w3VVZ0Ym0vN1ZWMThsMWs5L0crSjJ1NFB2di85K0RnTnovTG1CTHhFcGJpRHFBMDdnRDBSNXhiMWViMXBsWmFWUDA3UlVpTmNJOHQxMzMxMnBxNnVMTmhoMFJMZHppSUZCL0ZlWkNueE8xSFM2eVdSU1AvbmtrM1BKY2piZTZuUjFkWFV2WHJ5NE5icWVFWE43RmR3Z0Y3cUV5TVRsaXZweVpOS2tTYjVMbHk2MWpQWURqblUwVGRNM2JkcmtOQkNRaW1qbUJqV3ZOZ240TEZwSXNpeHJ6ejMzM0RsVlZXL1pKSVBKb0tHaHdWTmNYR3lVZEtNSnNicGxVTWlJWlprRHNxRUFvY3JLeXFPYXBtbWovYkJqa1VBZ29ELzU1Sk0rQXkwS0lCTHJ4dVhVemdQK0FlRS82aWVvN094c2QzVjFkYXAvaWhPZnp4ZCs5ZFZYdlFZaFl5cndEWEIzUEFMcXBSampSTGo2blhmZWViR3hzZkdYU0NSeVN5Vy9UUlNxcW1vZmZQREJaWXZGWXBUNzdqSml2ZktRVUlBSEVZT3FBZEtmTzNldTQ5U3BVNmxNWFRjZ0dBd0dmLy83MzEvTXlja0pHZ2pJRGJ4RlZONk1vUWhxSGNiOWsxNVdWbmF1dmIzOTRxMldUbnFrMEhWZCsraWpqODVhclZhanlOMFFJaDlyeVhBRTFJc1plQlBoTW9yV0tHM1dyRmx0MzMvL2ZlTm9WOGpOaHQvdkQyN2N1TEU1THkvUHlKSlRnZjlsaUhudVltRUJLaEhxT1NCT09qOC8zLzNUVHovOVgwcWpCT0Z3V0gvampUZWF4bzBiWjVUV3M5ZXJzSkFFYlBzd0NmaG5oTGs0UUZCMnV6MjhhZE9tSzZGUXlEUGFsVFNhSEQ1OHVIM2x5cFhkYVdscFJvSC9PbUlXZkJtRDI2UmtTSmlCZDJNSkNsQWZldWloTG9mRDRiemRsQ29VQ3ZrM2J0elltWm1aYVdRZzlBcm9BbEdCcUluQ0R2dzlZa2N1dzhJVUZSVjF2L25tbTVjYkd4czdScnZ5RW8zTDVYTHYzYnYzeW4zMzNlZEtUMDgzM0JZQ3NTSFdINEI1eVJCUUw5bUluVjdPeHloVUJORHZ1T01PNXp2dnZITzhxNnZybGhOV0tCVHEzcmx6NTlHWk0yZWU0L3FiZVhrUit5bVZKRk5BdlZnUVc4Rjl6clhObkF5YndLS2lvaXZQUHZ2c2hjOCsrK3hjVTFOVHM2cXFDVjAxbHlqOGZyKzN2cjYrNWEyMzNtcGNzR0RCSlZtV3U2L3ozR0ZFcHVMZjBTZVowMmdnSVZaSXY0M3hXR3FBazFaUkZQZnExYXQvMkwxNzk1Y3RMUzNuZEYyL3FmMkFYVjFkVFVlT0hEbTBjZVBHcitiT25kdXNLSW9hWTN1RGZrTVRoSlA2VjR5QUJUZFM2cGVKeU4zNkcwUzJyMXh1dkQrc2FyVmF2Vk9uVG5WUG1USWxhTFBaQWxhck5XU3hXS1NwVTZmbXpKa3p4MVphV21yTnk4dExhRllXdjkrdm5UOS8zbi8rL0hsL2ZYMjlzN201MmUvMWVpV24wNWx4OGVMRmpIUG56bVYxZEhUa0lESTZYcSsrZXZ1ZVg0Q1BnZTJJd0ZQamxYT2pSRzl5aUhXSUhTTjdOODY5cm5iMU9YVEVBMm15TEd2cDZlbGFlWGw1dUs2dUxtR2JsTFMxdGJXdFdiT21lOXk0Y2JxaUtGclBkZ1Zhbk9YdTFaeUxpTEhrVEJKb1hvOGt4Y0NMaVA0cWhNRkdKSU05Q2dzTHc5dTJiWE9IUXFFUmF4WjFYZGNPSERod2NmcjA2VGRzb3E5ejZJaCs1eFRDMmwxTzRuZVhUZ2paaUpGMUZjUFl6blQ4K1BIYWpoMDdSaXpkZFYxZDNla3BVNlpFWnhPTzk2Z0gvZ3l4OC9STnMySGtVSkVSTzV2TUFmNFMrQkE0Z25EUng5b01hc0F4Y2VKRXRhcXFxak1jRGc5NUF5MWQxN1dhbWhwSFlXRmhHNE52MHNJSXYrVXB4RmpuRFVUVzV3bUliWXR1cVZCc0NkRWNXQkNiTnQ2SDJKZjJEWVN6c1JGaElYWVRZNi9BOGVQSGgzYnQyalhrT0l1NnVyclRSVVZGc1FTa0kxNmFUc1JBL1FoaWU3ZmZBZzhoV29ROFJIOHo1alVuSGlTRVpWaU1TRnErQUxGWDdkOGg1dndIQ0dyU3BFbis3ZHUzWDRsSG96Uk51NUVHQlJFbTh6SkVqcmw1aUJkcFBHUEVDQmdON0lqTmhRMWRUeE1tVEFoKyt1bW5nOWFvMnRyYVUwVkZSYkg2b0FDd0Y1ak5MZFowSlFNYjhOZGNXNVlUclZHK2p6Lyt1TzE2R3FWcG12YjExMStmTFN3c3ZHSjBEWVNBZHBFUzBMRElCZjRXMFU4WWF0VE9uVHRicjZOQko0dUtpbUtaMlVIZ2o4RDhVWGl1V3c0elFxUGFNZWhQSms2Y0dLcXFxdW9JQm9OcUh3MVNhMnBxemw5SGcwTEFwd3d4UWllRk1TWkVIMlU0TTJ5ejJiVDMzbnV2U1ZYVjFrZ2swclpyMTY2RCtmbjVUcVBQOWh6VmlJMjhVb3d3R2NEZklCWmhHMVc4V2w1ZVh2UGdndy8rTzhKRlkyVEZxWWl4emh4dU16TTZtZVFpdHYyTUphZ3dvcStKTlZDdFJwalhLUUVsbUR4RTAyYzRqb3B4QkJGOTBDekdxSDl0TEdKSEdCT3hOQ3BhUUo4am1yaVVtWjFrN2tDNGxGcUlMU0Evc0lja3h4YWs2SThkZUIzaEFEVVMwR2NJQWFVWVpiSVFWcDhUTWY0Skk0SS9QdVVXYWVMRy9BUDBrSVZ3eks1R3hGeDhDZFFna2x1TmVmNGZVVUorV3ZjNlRKVUFBQUFBU1VWT1JLNUNZSUk9Ii8+CiAgICAgICAgPGltYWdlIGlkPSJfSW1hZ2UyIiB3aWR0aD0iMTc5cHgiIGhlaWdodD0iODlweCIgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMTUFBQUJaQ0FZQUFBQjF5eFVYQUFBQUNYQklXWE1BQUE3RUFBQU94QUdWS3c0YkFBQUJZVWxFUVZSNG5PM1dNVW9sUVJTRzBiK2xEVjJFdXhBeEVHUEhaUmhPT2h0d0kwWUdtcGs0MllCdVlqRFVIUmlOakZ5VEI3NVF4YUo1MTNPaW9vTmJWZkJSZEdxODI2cmFDZDlhVloyTkRtMXI2VXZDVjVuWDFqZEovZ3pZNHpISnZ3RnoyU3kva3p3Tm1MdWY1Q1JKc3ZaSy94cXdFUXhWVlQvOVp0Q09tR2xEekxRaFp0b1FNMjJJbVRiRVRCdGlwZzB4MDRhWWFVUE10Q0ZtMmhBemJZaVpOc1JNRzNPU3k5WDY3NUlIZ1UrNnoxdkRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPODNWZFgxYW4wK1RkUFZvcWVCRDZxcUgwbE9rMlJPY3J6NmZyZllpZUR6ZHJOcWVHdmhnOENYRVROdGlKazJ4RXdiWXFZTk1kT0dtR2xEekxRaFp0b1FNMjJJbVRiRVRCdGlwZzB4MDRhWWFXTmVXeDlWMWZhQVBSNlNYRXpUOUR4Z05odWlxZzZUSEF3WXZiZSt5V2kzVmJVejRCSnNrS282R3gzYW5HVDBpL2wvOEh3Mncwc0d0L1lLek5YS2NiSmVEbVFBQUFBQVNVVk9SSzVDWUlJPSIvPgogICAgPC9kZWZzPgo8L3N2Zz4K';
+
+const HAT_TIMEOUT = 100;
+
+// Déclaration des locales disponibles pour l'extension
+const AvailableLocales = ['en', 'fr', 'de'];
+
+//Traductions des textes utilisés par l'extension
+const Message = {
+  activateImageclass: {
+    'en': 'activate Image Classification',
+    'fr': 'activer Image Classification'
+  },
+  video_toggle: {
+    'en': 'turn video [VIDEO_STATE]',
+    'fr': 'mettre caméra sur [VIDEO_STATE]'
+  },
+  on: {
+    'en': 'on',
+    'fr': 'on'
+  },
+  off: {
+    'en': 'off',
+    'fr': 'off'
+  },
+  onfront: {
+    'en': 'front camera on',
+    'fr': 'allumer caméra avant',
+    'de': 'Frontkamera einschalten'
+  },
+  onback: {
+    'en': 'back camera on',
+    'fr': 'allumer caméra arrière',
+    'de': 'Rückfahrkamera einschalten'
+  },
+  off: {
+    'en': 'camera off',
+    'fr': 'arrêter la caméra',
+    'de': 'Stopp Kamera'
+  },
+  video_on_flipped: {
+    'en': 'flip camera image',
+    'fr': 'retourner l\'image de la caméra',
+    'de': 'Kameraspiegel'
+  },
+  result1: {
+    'en': 'candidate1',
+    'fr': 'Prédiction 1'
+  },
+  result2: {
+    'en': 'candidate2',
+    'fr': 'Prédiction 2'
+  },
+  result3: {
+    'en': 'candidate3',
+    'fr': 'Prédiction 3'
+  },
+  confidence1: {
+    'en': 'confidence1',
+    'fr': 'Probabilité 1'
+  },
+  confidence2: {
+    'en': 'confidence2',
+    'fr': 'Probabilité 2'
+  },
+  confidence3: {
+    'en': 'confidence3',
+    'fr': 'Probabilité 3'
+  },
+  when_received_block: {
+    'en': 'when received classification candidates',
+    'fr': 'quand une prédiction est réalisée'
+  },
+  toggle_classification: {
+    'en': 'turn classification [CLASSIFICATION_STATE]',
+    'fr': 'mettre la classification sur [CLASSIFICATION_STATE]'
+  },
+  set_classification_interval: {
+    'en': 'Classify once every [CLASSIFICATION_INTERVAL] seconds',
+    'fr': 'Faire une prédiction toutes les [CLASSIFICATION_INTERVAL] secondes'
+  }
+}
+
+// Déclaration de la classe principale pour les blocs de l'apprentissage machine
+class Scratch3ImageClassifierBlocks {
+  constructor(runtime) {
+    this.runtime = runtime;
+    this.when_received = false;
+    this.results = [];
+    this.locale = this.setLocale();
+
+    this.blockClickedAt = null;
+
+    this.interval = 1000;
+
+    // Méthode pour détecter les images et charger le modèle de classification
+    this.detect = () => {
+      this.video = this.runtime.ioDevices.video.provider.video;
+      this.classifier = ml5.imageClassifier('MobileNet', () => {
+        console.log('Model Loaded!');
+        this.timer = setInterval(() => {
+          this.classify();
+        }, this.interval);
+      });
+    }
+
+  }
+
+  getInfo() {
+    this.locale = this.setLocale();
+
+    return {
+      id: 'ic',
+      name: 'ImageClassifier',
+      blockIconURI: blockIconURI,
+      blocks: [
+        // Bloc pour activer la classification d'image
+        {
+          opcode: 'activateImageclass',
+          blockType: BlockType.COMMAND,
+          text: Message.activateImageclass[this._locale],
+        },
+        // Blocs pour récupérer les résultats de la classification
+        {
+          opcode: 'getResult1',
+          text: Message.result1[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getResult2',
+          text: Message.result2[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getResult3',
+          text: Message.result3[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        // Blocs pour récupérer les probabilités (confiance) des prédictions
+        {
+          opcode: 'getConfidence1',
+          text: Message.confidence1[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getConfidence2',
+          text: Message.confidence2[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getConfidence3',
+          text: Message.confidence3[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        // Bloc déclenché quand une classification est reçue
+        {
+          opcode: 'whenReceived',
+          text: Message.when_received_block[this.locale],
+          blockType: BlockType.HAT,
+        },
+        // Bloc pour activer/désactiver la classification
+        {
+          opcode: 'toggleClassification',
+          text: Message.toggle_classification[this.locale],
+          blockType: BlockType.COMMAND,
+          arguments: {
+            CLASSIFICATION_STATE: {
+              type: ArgumentType.STRING,
+              menu: 'classification_menu',
+              defaultValue: 'off'
+            }
+          }
+        },
+        // Bloc pour définir l'intervalle de classification
+        {
+          opcode: 'setClassificationInterval',
+          text: Message.set_classification_interval[this.locale],
+          blockType: BlockType.COMMAND,
+          arguments: {
+            CLASSIFICATION_INTERVAL: {
+              type: ArgumentType.STRING,
+              menu: 'classification_interval_menu',
+              defaultValue: '1'
+            }
+          }
+        },
+        // Bloc pour gérer l'état de la vidéo
+        {
+          opcode: 'videoToggle',
+          text: Message.video_toggle[this.locale],
+          blockType: BlockType.COMMAND,
+          arguments: {
+            VIDEO_STATE: {
+              type: ArgumentType.STRING,
+              menu: 'video_menu',
+              defaultValue: 'off'
+            }
+          }
+        },
+        // Bloc pour gérer la transparence de la vidéo
+        {
+          opcode: 'setVideoTransparency',
+          text: formatMessage({
+            id: 'videoSensing.setVideoTransparency',
+            default: 'set video transparency to [TRANSPARENCY]',
+            description: 'Controls transparency of the video preview layer'
+          }),
+          arguments: {
+            TRANSPARENCY: {
+              type: ArgumentType.NUMBER,
+              defaultValue: 50
+            }
+          }
+        }
+      ],
+      menus: {
+        video_menu: this.getVideoMenu(),
+        classification_interval_menu: this.getClassificationIntervalMenu(),
+        classification_menu: this.getClassificationMenu()
+      }
+    };
+  }
+
+  getResult1() {
+    return this.results[0] ? this.results[0]['label'] : '';
+  }
+
+  getResult2() {
+    return this.results[1] ? this.results[1]['label'] : '';
+  }
+
+  getResult3() {
+    return this.results[2] ? this.results[2]['label'] : '';
+  }
+
+  getConfidence1() {
+    return this.results[0] ? this.results[0]['confidence'] : '';
+  }
+
+  getConfidence2() {
+    return this.results[1] ? this.results[1]['confidence'] : '';
+  }
+
+  getConfidence3() {
+    return this.results[2] ? this.results[2]['confidence'] : '';
+  }
+
+  whenReceived(args) {
+    if (this.when_received) {
+      setTimeout(() => {
+        this.when_received = false;
+      }, HAT_TIMEOUT);
+      return true;
+    }
+    return false;
+  }
+
+  toggleClassification(args) {
+    if (this.actionRepeated()) {
+      return
+    };
+
+    let state = args.CLASSIFICATION_STATE;
+    if (this.timer) {
+      clearTimeout(this.timer);
+    }
+    if (state === 'on') {
+      this.timer = setInterval(() => {
+        this.classify();
+      }, this.interval);
+    }
+  }
+
+  setClassificationInterval(args) {
+    if (this.actionRepeated()) {
+      return
+    };
+
+    if (this.timer) {
+      clearTimeout(this.timer);
+    }
+
+    this.interval = args.CLASSIFICATION_INTERVAL * 1000;
+    this.timer = setInterval(() => {
+      this.classify();
+    }, this.interval);
+  }
+
+  activateImageclass(args) {
+    if (!this.runtime.ioDevices.video.videoReady) {
+      alert('Il faut d\'abord activer la vidéo');
+    } else {
+      this.detect();
+    }
+
+  }
+
+  classify() {
+    this.classifier.classify(this.video, (err, results) => {
+      if (err) {
+        console.error(err);
+      } else {
+        this.when_received = true;
+        this.results = results;
+      }
+    });
+  }
+
+  actionRepeated() {
+    let currentTime = Date.now();
+    if (this.blockClickedAt && (this.blockClickedAt + 250) > currentTime) {
+      console.log('Please do not repeat trigerring this block.');
+      this.blockClickedAt = currentTime;
+      return true;
+    } else {
+      this.blockClickedAt = currentTime;
+      return false;
+    }
+  }
+
+  // Menu pour gérer l'état de la caméra vidéo
+  get VIDEO_MENU() {
+    return [
+      'onback', 'onfront', 'video_on_flipped', 'off'
+    ].map(key => ({
+      text: Message[key][this.locale],
+      value: key
+    }));
+  }
+
+  getClassificationIntervalMenu() {
+    return [{
+        text: '5',
+        value: '5'
+      },
+      {
+        text: '2',
+        value: '2'
+      },
+      {
+        text: '1',
+        value: '1'
+      },
+      {
+        text: '0.5',
+        value: '0.5'
+      }
+    ]
+  }
+
+  getClassificationMenu() {
+    return [{
+        text: Message.off[this.locale],
+        value: 'off'
+      },
+      {
+        text: Message.on[this.locale],
+        value: 'on'
+      }
+    ]
+  }
+
+  // Fonction permettant d'activer la vidéo et de changer de caméra
+  videoToggle(args) {
+    if (this.actionRepeated()) {
+      return
+    };
+    switch (args.VIDEO_STATE) {
+      case 'off':
+        this.runtime.ioDevices.video.disableVideo();
+        break;
+      case 'onback':
+        this.runtime.ioDevices.video.enableVideo('environment');
+        this.runtime.ioDevices.video.mirror = false;
+        this.active = true;
+        break;
+      case 'onfront':
+        this.runtime.ioDevices.video.enableVideo('user');
+        this.runtime.ioDevices.video.mirror = true;
+        this.active = true;
+        break;
+      default:
+        this.runtime.ioDevices.video.mirror = !this.runtime.ioDevices.video.mirror;
+    }
+
+  }
+
+  // Fonction permettant de changer la transparence d'affichage de la caméra sur la scène
+  setVideoTransparency(args) {
+    const transparency = Cast.toNumber(args.TRANSPARENCY);
+    this.globalVideoTransparency = transparency;
+    this.runtime.ioDevices.video.setPreviewGhost(transparency);
+  }
+
+  // Fonction permettant de définir la langue de l'extension en fonction de la langue définit dans Scratch.
+  // Si la traduction d'une langue n'est pas disponible dans l'extension, c'est l'anglais qui est choisi
+  setLocale() {
+    let locale = formatMessage.setup().locale;
+    return AvailableLocales.includes(locale) ? locale : 'en';
+  }
+}
+
+module.exports = Scratch3ImageClassifierBlocks;
\ No newline at end of file
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_ml/index.js b/node_modules/scratch-vm/src/extensions/scratch3_ml/index.js
new file mode 100644
index 0000000..f42c894
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_ml/index.js
@@ -0,0 +1,942 @@
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const log = require('../../util/log');
+const ml5 = require('ml5');
+
+
+let formatMessage = require('format-message');
+
+
+const HAT_TIMEOUT = 100;
+
+const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDgwIDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zOnNlcmlmPSJodHRwOi8vd3d3LnNlcmlmLmNvbS8iIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MS41OyI+CiAgICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCg1LjUxODIyLDAsMCwxMC45Mjg1LC04MTguMDQ3LC0yOTIuODAyKSI+CiAgICAgICAgPHJlY3QgeD0iMTIzLjU5NCIgeT0iMTguMTY5IiB3aWR0aD0iNjYuMzEyIiBoZWlnaHQ9IjMzLjEzNyIgc3R5bGU9ImZpbGw6cmdiKDEzLDE4OSwxNDApO3N0cm9rZTpyZ2IoMTMsMTg5LDE0MCk7c3Ryb2tlLXdpZHRoOjAuMTJweDsiLz4KICAgIDwvZz4KICAgIDxwYXRoIGlkPSJ0b2lsZSIgZD0iTTQwLDVMMjcuOTM5LDI2LjM5OUwzLjg2LDMxLjI1N0wyMC40ODQsNDkuMzQxTDE3LjY2NCw3My43NDNMNDAsNjMuNTJMNjIuMzM2LDczLjc0M0w1OS41MTYsNDkuMzQxTDc2LjE0LDMxLjI1N0w1Mi4wNjEsMjYuMzk5TDQwLDVaIiBzdHlsZT0iZmlsbDp1cmwoI19MaW5lYXIxKTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6d2hpdGU7c3Ryb2tlLXdpZHRoOjNweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0OyIvPgogICAgPGcgaWQ9Ik1MIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM5LjExNzYsNTMpIj4KICAgICAgICA8dGV4dCB4PSItMTcuOTdweCIgeT0iMHB4IiBzdHlsZT0iZm9udC1mYW1pbHk6J0V1cGhlbWlhVUNBUycsICdFdXBoZW1pYSBVQ0FTJywgc2Fucy1zZXJpZjtmb250LXNpemU6MjhweDtmaWxsOndoaXRlOyI+TTx0c3BhbiB4PSIzLjUwNXB4ICIgeT0iMHB4ICI+TDwvdHNwYW4+PC90ZXh0PgogICAgPC9nPgogICAgPGRlZnM+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJfTGluZWFyMSIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjAiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEzLjkzMzUsMTIuOTMzNSwtMTIuOTMzNSwxMy45MzM1LDM2LjE3MTEsMzcuMTU4NSkiPjxzdG9wIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6cmdiKDIwMiwzNCwzNCk7c3RvcC1vcGFjaXR5OjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOnJnYigwLDg4LDI1NSk7c3RvcC1vcGFjaXR5OjEiLz48L2xpbmVhckdyYWRpZW50PgogICAgPC9kZWZzPgo8L3N2Zz4K';
+
+const Message = {
+    toggle_classification: {
+    'en': 'turn classification [CLASSIFICATION_STATE]',
+    'fr': 'définir la classification sur [CLASSIFICATION_STATE]',
+    'de': 'Klassifikation auf setzen [CLASSIFICATION_STATE]'
+
+  },
+  on: {
+    'en': 'on',
+    'fr': 'démarrer',
+    'de': 'starten'
+  },
+  off: {
+    'en': 'off',
+    'fr': 'arrêter',
+    'de': 'stoppen'
+  },
+    video_toggle: {
+    'en': 'turn video [VIDEO_STATE]',
+    'fr': 'mettre caméra sur [VIDEO_STATE]',
+    'de': 'schalte Video [VIDEO_STATE]'
+  },
+   onfront: {
+    'en': 'front camera on',
+    'fr': 'allumer caméra avant',
+    'de':'Frontkamera einschalten'
+  },
+  onback: {
+    'en': 'back camera on',
+    'fr': 'allumer caméra arrière',
+    'de':'Rückfahrkamera einschalten'
+  },
+  video_on_flipped: {
+    'en': 'flip camera image',
+    'fr': 'retourner l\'image de la caméra',
+    'de': 'Kameraspiegel'
+  },
+  train: {
+    'en': 'train label [LABEL]',
+    'fr': 'entraîner étiquette [LABEL]',
+    'de': 'Etikett trainieren [LABEL]'
+  },
+  first_training_warning: {
+    'en': 'The first training will take a while, so do not click again and again.',
+    'fr': 'Le premier entraînement prend du temps, ne pas lancer le processus une seconde fois.',
+    'de': 'Das erste Training braucht Zeit, starten Sie den Prozess nicht ein zweites Mal.'
+  },
+  when_received_block: {
+    'en': 'when received label:[LABEL]',
+    'fr': 'quand je reçois l\'étiquette [LABEL]',
+    'de': 'wenn ich das Etikett erhalte [LABEL]'
+  },
+  label_block: {
+    'en': 'label',
+    'fr': 'étiquette',
+    'de': 'Etikett'
+  },
+  counts_label_1: {
+    'en': 'training counts of label 1',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 1',
+    'de': 'Trainingszählungen von Etikett 1'
+  },
+  counts_label_2: {
+    'en': 'training counts of label 2',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 2',
+    'de': 'Trainingszählungen von Etikett 2'
+  },
+  counts_label_3: {
+    'en': 'training counts of label 3',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 3',
+    'de': 'Trainingszählungen von Etikett 3'
+  },
+  counts_label_4: {
+    'en': 'training counts of label 4',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 4',
+    'de': 'Trainingszählungen von Etikett 4'
+  },
+  counts_label_5: {
+    'en': 'training counts of label 5',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 5',
+    'de': 'Trainingszählungen von Etikett 5'
+  },
+  counts_label_6: {
+    'en': 'training counts of label 6',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 6',
+    'de': 'Trainingszählungen von Etikett 6'
+  },
+  counts_label_7: {
+    'en': 'training counts of label 7',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 7',
+    'de': 'Trainingszählungen von Etikett 7'
+  },
+  counts_label_8: {
+    'en': 'training counts of label 8',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 8',
+    'de': 'Trainingszählungen von Etikett 8'
+  },
+  counts_label_9: {
+    'en': 'training counts of label 9',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 9',
+    'de': 'Trainingszählungen von Etikett 9'
+  },
+  counts_label_10: {
+    'en': 'training counts of label 10',
+    'fr': 'nombre d\'entraînements pour l\'étiquette 10',
+    'de': 'Trainingszählungen von Etikett 10'
+  },
+  any: {
+    'en': 'any',
+    'fr': 'n\'importe laquelle',
+    'de': 'jede'
+  },
+  all: {
+    'en': 'all',
+    'fr': 'tous',
+    'de': 'alle'
+  },
+  reset: {
+    'en': 'reset training of label:[LABEL]',
+    'fr': 'supprimer l\'entraînement de l\'étiquette [LABEL]',
+    'de': 'Zurücksetzen der Ausbildung des Etiketts:[LABEL]'
+  },
+  download_learning_data: {
+    'en': 'download learning data',
+    'fr': 'télécharger les données d\'entraînement',
+    'de': 'Lerndaten herunterladen'
+  },
+  upload_learning_data: {
+    'en': 'upload learning data',
+    'fr': 'récupérer les données d\'entraînement',
+    'de': 'Lerndaten hochladen'
+  },
+  upload: {
+    'en': 'Upload',
+    'fr': 'Récupérer',
+    'de':'Hochladen'
+  },
+  uploaded: {
+    'en': 'The upload is complete.',
+    'fr': 'La récupération est terminée.',
+    'de': 'Der Upload ist abgeschlossen.'
+  },
+  upload_instruction: {
+    'en': 'Select a file and click the upload button.',
+    'fr': 'Sélectionner un fichier et cliquer sur le bouton "Récupérer"',
+'de': 'Wählen Sie eine Datei aus und klicken Sie auf die Schaltfläche Hochladen.'
+  },
+  confirm_reset: {
+    'en': 'Are you sure to reset ?',
+    'fr':'Etes-vous sûr de vouloir supprimer l\'entraînement ?',
+    'de': 'Sind Sie sicher, dass Sie zurücksetzen wollen ?'
+  },
+
+  set_classification_interval: {
+    'en': 'Label once every [CLASSIFICATION_INTERVAL] seconds',
+    'fr': 'Reconnaître l\'étiquette toutes les [CLASSIFICATION_INTERVAL] secondes',
+    'de': 'Etikett einmal alle [CLASSIFICATION_INTERVAL] Sekunden'
+  },
+   title: {
+    'en': 'Machine learning',
+    'fr':'Entrainement machine',
+    'de':'Machine learning'
+  },
+  active: {
+'en': 'classification activated ?',
+'fr':'classification activée ?',
+'de':'Klassifizierung aktiviert ?'
+
+  },
+  active_warning: {
+'en':'Classification is not activated.',
+'fr':'La classification n\'est pas activée.',
+'de':'Die Klassifizierung ist nicht aktiviert.'
+
+
+  }
+}
+
+const AvailableLocales = ['en', 'fr', 'de'];
+
+class Scratch3MLBlocks {
+
+
+  /**
+   * @return {string} - the ID of this extension.
+   */
+  static get EXTENSION_ID() {
+    return 'ml';
+  }
+
+  /**
+   * URL to get this extension.
+   * @type {string}
+   */
+  static get extensionURL() {
+    return extensionURL;
+  }
+
+  /**
+   * Set URL to get this extension.
+   * extensionURL will be reset when the module is loaded from the web.
+   * @param {string} url - URL
+   */
+  static set extensionURL(url) {
+    extensionURL = url;
+  }
+
+
+  // Menu pour gérer l'état de la caméra vidéo
+  get VIDEO_MENU() {
+    return [
+      'onback', 'onfront', 'video_on_flipped', 'off'
+    ].map(key => ({
+      text: Message[key][this.locale],
+      value: key
+    }));
+  }
+
+
+
+  constructor(runtime) {
+    this.runtime = runtime;
+    if (runtime.formatMessage) {
+      // Replace 'formatMessage' to a formatter which is used in the runtime.
+      formatMessage = runtime.formatMessage;
+    }
+
+    this.when_received = false;
+    this.when_received_arr = Array(8).fill(false);
+    this.label = null;
+    this.locale = this.setLocale();
+    this.active = false;
+
+    this.blockClickedAt = null;
+
+    this.counts = null;
+    this.firstTraining = true;
+
+    this.interval = 1000;
+    this.globalVideoTransparency = 0;
+    this.setVideoTransparency({
+        TRANSPARENCY: this.globalVideoTransparency
+    });
+
+    this.canvas = document.querySelector('canvas');
+
+    //this.runtime.ioDevices.video.enableVideo().then(() => {this.input = this.runtime.ioDevices.video.provider.video});
+
+    this.knnClassifier = ml5.KNNClassifier();
+    this.featureExtractor = ml5.featureExtractor('MobileNet', () => {
+      console.log('[featureExtractor] Model Loaded!');
+      this.timer = setInterval(() => {
+        this.classify();
+      }, this.interval);
+    });
+  }
+
+  getInfo() {
+    this.locale = this.setLocale();
+    
+
+    return {
+      id: 'ml',
+      name: Message.title[this.locale],
+      blockIconURI: blockIconURI,
+      blocks: [{
+          opcode: 'toggleClassification',
+          text: Message.toggle_classification[this.locale],
+          blockType: BlockType.COMMAND,
+          arguments: {
+            CLASSIFICATION_STATE: {
+              type: ArgumentType.STRING,
+              menu: 'classification_menu',
+              defaultValue: 'on'
+            }
+          }
+        },
+                                {
+                    opcode: 'activated',
+                    text: Message.active[this.locale],
+                    blockType: BlockType.BOOLEAN
+                },
+        '---',
+        
+{
+          opcode: 'videoToggle',
+          text: Message.video_toggle[this.locale],
+          blockType: BlockType.COMMAND,
+          arguments: {
+            VIDEO_STATE: {
+              type: ArgumentType.STRING,
+              menu: 'video_menu',
+              defaultValue: 'onback'
+            }
+          }
+        },
+        {
+          opcode: 'setVideoTransparency',
+          text: formatMessage({
+              id: 'videoSensing.setVideoTransparency',
+              default: 'set video transparency to [TRANSPARENCY]',
+              description: 'Controls transparency of the video preview layer'
+          }),
+          arguments: {
+              TRANSPARENCY: {
+                  type: ArgumentType.NUMBER,
+                  defaultValue: 50
+              }
+          }
+        },
+        '---',
+        {
+          opcode: 'train',
+          text: Message.train[this.locale],
+          blockType: BlockType.COMMAND,
+          arguments: {
+            LABEL: {
+              type: ArgumentType.STRING,
+              menu: 'train_menu',
+              defaultValue: '1'
+            }
+          }
+        },
+               {
+          opcode: 'whenReceived',
+          text: Message.when_received_block[this.locale],
+          blockType: BlockType.HAT,
+          arguments: {
+            LABEL: {
+              type: ArgumentType.STRING,
+              menu: 'received_menu',
+              defaultValue: 'any'
+            }
+          }
+        },
+                 {
+          opcode: 'getLabel',
+          text: Message.label_block[this.locale],
+          blockType: BlockType.REPORTER
+        },
+               '---',
+        {
+          opcode: 'getCountByLabel1',
+          text: Message.counts_label_1[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel2',
+          text: Message.counts_label_2[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel3',
+          text: Message.counts_label_3[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel4',
+          text: Message.counts_label_4[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel5',
+          text: Message.counts_label_5[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel6',
+          text: Message.counts_label_6[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel7',
+          text: Message.counts_label_7[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel8',
+          text: Message.counts_label_8[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel9',
+          text: Message.counts_label_9[this.locale],
+          blockType: BlockType.REPORTER
+        },
+        {
+          opcode: 'getCountByLabel10',
+          text: Message.counts_label_10[this.locale],
+          blockType: BlockType.REPORTER
+        },
+                '---',
+        {
+          opcode: 'reset',
+          blockType: BlockType.COMMAND,
+          text: Message.reset[this.locale],
+          arguments: {
+            LABEL: {
+              type: ArgumentType.STRING,
+              menu: 'reset_menu',
+              defaultValue: 'all'
+            }
+          }
+        },
+                {
+          opcode: 'setClassificationInterval',
+          text: Message.set_classification_interval[this.locale],
+          blockType: BlockType.COMMAND,
+          arguments: {
+            CLASSIFICATION_INTERVAL: {
+              type: ArgumentType.STRING,
+              menu: 'classification_interval_menu',
+              defaultValue: '1'
+            }
+          }
+        },
+        '---',
+        '---',
+        {
+          opcode: 'download',
+          text: Message.download_learning_data[this.locale],
+          blockType: BlockType.COMMAND
+        },
+        {
+          opcode: 'upload',
+          text: Message.upload_learning_data[this.locale],
+          blockType: BlockType.COMMAND
+        }
+
+
+
+        
+
+      ],
+      menus: {
+        received_menu: {
+          items: this.getMenu('received')
+        },
+        reset_menu: {
+          items: this.getMenu('reset')
+        },
+        train_menu: {
+          items: this.getTrainMenu()
+        },
+        count_menu: {
+          items: this.getTrainMenu()
+        },
+        video_menu: { 
+          acceptReporters: false,
+          items: this.VIDEO_MENU
+        },
+        classification_interval_menu: {
+          acceptReporters: true,
+          items: this.getClassificationIntervalMenu()
+        },
+        classification_menu: this.getClassificationMenu()
+      }
+    };
+  }
+
+  /**
+   * The transparency setting of the video preview stored in a value
+   * accessible by any object connected to the virtual machine.
+   * @type {number}
+   */
+  get globalVideoTransparency () {
+      const stage = this.runtime.getTargetForStage();
+      if (stage) {
+          return stage.videoTransparency;
+      }
+      return 50;
+  }
+
+  set globalVideoTransparency (transparency) {
+      const stage = this.runtime.getTargetForStage();
+      if (stage) {
+          stage.videoTransparency = transparency;
+      }
+      return transparency;
+  }
+
+  addExample1() {
+    this.firstTrainingWarning();
+    let features = this.featureExtractor.infer(this.input);
+    this.knnClassifier.addExample(features, '1');
+    this.updateCounts();
+  }
+
+  addExample2() {
+    this.firstTrainingWarning();
+    let features = this.featureExtractor.infer(this.input);
+    this.knnClassifier.addExample(features, '2');
+    this.updateCounts();
+  }
+
+  addExample3() {
+    this.firstTrainingWarning();
+    let features = this.featureExtractor.infer(this.input);
+    this.knnClassifier.addExample(features, '3');
+    this.updateCounts();
+  }
+
+  train(args) {
+    if (this.active){
+    this.firstTrainingWarning();
+    let features = this.featureExtractor.infer(this.input);
+    this.knnClassifier.addExample(features, args.LABEL);
+    this.updateCounts();
+  }
+  else {alert(Message.active_warning[this.locale]);}
+}
+
+  trainAny(args) {
+    this.train(args);
+  }
+
+  getLabel() {
+    return this.label;
+  }
+
+  whenReceived(args) {
+    if (args.LABEL === 'any') {
+      if (this.when_received) {
+        setTimeout(() => {
+            this.when_received = false;
+        }, HAT_TIMEOUT);
+        return true;
+      }
+      return false;
+    } else {
+      if (this.when_received_arr[args.LABEL]) {
+        setTimeout(() => {
+          this.when_received_arr[args.LABEL] = false;
+        }, HAT_TIMEOUT);
+        return true;
+      }
+      return false;
+    }
+  }
+
+  whenReceivedAny(args) {
+    return this.whenReceived(args);
+  }
+
+  getCountByLabel1() {
+    if (this.counts) {
+      return this.counts['1'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel2() {
+    if (this.counts) {
+      return this.counts['2'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel3() {
+    if (this.counts) {
+      return this.counts['3'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel4() {
+    if (this.counts) {
+      return this.counts['4'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel5() {
+    if (this.counts) {
+      return this.counts['5'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel6() {
+    if (this.counts) {
+      return this.counts['6'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel7() {
+    if (this.counts) {
+      return this.counts['7'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel8() {
+    if (this.counts) {
+      return this.counts['8'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel9() {
+    if (this.counts) {
+      return this.counts['9'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel10() {
+    if (this.counts) {
+      return this.counts['10'];
+    } else {
+      return 0;
+    }
+  }
+
+  getCountByLabel(args) {
+    if (this.counts[args.LABEL]) {
+      return this.counts[args.LABEL];
+    } else {
+      return 0;
+    }
+  }
+
+  reset(args) {
+    if (this.actionRepeated()) { return };
+
+    setTimeout(() => {
+      let result = confirm(Message.confirm_reset[this.locale]);
+      if (result) {
+        if (args.LABEL == 'all') {
+          this.knnClassifier.clearAllLabels();
+          for (let label in this.counts) {
+            this.counts[label] = 0;
+          }
+        } else {
+          if (this.counts[args.LABEL] > 0) {
+            this.knnClassifier.clearLabel(args.LABEL);
+            this.counts[args.LABEL] = 0;
+          }
+        }
+      }
+    }, 1000);
+  }
+
+  resetAny(args) {
+    this.reset(args);
+  }
+
+  download() {
+    if (this.actionRepeated()) { return };
+    let fileName = String(Date.now());
+    this.knnClassifier.save(fileName);
+  }
+
+  upload() {
+    if (this.actionRepeated()) { return };
+    let width = 480;
+    let height = 200;
+    let left = window.innerWidth / 2;
+    let top = window.innerHeight / 2;
+    let x = left - (width / 2);
+    let y = top - (height / 2);
+    let uploadWindow = window.open('', null, 'top=' + y + ',left=' + x + ',width=' + width + ',height=' + height);
+    uploadWindow.document.open();
+    uploadWindow.document.write('<html><head><title>' + Message.upload_learning_data[this.locale] + '</title></head><body style="background-color: rgb(219, 219, 219); margin-top: 30%; margin-left: 0; margin-right: 0;">');
+    uploadWindow.document.write('<div style="margin-left: auto; margin-right: auto; font-size: 2em; font-family: arial; text-align: center; background-color: rgb(200, 200, 200); padding-bottom: 20px;">');
+    uploadWindow.document.write('<p style="background-color: rgb(25, 94, 189); padding: 20px; overflow: hidden; color: white;">' + Message.upload_instruction[this.locale] + '</p>');
+    uploadWindow.document.write('<p style="margin-left: auto; margin-right: auto; width: 40%;"><input type="file" style="font-size: 0.5em; transform: scale(2,2); padding: 20px;" id="upload-files"></p>');
+    uploadWindow.document.write('<p><input type="button" style="font-size: 1.3em; border-radius: 30px; padding: 25px; background-color: rgb(19, 27, 180); color: white; border: 2px solid rgb(0, 26, 85);" value="' + Message.upload[this.locale] + '" id="upload-button"></p>');
+    uploadWindow.document.write('</div></body></html>');
+    uploadWindow.document.close();
+
+    uploadWindow.document.getElementById("upload-button").onclick = () =>{
+      this.uploadButtonClicked(uploadWindow);
+    }
+  }
+
+  toggleClassification (args) {
+    let state = args.CLASSIFICATION_STATE;
+    if (this.timer) {
+      clearTimeout(this.timer);
+    }
+    if (state === 'on') {
+     
+            if (!this.runtime.ioDevices.video.videoReady){
+        alert('Il faut d\'abord activer la vidéo'); }
+        else {
+           this.active=true;
+    this.input = this.runtime.ioDevices.video.provider.video;
+
+      this.timer = setInterval(() => {
+        this.classify();
+      }, this.interval);
+    }}
+    else {this.active=false;}
+  }
+
+  setClassificationInterval (args) {
+    if (this.timer) {
+      clearTimeout(this.timer);
+    }
+
+    this.interval = args.CLASSIFICATION_INTERVAL * 1000;
+    this.timer = setInterval(() => {
+      this.classify();
+    }, this.interval);
+  }
+
+
+    activated(args, util){
+        return this.active;
+    }
+
+
+
+videoToggle (args) {
+      let state = args.VIDEO_STATE;
+      this.active=false;
+      if (state === 'off') {
+        this.runtime.ioDevices.video.disableVideo();
+        this.poseNet.video = null;
+      } else {
+        if (state === 'onback') {  
+          this.runtime.ioDevices.video.enableVideo('environment');
+          this.runtime.ioDevices.video.mirror = false;
+        }
+        else{
+        if (state === 'onfront') {
+          this.runtime.ioDevices.video.enableVideo('user');
+          this.runtime.ioDevices.video.mirror = true;
+        }
+        else{
+            this.runtime.ioDevices.video.mirror = !this.runtime.ioDevices.video.mirror;
+        }
+
+      }
+        
+
+      }
+    }
+
+
+
+  /**
+   * A scratch command block handle that configures the video preview's
+   * transparency from passed arguments.
+   * @param {object} args - the block arguments
+   * @param {number} args.TRANSPARENCY - the transparency to set the video
+   *   preview to
+   */
+  setVideoTransparency (args) {
+      const transparency = Cast.toNumber(args.TRANSPARENCY);
+      this.globalVideoTransparency = transparency;
+      this.runtime.ioDevices.video.setPreviewGhost(transparency);
+  }
+
+
+
+  uploadButtonClicked(uploadWindow) {
+    let files = uploadWindow.document.getElementById('upload-files').files;
+
+    if (files.length <= 0) {
+      uploadWindow.alert('Please select JSON file.');
+      return false;
+    }
+
+    let fr = new FileReader();
+
+    fr.onload = (e) => {
+      let data = JSON.parse(e.target.result);
+      this.knnClassifier.load(data, () => {
+        console.log('uploaded!');
+
+        this.updateCounts();
+        alert(Message.uploaded[this.locale]);
+      });
+    }
+
+    fr.onloadend = (e) => {
+      uploadWindow.document.getElementById('upload-files').value = "";
+    }
+
+    fr.readAsText(files.item(0));
+    uploadWindow.close();
+  }
+
+  classify() {
+    let numLabels = this.knnClassifier.getNumLabels();
+    if (numLabels == 0) return;
+
+    let features = this.featureExtractor.infer(this.input);
+    this.knnClassifier.classify(features, (err, result) => {
+      if (err) {
+        console.error(err);
+      } else {
+        this.label = this.getTopConfidenceLabel(result.confidencesByLabel);
+        this.when_received = true;
+        this.when_received_arr[this.label] = true
+      }
+    });
+  }
+
+  getTopConfidenceLabel(confidences) {
+    let topConfidenceLabel;
+    let topConfidence = 0;
+
+    for (let label in confidences) {
+      if (confidences[label] > topConfidence) {
+        topConfidenceLabel = label;
+      }
+    }
+
+    return topConfidenceLabel;
+  }
+
+  updateCounts() {
+    this.counts = this.knnClassifier.getCountByLabel();
+    console.debug(this.counts);
+  }
+
+  actionRepeated() {
+    let currentTime = Date.now();
+    if (this.blockClickedAt && (this.blockClickedAt + 250) > currentTime) {
+      console.log('Please do not repeat trigerring this block.');
+      this.blockClickedAt = currentTime;
+      return true;
+    } else {
+      this.blockClickedAt = currentTime;
+      return false;
+    }
+  }
+
+  getMenu(name) {
+    let arr = [];
+    let defaultValue = 'any';
+    let text = Message.any[this.locale];
+    if (name == 'reset') {
+      defaultValue = 'all';
+      text = Message.all[this.locale];
+    }
+    arr.push({text: text, value: defaultValue});
+    for(let i = 1; i <= 10; i++) {
+      let obj = {};
+      obj.text = i.toString(10);
+      obj.value = i.toString(10);
+      arr.push(obj);
+    };
+    return arr;
+  }
+
+  getTrainMenu() {
+    let arr = [];
+    for(let i = 1; i <= 10; i++) {
+      let obj = {};
+      obj.text = i.toString(10);
+      obj.value = i.toString(10);
+      arr.push(obj);
+    };
+    return arr;
+  }
+
+
+ 
+
+  getClassificationIntervalMenu() {
+    return [
+      {
+        text: '1',
+        value: '1'
+      },
+      {
+        text: '0.5',
+        value: '0.5'
+      },
+      {
+        text: '0.2',
+        value: '0.2'
+      },
+      {
+        text: '0.1',
+        value: '0.1'
+      }
+    ]
+  }
+
+  getClassificationMenu() {
+    return [
+      {
+        text: Message.off[this.locale],
+        value: 'off'
+      },
+      {
+        text: Message.on[this.locale],
+        value: 'on'
+      }
+    ]
+  }
+
+  firstTrainingWarning() {
+    if (this.firstTraining) {
+      alert(Message.first_training_warning[this.locale]);
+      this.firstTraining = false;
+    }
+  }
+
+
+
+  setLocale() {
+    let locale = formatMessage.setup().locale;
+    if (AvailableLocales.includes(locale)) {
+      return locale;
+    } else {
+      return 'en';
+    }
+  }
+}
+
+exports.blockClass = Scratch3MLBlocks; // loadable-extension needs this line.
+module.exports = Scratch3MLBlocks;
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_music/manifest.js b/node_modules/scratch-vm/src/extensions/scratch3_music/manifest.js
index 327d154..be166a7 100644
--- a/node_modules/scratch-vm/src/extensions/scratch3_music/manifest.js
+++ b/node_modules/scratch-vm/src/extensions/scratch3_music/manifest.js
@@ -1,63 +1,65 @@
 module.exports = {
-    'drums/1-snare.mp3': require('./assets/drums/1-snare.mp3?arrayBuffer'),
-    'drums/2-bass-drum.mp3': require('./assets/drums/2-bass-drum.mp3?arrayBuffer'),
-    'drums/3-side-stick.mp3': require('./assets/drums/3-side-stick.mp3?arrayBuffer'),
-    'drums/4-crash-cymbal.mp3': require('./assets/drums/4-crash-cymbal.mp3?arrayBuffer'),
-    'drums/5-open-hi-hat.mp3': require('./assets/drums/5-open-hi-hat.mp3?arrayBuffer'),
-    'drums/6-closed-hi-hat.mp3': require('./assets/drums/6-closed-hi-hat.mp3?arrayBuffer'),
-    'drums/7-tambourine.mp3': require('./assets/drums/7-tambourine.mp3?arrayBuffer'),
-    'drums/8-hand-clap.mp3': require('./assets/drums/8-hand-clap.mp3?arrayBuffer'),
-    'drums/9-claves.mp3': require('./assets/drums/9-claves.mp3?arrayBuffer'),
-    'drums/10-wood-block.mp3': require('./assets/drums/10-wood-block.mp3?arrayBuffer'),
-    'drums/11-cowbell.mp3': require('./assets/drums/11-cowbell.mp3?arrayBuffer'),
-    'drums/12-triangle.mp3': require('./assets/drums/12-triangle.mp3?arrayBuffer'),
-    'drums/13-bongo.mp3': require('./assets/drums/13-bongo.mp3?arrayBuffer'),
-    'drums/14-conga.mp3': require('./assets/drums/14-conga.mp3?arrayBuffer'),
-    'drums/15-cabasa.mp3': require('./assets/drums/15-cabasa.mp3?arrayBuffer'),
-    'drums/16-guiro.mp3': require('./assets/drums/16-guiro.mp3?arrayBuffer'),
-    'drums/17-vibraslap.mp3': require('./assets/drums/17-vibraslap.mp3?arrayBuffer'),
-    'drums/18-cuica.mp3': require('./assets/drums/18-cuica.mp3?arrayBuffer'),
-    'instruments/1-piano/24.mp3': require('./assets/instruments/1-piano/24.mp3?arrayBuffer'),
-    'instruments/1-piano/36.mp3': require('./assets/instruments/1-piano/36.mp3?arrayBuffer'),
-    'instruments/1-piano/48.mp3': require('./assets/instruments/1-piano/48.mp3?arrayBuffer'),
-    'instruments/1-piano/60.mp3': require('./assets/instruments/1-piano/60.mp3?arrayBuffer'),
-    'instruments/1-piano/72.mp3': require('./assets/instruments/1-piano/72.mp3?arrayBuffer'),
-    'instruments/1-piano/84.mp3': require('./assets/instruments/1-piano/84.mp3?arrayBuffer'),
-    'instruments/1-piano/96.mp3': require('./assets/instruments/1-piano/96.mp3?arrayBuffer'),
-    'instruments/1-piano/108.mp3': require('./assets/instruments/1-piano/108.mp3?arrayBuffer'),
-    'instruments/2-electric-piano/60.mp3': require('./assets/instruments/2-electric-piano/60.mp3?arrayBuffer'),
-    'instruments/3-organ/60.mp3': require('./assets/instruments/3-organ/60.mp3?arrayBuffer'),
-    'instruments/4-guitar/60.mp3': require('./assets/instruments/4-guitar/60.mp3?arrayBuffer'),
-    'instruments/5-electric-guitar/60.mp3': require('./assets/instruments/5-electric-guitar/60.mp3?arrayBuffer'),
-    'instruments/6-bass/36.mp3': require('./assets/instruments/6-bass/36.mp3?arrayBuffer'),
-    'instruments/6-bass/48.mp3': require('./assets/instruments/6-bass/48.mp3?arrayBuffer'),
-    'instruments/7-pizzicato/60.mp3': require('./assets/instruments/7-pizzicato/60.mp3?arrayBuffer'),
-    'instruments/8-cello/36.mp3': require('./assets/instruments/8-cello/36.mp3?arrayBuffer'),
-    'instruments/8-cello/48.mp3': require('./assets/instruments/8-cello/48.mp3?arrayBuffer'),
-    'instruments/8-cello/60.mp3': require('./assets/instruments/8-cello/60.mp3?arrayBuffer'),
-    'instruments/9-trombone/36.mp3': require('./assets/instruments/9-trombone/36.mp3?arrayBuffer'),
-    'instruments/9-trombone/48.mp3': require('./assets/instruments/9-trombone/48.mp3?arrayBuffer'),
-    'instruments/9-trombone/60.mp3': require('./assets/instruments/9-trombone/60.mp3?arrayBuffer'),
-    'instruments/10-clarinet/48.mp3': require('./assets/instruments/10-clarinet/48.mp3?arrayBuffer'),
-    'instruments/10-clarinet/60.mp3': require('./assets/instruments/10-clarinet/60.mp3?arrayBuffer'),
-    'instruments/11-saxophone/36.mp3': require('./assets/instruments/11-saxophone/36.mp3?arrayBuffer'),
-    'instruments/11-saxophone/60.mp3': require('./assets/instruments/11-saxophone/60.mp3?arrayBuffer'),
-    'instruments/11-saxophone/84.mp3': require('./assets/instruments/11-saxophone/84.mp3?arrayBuffer'),
-    'instruments/12-flute/60.mp3': require('./assets/instruments/12-flute/60.mp3?arrayBuffer'),
-    'instruments/12-flute/72.mp3': require('./assets/instruments/12-flute/72.mp3?arrayBuffer'),
-    'instruments/13-wooden-flute/60.mp3': require('./assets/instruments/13-wooden-flute/60.mp3?arrayBuffer'),
-    'instruments/13-wooden-flute/72.mp3': require('./assets/instruments/13-wooden-flute/72.mp3?arrayBuffer'),
-    'instruments/14-bassoon/36.mp3': require('./assets/instruments/14-bassoon/36.mp3?arrayBuffer'),
-    'instruments/14-bassoon/48.mp3': require('./assets/instruments/14-bassoon/48.mp3?arrayBuffer'),
-    'instruments/14-bassoon/60.mp3': require('./assets/instruments/14-bassoon/60.mp3?arrayBuffer'),
-    'instruments/15-choir/48.mp3': require('./assets/instruments/15-choir/48.mp3?arrayBuffer'),
-    'instruments/15-choir/60.mp3': require('./assets/instruments/15-choir/60.mp3?arrayBuffer'),
-    'instruments/15-choir/72.mp3': require('./assets/instruments/15-choir/72.mp3?arrayBuffer'),
-    'instruments/16-vibraphone/60.mp3': require('./assets/instruments/16-vibraphone/60.mp3?arrayBuffer'),
-    'instruments/16-vibraphone/72.mp3': require('./assets/instruments/16-vibraphone/72.mp3?arrayBuffer'),
-    'instruments/17-music-box/60.mp3': require('./assets/instruments/17-music-box/60.mp3?arrayBuffer'),
-    'instruments/18-steel-drum/60.mp3': require('./assets/instruments/18-steel-drum/60.mp3?arrayBuffer'),
-    'instruments/19-marimba/60.mp3': require('./assets/instruments/19-marimba/60.mp3?arrayBuffer'),
-    'instruments/20-synth-lead/60.mp3': require('./assets/instruments/20-synth-lead/60.mp3?arrayBuffer'),
-    'instruments/21-synth-pad/60.mp3': require('./assets/instruments/21-synth-pad/60.mp3?arrayBuffer')
+    'drums/1-snare.mp3': require('!arraybuffer-loader!./assets/drums/1-snare.mp3'),
+    'drums/2-bass-drum.mp3': require('!arraybuffer-loader!./assets/drums/2-bass-drum.mp3'),
+    'drums/3-side-stick.mp3': require('!arraybuffer-loader!./assets/drums/3-side-stick.mp3'),
+    'drums/4-crash-cymbal.mp3': require('!arraybuffer-loader!./assets/drums/4-crash-cymbal.mp3'),
+    'drums/5-open-hi-hat.mp3': require('!arraybuffer-loader!./assets/drums/5-open-hi-hat.mp3'),
+    'drums/6-closed-hi-hat.mp3': require('!arraybuffer-loader!./assets/drums/6-closed-hi-hat.mp3'),
+    'drums/7-tambourine.mp3': require('!arraybuffer-loader!./assets/drums/7-tambourine.mp3'),
+    'drums/8-hand-clap.mp3': require('!arraybuffer-loader!./assets/drums/8-hand-clap.mp3'),
+    'drums/9-claves.mp3': require('!arraybuffer-loader!./assets/drums/9-claves.mp3'),
+    'drums/10-wood-block.mp3': require('!arraybuffer-loader!./assets/drums/10-wood-block.mp3'),
+    'drums/11-cowbell.mp3': require('!arraybuffer-loader!./assets/drums/11-cowbell.mp3'),
+    'drums/12-triangle.mp3': require('!arraybuffer-loader!./assets/drums/12-triangle.mp3'),
+    'drums/13-bongo.mp3': require('!arraybuffer-loader!./assets/drums/13-bongo.mp3'),
+    'drums/14-conga.mp3': require('!arraybuffer-loader!./assets/drums/14-conga.mp3'),
+    'drums/15-cabasa.mp3': require('!arraybuffer-loader!./assets/drums/15-cabasa.mp3'),
+    'drums/16-guiro.mp3': require('!arraybuffer-loader!./assets/drums/16-guiro.mp3'),
+    'drums/17-vibraslap.mp3': require('!arraybuffer-loader!./assets/drums/17-vibraslap.mp3'),
+    'drums/18-cuica.mp3': require('!arraybuffer-loader!./assets/drums/18-cuica.mp3'),
+    'instruments/1-piano/24.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/24.mp3'),
+    'instruments/1-piano/36.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/36.mp3'),
+    'instruments/1-piano/48.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/48.mp3'),
+    'instruments/1-piano/60.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/60.mp3'),
+    'instruments/1-piano/72.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/72.mp3'),
+    'instruments/1-piano/84.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/84.mp3'),
+    'instruments/1-piano/96.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/96.mp3'),
+    'instruments/1-piano/108.mp3': require('!arraybuffer-loader!./assets/instruments/1-piano/108.mp3'),
+    'instruments/2-electric-piano/60.mp3': require('!arraybuffer-loader!./assets/instruments/2-electric-piano/60.mp3'),
+    'instruments/3-organ/60.mp3': require('!arraybuffer-loader!./assets/instruments/3-organ/60.mp3'),
+    'instruments/4-guitar/60.mp3': require('!arraybuffer-loader!./assets/instruments/4-guitar/60.mp3'),
+    'instruments/5-electric-guitar/60.mp3': require(
+        '!arraybuffer-loader!./assets/instruments/5-electric-guitar/60.mp3'
+    ),
+    'instruments/6-bass/36.mp3': require('!arraybuffer-loader!./assets/instruments/6-bass/36.mp3'),
+    'instruments/6-bass/48.mp3': require('!arraybuffer-loader!./assets/instruments/6-bass/48.mp3'),
+    'instruments/7-pizzicato/60.mp3': require('!arraybuffer-loader!./assets/instruments/7-pizzicato/60.mp3'),
+    'instruments/8-cello/36.mp3': require('!arraybuffer-loader!./assets/instruments/8-cello/36.mp3'),
+    'instruments/8-cello/48.mp3': require('!arraybuffer-loader!./assets/instruments/8-cello/48.mp3'),
+    'instruments/8-cello/60.mp3': require('!arraybuffer-loader!./assets/instruments/8-cello/60.mp3'),
+    'instruments/9-trombone/36.mp3': require('!arraybuffer-loader!./assets/instruments/9-trombone/36.mp3'),
+    'instruments/9-trombone/48.mp3': require('!arraybuffer-loader!./assets/instruments/9-trombone/48.mp3'),
+    'instruments/9-trombone/60.mp3': require('!arraybuffer-loader!./assets/instruments/9-trombone/60.mp3'),
+    'instruments/10-clarinet/48.mp3': require('!arraybuffer-loader!./assets/instruments/10-clarinet/48.mp3'),
+    'instruments/10-clarinet/60.mp3': require('!arraybuffer-loader!./assets/instruments/10-clarinet/60.mp3'),
+    'instruments/11-saxophone/36.mp3': require('!arraybuffer-loader!./assets/instruments/11-saxophone/36.mp3'),
+    'instruments/11-saxophone/60.mp3': require('!arraybuffer-loader!./assets/instruments/11-saxophone/60.mp3'),
+    'instruments/11-saxophone/84.mp3': require('!arraybuffer-loader!./assets/instruments/11-saxophone/84.mp3'),
+    'instruments/12-flute/60.mp3': require('!arraybuffer-loader!./assets/instruments/12-flute/60.mp3'),
+    'instruments/12-flute/72.mp3': require('!arraybuffer-loader!./assets/instruments/12-flute/72.mp3'),
+    'instruments/13-wooden-flute/60.mp3': require('!arraybuffer-loader!./assets/instruments/13-wooden-flute/60.mp3'),
+    'instruments/13-wooden-flute/72.mp3': require('!arraybuffer-loader!./assets/instruments/13-wooden-flute/72.mp3'),
+    'instruments/14-bassoon/36.mp3': require('!arraybuffer-loader!./assets/instruments/14-bassoon/36.mp3'),
+    'instruments/14-bassoon/48.mp3': require('!arraybuffer-loader!./assets/instruments/14-bassoon/48.mp3'),
+    'instruments/14-bassoon/60.mp3': require('!arraybuffer-loader!./assets/instruments/14-bassoon/60.mp3'),
+    'instruments/15-choir/48.mp3': require('!arraybuffer-loader!./assets/instruments/15-choir/48.mp3'),
+    'instruments/15-choir/60.mp3': require('!arraybuffer-loader!./assets/instruments/15-choir/60.mp3'),
+    'instruments/15-choir/72.mp3': require('!arraybuffer-loader!./assets/instruments/15-choir/72.mp3'),
+    'instruments/16-vibraphone/60.mp3': require('!arraybuffer-loader!./assets/instruments/16-vibraphone/60.mp3'),
+    'instruments/16-vibraphone/72.mp3': require('!arraybuffer-loader!./assets/instruments/16-vibraphone/72.mp3'),
+    'instruments/17-music-box/60.mp3': require('!arraybuffer-loader!./assets/instruments/17-music-box/60.mp3'),
+    'instruments/18-steel-drum/60.mp3': require('!arraybuffer-loader!./assets/instruments/18-steel-drum/60.mp3'),
+    'instruments/19-marimba/60.mp3': require('!arraybuffer-loader!./assets/instruments/19-marimba/60.mp3'),
+    'instruments/20-synth-lead/60.mp3': require('!arraybuffer-loader!./assets/instruments/20-synth-lead/60.mp3'),
+    'instruments/21-synth-pad/60.mp3': require('!arraybuffer-loader!./assets/instruments/21-synth-pad/60.mp3')
 };
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_pm/index.js b/node_modules/scratch-vm/src/extensions/scratch3_pm/index.js
new file mode 100644
index 0000000..3abcc34
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_pm/index.js
@@ -0,0 +1,1391 @@
+const formatMessage = require('format-message');
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const MathUtil = require('../../util/math-util');
+const Variable = require('../../engine/variable');
+/**
+ * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
+ * @type {string}
+ */
+// eslint-disable-next-line max-len
+const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyBpZD0iQ2FscXVlXzEiIGRhdGEtbmFtZT0iQ2FscXVlIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAxNTE3LjIgNDg4LjciPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcC1wYXRoIj48cmVjdCB4PSItMjQ2IiB5PSItMzg4LjciIHdpZHRoPSIyMjE3LjUiIGhlaWdodD0iMjA2My45IiBzdHlsZT0iZmlsbDpub25lIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9ImNsaXAtcGF0aC03Ij48cmVjdCB4PSItNzUuOCIgeT0iLTExMS4zIiB3aWR0aD0iMTkxMy4xIiBoZWlnaHQ9IjE3ODAuNiIgc3R5bGU9ImZpbGw6bm9uZSIvPjwvY2xpcFBhdGg+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMjc5LjQiIGhlaWdodD0iNDg4LjciIHN0eWxlPSJmaWxsOiMyZTYzYTkiLz48Y2lyY2xlIGN4PSIxMjcyLjkiIGN5PSIyNDQuMyIgcj0iMjQ0LjMiIHN0eWxlPSJmaWxsOiMyZTYzYTkiLz48cmVjdCB4PSIyMS43IiB5PSIzMS42IiB3aWR0aD0iNDIwLjkiIGhlaWdodD0iNDIwLjkiIHN0eWxlPSJmaWxsOiNmZmYiLz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoKSI+PHBhdGggZD0iTTI1Ni44LDE3Mi43YTgxLjgsODEuOCwwLDEsMCw4MS44LTgxLjgsODEuODMsODEuODMsMCwwLDAtODEuOCw4MS44bTE3LjQsMEE2NC40LDY0LjQsMCwxLDEsMzM4LjYsMjM3YTY0LjQ5LDY0LjQ5LDAsMCwxLTY0LjQtNjQuMyIgc3R5bGU9ImZpbGw6IzRlNzZhZSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoKSI+PHBhdGggZD0iTTI1Ni44LDE3Mi43YTgxLjgsODEuOCwwLDEsMCw4MS44LTgxLjhBODEuODMsODEuODMsMCwwLDAsMjU2LjgsMTcyLjdabTE3LjQsMEE2NC40LDY0LjQsMCwxLDEsMzM4LjYsMjM3LDY0LjQ5LDY0LjQ5LDAsMCwxLDI3NC4yLDE3Mi43WiIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6Izg4OWNjNztzdHJva2Utd2lkdGg6MnB4Ii8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgpIj48cG9seWdvbiBwb2ludHM9IjM0Mi44IDUzLjkgMzc1LjUgNTMuOSAzNTEuOCA3OC44IDMzMy4zIDc4LjggMzQyLjggNTMuOSIgc3R5bGU9ImZpbGw6IzRlNzZhZSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoKSI+PHBvbHlnb24gcG9pbnRzPSIzNDIuOCA1My45IDM3NS41IDUzLjkgMzUxLjggNzguOCAzMzMuMyA3OC44IDM0Mi44IDUzLjkiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiM4ODljYzc7c3Ryb2tlLXdpZHRoOjJweCIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoKSI+PHBvbHlnb24gcG9pbnRzPSIzMDguOCAxMjguNCAzNjguNiAxMjguNCAzNjguNiAxNDguMyAzMzEuNiAxNDguNCAzMzEuNiAxNjEuMiAzNjYuMiAxNjEuMiAzNjYuMiAxODEuMiAzMzEuNiAxODEuMiAzMzEuNiAxOTQgMzY4LjYgMTk0IDM2OC42IDIxNCAzMDguOCAyMTQgMzA4LjggMTI4LjQiIHN0eWxlPSJmaWxsOiM0ZTc2YWUiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aCkiPjxwb2x5Z29uIHBvaW50cz0iMzA4LjggMTI4LjQgMzY4LjYgMTI4LjQgMzY4LjYgMTQ4LjMgMzMxLjYgMTQ4LjQgMzMxLjYgMTYxLjIgMzY2LjIgMTYxLjIgMzY2LjIgMTgxLjIgMzMxLjYgMTgxLjIgMzMxLjYgMTk0IDM2OC42IDE5NCAzNjguNiAyMTQgMzA4LjggMjE0IDMwOC44IDEyOC40IiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojODg5Y2M3O3N0cm9rZS13aWR0aDoycHgiLz48L2c+PGcgc3R5bGU9Imlzb2xhdGlvbjppc29sYXRlIj48cGF0aCBkPSJNMTQ1LjMxLDE2NC40MkgxMzQuNTZjLTMsMC01LjM4LTEuODEtNS4zOC00LjA2di0xNWMwLTIuMjUsMi40LTQuMDYsNS4zOC00LjA2aDUuMzd2LTQuMjJoLTkuNTl2LTQuMDZoOS41OWMzLDAsNS4zOCwxLjgxLDUuMzgsNC4wNlptLTEwLjc1LTQuMDZoNS4zN3YtMTVoLTUuMzdaIi8+PHBhdGggZD0iTTE2Ni44LDE1OC42NmMwLDMuMzUtMy42Myw2LjA5LTguMDYsNi4wOXMtOC4wNi0yLjc0LTguMDYtNi4wOVYxMzguODJjMC0zLjM1LDMuNjMtNi4wOSw4LjA2LTYuMDlzOC4wNiwyLjc0LDguMDYsNi4wOXYyLjM2aC01LjM3di00LjA2aC01LjM3djIzLjI0aDUuMzd2LTQuMDVoNS4zN1oiLz48cGF0aCBkPSJNMTg4LjMsMTY0LjQySDE3Ny41NWMtMywwLTUuMzctMS44MS01LjM3LTQuMDZ2LTE1YzAtMi4yNSwyLjQtNC4wNiw1LjM3LTQuMDZoNS4zOHYtNC4yMmgtOS41OXYtNC4wNmg5LjU5YzMsMCw1LjM3LDEuODEsNS4zNyw0LjA2Wm0tMTAuNzUtNC4wNmg1LjM4di0xNWgtNS4zOFoiLz48cGF0aCBkPSJNMjA5LjgsMTY0LjQySDE5OS4wNWMtMywwLTUuMzctMS44MS01LjM3LTQuMDZWMTM3LjEyYzAtMi4yNSwyLjQtNC4wNiw1LjM3LTQuMDZoNS4zOHYtNy43OGg1LjM3Wm0tMTAuNzUtNC4wNmg1LjM4VjEzNy4xMmgtNS4zOFoiLz48cGF0aCBkPSJNMjE1LjE4LDEzOC44MmMwLTMuMzUsMy42My02LjA5LDguMDYtNi4wOXM4LjA2LDIuNzQsOC4wNiw2LjA5djEySDIyMC41NXY5LjU5aDUuMzh2LTQuMDVoNS4zN3YyLjM1YzAsMy4zNS0zLjYzLDYuMDktOC4wNiw2LjA5cy04LjA2LTIuNzQtOC4wNi02LjA5Wm0xNS40Ny0xMi4xMkwyMTUuODMsMTMxdi0zLjc5bDE0LjgyLTQuMjdabS0xMC4xLDIwaDUuMzh2LTkuNTloLTUuMzhaIi8+PHBhdGggZD0iTTIzNi42OCwxMzMuMDZoMjEuNWMzLDAsNS4zNywxLjgxLDUuMzcsNC4wNnYyNy4zaC01LjM3di0yNy4zSDI1Mi44djI3LjNoLTUuMzd2LTI3LjNoLTUuMzh2MjcuM2gtNS4zN1oiLz48cGF0aCBkPSJNMjc0LjMsMTI5LjMzaC01LjM3di00LjA1aDUuMzdabTAsMzUuNDJhNyw3LDAsMCwxLTMuNzctMS4yMSwzLjQ5LDMuNDksMCwwLDEtMS42LTIuODVWMTMzLjA2aDUuMzdaIi8+PHBhdGggZD0iTTI3OS42OCwxMzguODJjMC0zLjM1LDMuNjMtNi4wOSw4LjA2LTYuMDlzOC4wNiwyLjc0LDguMDYsNi4wOXYxMkgyODUuMDV2OS41OWg1LjM4di00LjA1aDUuMzd2Mi4zNWMwLDMuMzUtMy42Myw2LjA5LTguMDYsNi4wOXMtOC4wNi0yLjc0LTguMDYtNi4wOVptNS4zNyw3Ljg5aDUuMzh2LTkuNTloLTUuMzhaIi8+PC9nPjxnIHN0eWxlPSJpc29sYXRpb246aXNvbGF0ZSI+PHBhdGggZD0iTTE0NiwxNzhjMC0zLjM0LDMuNjMtNi4wOCw4LjA2LTYuMDhzOC4wNywyLjc0LDguMDcsNi4wOHY0LjQ0aC01LjM4di02LjE0SDE1MS40djMxaDUuMzdWMTkzLjg4aC0yLjMydi00LjA2aDcuN3YxNS44NGMwLDMuMzUtMy42Myw2LjA5LTguMDcsNi4wOVMxNDYsMjA5LDE0NiwyMDUuNjZaIi8+PHBhdGggZD0iTTE2Ny41MiwxODQuMTJjMC0yLjI1LDIuNC00LjA2LDUuMzgtNC4wNmg1LjM3djQuMDZIMTcyLjl2MjcuM2gtNS4zOFoiLz48cGF0aCBkPSJNMTgyLjM0LDE4NS44MmMwLTMuMzUsMy42My02LjA5LDguMDYtNi4wOXM4LjA2LDIuNzQsOC4wNiw2LjA5djEySDE4Ny43MXY5LjU5aDUuMzh2LTQuMDVoNS4zN3YyLjM1YzAsMy4zNS0zLjYzLDYuMDktOC4wNiw2LjA5cy04LjA2LTIuNzQtOC4wNi02LjA5Wm01LjM3LDcuODloNS4zOHYtOS41OWgtNS4zOFoiLz48cGF0aCBkPSJNMjAzLjg0LDE4MC4wNmgxMC43NWMzLDAsNS4zNywxLjgxLDUuMzcsNC4wNnYyNy4zaC01LjM3di0yNy4zaC01LjM4djI3LjNoLTUuMzdaIi8+PHBhdGggZD0iTTIyNS4zNCwxODUuODJjMC0zLjM1LDMuNjMtNi4wOSw4LjA2LTYuMDlzOC4wNiwyLjc0LDguMDYsNi4wOXYxOS44NGMwLDMuMzUtMy42Myw2LjA5LTguMDYsNi4wOXMtOC4wNi0yLjc0LTguMDYtNi4wOVptNS4zNywyMS41NGg1LjM4VjE4NC4xMmgtNS4zOFoiLz48cGF0aCBkPSJNMjQ2Ljg0LDE3Mi4yOGg1LjM3djcuNzhoNS4zOGMzLDAsNS4zNywxLjgxLDUuMzcsNC4wNnYyMy4yNGMwLDIuMjUtMi4zOSw0LjA2LTUuMzcsNC4wNkgyNDYuODRabTUuMzcsMzUuMDhoNS4zOFYxODQuMTJoLTUuMzhaIi8+PHBhdGggZD0iTTI2OC4zNCwxNzJhNyw3LDAsMCwxLDMuNzcsMS4yLDMuNTIsMy41MiwwLDAsMSwxLjYsMi44NXYzNS40MmgtNS4zN1oiLz48cGF0aCBkPSJNMjc5LjA5LDE4NS44MmMwLTMuMzUsMy42My02LjA5LDguMDYtNi4wOXM4LjA2LDIuNzQsOC4wNiw2LjA5djEySDI4NC40NnY5LjU5aDUuMzh2LTQuMDVoNS4zN3YyLjM1YzAsMy4zNS0zLjYzLDYuMDktOC4wNiw2LjA5cy04LjA2LTIuNzQtOC4wNi02LjA5Wm01LjM3LDcuODloNS4zOHYtOS41OWgtNS4zOFoiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTg3LjcsNDA1LjhhMywzLDAsMCwxLTEtLjIsNy41NSw3LjU1LDAsMCwxLTEuMS0xLjRjLS40LS43LS45LTEuNS0xLjMtMi4xaC0uNXYxLjZhMy43OCwzLjc4LDAsMCwwLC4xLDEuMi42Ny42NywwLDAsMCwuNy41di4zSDgxLjR2LS4zYTEuMDcsMS4wNywwLDAsMCwuNi0uMiwxLjQyLDEuNDIsMCwwLDAsLjItLjZ2LTMuOGE5LjMzLDkuMzMsMCwwLDAtLjEtMi4yYy0uMS0uMy0uMy0uNS0uOC0uNXYtLjNoMy42YTIuNjcsMi42NywwLDAsMSwxLjcuNCwxLjk0LDEuOTQsMCwwLDEsLjgsMS42LDIuNDEsMi40MSwwLDAsMS0xLjgsMi4yLDE4Ljc2LDE4Ljc2LDAsMCwxLDEuMiwxLjgsMTEuNzYsMTEuNzYsMCwwLDAsMS4xLDEuNSwxLjMzLDEuMzMsMCwwLDAsLjUuM3YuM2MwLS4xLS4zLS4xLS43LS4xbS0zLjEtNy42YTEuNywxLjcsMCwwLDAtLjcuMXYzaC41YTEuNTUsMS41NSwwLDAsMCwxLjctMS42LDEuNDcsMS40NywwLDAsMC0xLjUtMS41IiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik05MS43LDM5OC40bC0uNS0uMywxLTEuNSwxLjIuMlptMi4yLDcuMmMtLjEuMi0uMi4yLS43LjJIODkuNHYtLjRhLjY4LjY4LDAsMCwwLC43LS43di0zLjlhMi41MSwyLjUxLDAsMCwwLS4xLTEsLjU1LjU1LDAsMCwwLS42LS40di0uM2g0Ljd2MS42aC0uNGMtLjEtLjgtLjQtMS0xLjYtMWgtLjhWNDAyaC41YzEsMCwxLjQtLjIsMS40LS43aC40djJoLS40YzAtLjYtLjMtLjctMS4zLS43aC0uNXYxLjlxMCwuNi4zLjZhNS42NCw1LjY0LDAsMCwwLC43LjFjMS4xLDAsMS41LS4yLDEuNy0xLjFsLjQuMWMtLjMuNi0uNSwxLjItLjYsMS40IiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik05OC4xLDQwMi43aC0uM2wtLjItLjVjLjktLjEsMS41LS41LDEuNS0xLjNhMS4yOSwxLjI5LDAsMCwwLTEuMy0xLjRoLS40djMuNmE1LjgzLDUuODMsMCwwLDAsLjEsMS44LjU1LjU1LDAsMCwwLC42LjR2LjNIOTUuNXYtLjJjLjUsMCwuNi0uMy43LS43di00YTIuNTEsMi41MSwwLDAsMC0uMS0xLC41NS41NSwwLDAsMC0uNi0uNFYzOTloMS4yYy41LDAsMS0uMSwxLjUtLjEsMS40LDAsMi4zLjcsMi4zLDEuOWEyLjE3LDIuMTcsMCwwLDEtMi40LDEuOSIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTA3LjIsMzk5LjZhMS41NSwxLjU1LDAsMCwwLS4yLjh2M2EyLjI0LDIuMjQsMCwwLDEtLjQsMS41LDIuNDYsMi40NiwwLDAsMS0yLjIsMSwyLjkzLDIuOTMsMCwwLDEtMS42LS40LDIuMDksMi4wOSwwLDAsMS0xLTIuMVY0MDBjLS4xLS40LS4zLS41LS43LS42di0uM2gyLjZ2LjNhLjYuNiwwLDAsMC0uNi4zLDEuNzIsMS43MiwwLDAsMC0uMS44djEuOWMwLDEuNywwLDIuMS40LDIuNGExLjI5LDEuMjksMCwwLDAsMS4xLjUsMS40MiwxLjQyLDAsMCwwLDEuNS0xLDcuNyw3LjcsMCwwLDAsLjEtMS45di0xYTUuMzksNS4zOSwwLDAsMC0uMS0xLjcuNTUuNTUsMCwwLDAtLjUtLjN2LS4zaDIuMXYuM2MtLjIsMC0uMywwLS40LjIiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTExMy4zLDQwNS4yYTIuODMsMi44MywwLDAsMS0yLC41aC0yLjZ2LS4zYS42My42MywwLDAsMCwuNy0uN3YtMy40YTUuNzksNS43OSwwLDAsMC0uMS0xLjYuNTUuNTUsMCwwLDAtLjYtLjRWMzk5aDMuNGMuOSwwLDEuOC40LDEuOCwxLjUsMCwuOC0uNSwxLjMtMS40LDEuNWExLjc0LDEuNzQsMCwwLDEsLjgsMy4ybS0yLjItNS42aC0uNXYyLjJoLjVjMSwwLDEuNS0uNCwxLjUtMS4xcy0uNi0xLjEtMS41LTEuMW0uMSwyLjhoLS42djEuNGEyLjgxLDIuODEsMCwwLDAsLjEsMS4xLjcyLjcyLDAsMCwwLC43LjQsMS4xNiwxLjE2LDAsMCwwLDEuMy0xLjMsMS40NSwxLjQ1LDAsMCwwLTEuNS0xLjYiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTExOS42LDQwNS42Yy0uMS4xLS4yLjItLjcuMkgxMTV2LS40YS43Ni43NiwwLDAsMCwuNS0uMmMuMi0uMi4yLS41LjItMS4ydi0yLjVhNS4zOSw1LjM5LDAsMCwwLS4xLTEuOC41NS41NSwwLDAsMC0uNi0uNFYzOTloMi43di4zYS43Ny43NywwLDAsMC0uOC43djMuMmMwLDEuNCwwLDEuNi4xLDEuN3MuMy4yLjguMmEyLjMzLDIuMzMsMCwwLDAsMS4xLS4yYy4zLS4xLjUtLjUuNi0uOWwuNC4xYTIuODEsMi44MSwwLDAsMS0uMywxLjUiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTEyMy4xLDQwNS43aC0yLjR2LS4zYS42My42MywwLDAsMCwuNy0uN3YtNGEyLjUxLDIuNTEsMCwwLDAtLjEtMSwuNTUuNTUsMCwwLDAtLjYtLjRWMzk5aDIuNnYuM2MtLjQsMC0uNi4zLS43Ljd2My4yYTUuODMsNS44MywwLDAsMCwuMSwxLjguNTUuNTUsMCwwLDAsLjYuNHYuM1oiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTEzMi41LDQwNy41YTQuNDIsNC40MiwwLDAsMS0yLjQtLjcsMTQuMzEsMTQuMzEsMCwwLDEtMS41LTEuMSwyLjIsMi4yLDAsMCwxLS44LjEsMy4xOCwzLjE4LDAsMCwxLTMuNC0zLjMsMy40NywzLjQ3LDAsMCwxLDMuNi0zLjYsMy4xOCwzLjE4LDAsMCwxLDMuNCwzLjMsMy4zNywzLjM3LDAsMCwxLTEuOSwzLjJjLjQuMi43LjQsMS4xLjZhNC43OSw0Ljc5LDAsMCwwLDIuNC45LDMsMywwLDAsMCwxLjItLjNsLjEuM2EyLjc5LDIuNzksMCwwLDEtMS44LjZtLTQuNy03LjlhMi4xOSwyLjE5LDAsMCwwLTIuMSwyLjRjMCwxLjcsMSwzLjEsMi4zLDMuMWEyLjIzLDIuMjMsMCwwLDAsMi4xLTIuNWMwLTEuNi0xLTMtMi4zLTMiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTEzOC4zLDM5OS42YTEuNTUsMS41NSwwLDAsMC0uMi44djNhMi4yNCwyLjI0LDAsMCwxLS40LDEuNSwyLjQ2LDIuNDYsMCwwLDEtMi4yLDEsMi45MywyLjkzLDAsMCwxLTEuNi0uNCwyLjA5LDIuMDksMCwwLDEtMS0yLjF2LTEuOWE3LjU3LDcuNTcsMCwwLDAtLjEtMS41Yy0uMS0uNC0uMi0uNS0uNy0uNnYtLjNoMi42di4zYS42LjYsMCwwLDAtLjYuMywxLjcyLDEuNzIsMCwwLDAtLjEuOHYxLjljMCwxLjcsMCwyLjEuMywyLjRhMS4yOSwxLjI5LDAsMCwwLDEuMS41LDEuNDIsMS40MiwwLDAsMCwxLjUtMSw3LjcsNy43LDAsMCwwLC4xLTEuOXYtMWE1LjM5LDUuMzksMCwwLDAtLjEtMS43LjU1LjU1LDAsMCwwLS41LS4zdi0uM2gydi4zYy4yLDAsMCwwLS4xLjIiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTE0NC40LDQwNS42Yy0uMS4yLS4yLjItLjcuMmgtMy44di0uNGEuNjguNjgsMCwwLDAsLjctLjd2LTMuOWEyLjUxLDIuNTEsMCwwLDAtLjEtMSwuNTUuNTUsMCwwLDAtLjYtLjR2LS4zaDQuN3YxLjZoLS40Yy0uMS0uOC0uNC0xLTEuNi0xaC0uN1Y0MDJoLjVjMSwwLDEuNC0uMiwxLjQtLjdoLjR2MmgtLjRjMC0uNi0uMy0uNy0xLjMtLjdIMTQydjEuOXEwLC42LjMuNmMuMiwwLC40LjEuNy4xLDEuMSwwLDEuNS0uMiwxLjctMS4xbC40LjFhOC42NCw4LjY0LDAsMCwwLS43LDEuNCIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTUzLjcsMzk5LjZjMC0uOS0uNS0xLjItMS45LTEuMkgxNTF2Mi43aC42YzEuMSwwLDEuNS0uMiwxLjUtLjhoLjR2Mi40aC0uNGMtLjEtLjctLjQtLjktMS42LS45SDE1MVY0MDRjMCwuNy4xLDEuMi45LDEuM3YuM2gtMy4ydi0uMmMuNiwwLC44LS40LjgtLjl2LTQuOGEzLjc4LDMuNzgsMCwwLDAtLjEtMS4yLjY3LjY3LDAsMCwwLS43LS41di0uM2g1LjZ2MS45WiIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTYwLjMsNDA1LjhhMS41NSwxLjU1LDAsMCwxLS44LS4yLDMuNzgsMy43OCwwLDAsMS0uOS0xLjIsOS45MSw5LjkxLDAsMCwwLTEuMS0xLjdoLS40VjQwNGEyLjUxLDIuNTEsMCwwLDAsLjEsMSwuNTUuNTUsMCwwLDAsLjYuNHYuM2gtMi42di0uM2EuNjguNjgsMCwwLDAsLjctLjd2LTMuMmE2LjI3LDYuMjcsMCwwLDAtLjEtMS44LjU1LjU1LDAsMCwwLS42LS40VjM5OWgzYTIuNDIsMi40MiwwLDAsMSwxLjQuMywxLjYxLDEuNjEsMCwwLDEsLjYsMS4zLDEuODgsMS44OCwwLDAsMS0xLjUsMS44LDEzLDEzLDAsMCwxLDEsMS41LDQuMTQsNC4xNCwwLDAsMCwuOSwxLjIuNTIuNTIsMCwwLDAsLjQuMnYuM2MtLjEuMi0uMy4yLS43LjJtLTIuNS02LjNhMS4yNywxLjI3LDAsMCwwLS42LjF2Mi41aC40YTEuMjksMS4yOSwwLDAsMCwxLjQtMS4zLDEuMjQsMS4yNCwwLDAsMC0xLjItMS4zIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xNjcuNiw0MDUuN2gtMi40di0uM2EuNDcuNDcsMCwwLDAsLjUtLjUsMi4xNCwyLjE0LDAsMCwwLS4xLS42Yy0uMS0uNC0uMi0uNi0uMy0xaC0ybC0uMi42YTIuNCwyLjQsMCwwLDAtLjIsMWMwLC4zLjEuNC40LjR2LjNoLTJ2LS4yYS4zNy4zNywwLDAsMCwuMy0uMSwzLjQzLDMuNDMsMCwwLDAsLjctMS4zbDEtMi40Yy4zLS43LjYtMS43LjktMi42aC43Yy4xLjMuMy44LjQsMS4ybDEuNCwzLjZhOC42Niw4LjY2LDAsMCwwLC41LDEuMi42Ni42NiwwLDAsMCwuNS40bC0uMS4zWm0tMy4zLTQuOWMtLjMuNy0uNiwxLjYtLjgsMkgxNjVaIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xNzQuNywzOTkuNmEzLDMsMCwwLDAtLjIuOXY1LjJoLS43Yy0uNi0uOC0yLTIuNS0yLTIuNS0uMi0uMi0xLjQtMS43LTItMi41djMuNWExLjU1LDEuNTUsMCwwLDAsLjIuOC41NS41NSwwLDAsMCwuNS4zdi4zaC0yLjJ2LS4yYy43LDAsLjctLjYuNy0xLjF2LTMuNWMwLS44LDAtMS0uMi0xLjNzLS4yLS4yLS41LS4yVjM5OWgxLjhhMTUuMTQsMTUuMTQsMCwwLDAsMSwxLjNjMSwxLjIsMS45LDIuMiwyLjcsMy4ydi0yLjFhNC4yLDQuMiwwLDAsMC0uMS0xLjUuNjMuNjMsMCwwLDAtLjYtLjV2LS4zaDIuMnYuM2EuNDUuNDUsMCwwLDAtLjYuMiIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTgxLjYsNDA1LjVhNC40OCw0LjQ4LDAsMCwxLTIsLjRsLS4xLjRoLjJhLjU4LjU4LDAsMCwxLC42LjZjMCwuNS0uNC45LTEuMS45YTEuMjcsMS4yNywwLDAsMS0uNi0uMWwuMS0uNGMuMSwwLC4yLjEuMy4xLjMsMCwuNS0uMS41LS40cy0uMS0uMy0uMi0uMy0uMSwwLS4yLjFsLS4yLS4xLjItLjhhMy42NywzLjY3LDAsMCwxLTIuMS0uOSwzLjU1LDMuNTUsMCwwLDEtMS0yLjVjMC0yLjIsMS40LTMuNSwzLjctMy41YTUuNDEsNS40MSwwLDAsMSwxLjkuM3YxLjVoLS40YTEuNDcsMS40NywwLDAsMC0xLjYtMS4xLDIuMjEsMi4yMSwwLDAsMC0yLjMsMi41YzAsMS44LDEsMy4xLDIuNCwzLjFhMS41MiwxLjUyLDAsMCwwLDEuNi0xLjJsLjQuMWEzLjE0LDMuMTQsMCwwLDEtLjEsMS4zIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xODguNiw0MDUuN2gtMi40di0uM2EuNDcuNDcsMCwwLDAsLjUtLjUsMi4xNCwyLjE0LDAsMCwwLS4xLS42Yy0uMS0uNC0uMi0uNi0uMy0xaC0ybC0uMi42YTguMzgsOC4zOCwwLDAsMC0uMiwxYzAsLjMuMS40LjUuNHYuM2gtMnYtLjJhLjM3LjM3LDAsMCwwLC4zLS4xLDMuNDMsMy40MywwLDAsMCwuNy0xLjNsLjktMi40YTE1Ljc4LDE1Ljc4LDAsMCwwLC45LTIuNmguN2MuMS4zLjMuOC40LDEuMmwxLjQsMy42YTguNjYsOC42NiwwLDAsMCwuNSwxLjIuNjYuNjYsMCwwLDAsLjUuNGwtLjEuM1ptLTMuMy00LjljLS4zLjctLjYsMS42LS44LDJIMTg2WiIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTkxLjgsNDA1LjdoLTIuNHYtLjNjLjUsMCwuNi0uMy43LS43di00YTIuNTEsMi41MSwwLDAsMC0uMS0xLC41NS41NSwwLDAsMC0uNi0uNFYzOTlIMTkydi4zYy0uNCwwLS42LjMtLjcuN3YzLjJhNS44Myw1LjgzLDAsMCwwLC4xLDEuOC41NS41NSwwLDAsMCwuNi40di4zWiIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTk1LDQwNS44YTUuNTUsNS41NSwwLDAsMS0xLjctLjMsNi43NSw2Ljc1LDAsMCwwLS4yLTEuNGwuNC0uMWExLjQ5LDEuNDksMCwwLDAsMS41LDEuMmMuNywwLDEuMi0uNCwxLjItLjlhMS4xNSwxLjE1LDAsMCwwLS44LTFsLTEtLjdhMiwyLDAsMCwxLTEuMS0xLjhjMC0xLjEuOS0xLjgsMi4yLTEuOGEyLjczLDIuNzMsMCwwLDEsMS42LjR2MS4zaC0uNGExLjIyLDEuMjIsMCwwLDAtMS4zLTEuMSwxLDEsMCwwLDAtMS4xLjljMCwuNS4zLjguOSwxLjFsLjguNWMuOC41LDEuMywxLDEuMywxLjgsMCwxLjItLjksMS45LTIuMywxLjkiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTIwMyw0MDUuNmMtLjEuMi0uMi4yLS43LjJoLTMuOHYtLjRjLjQsMCwuNi0uMy43LS43di0zLjlhMi41MSwyLjUxLDAsMCwwLS4xLTEsLjU1LjU1LDAsMCwwLS42LS40di0uM2g0Ljd2MS42aC0uNGMtLjEtLjgtLjQtMS0xLjYtMWgtLjdWNDAyaC40YzEsMCwxLjQtLjIsMS40LS43aC40djJoLS40YzAtLjYtLjMtLjctMS4zLS43aC0uNXYxLjlxMCwuNi4zLjZhNS42NCw1LjY0LDAsMCwwLC43LjFjMS4xLDAsMS41LS4yLDEuNy0xLjFsLjQuMWMtLjMuNi0uNSwxLjItLjYsMS40IiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik04NSwzODguNmMtLjEuMS0uMi4yLS42LjJIODAuOHYtLjJhLjYuNiwwLDAsMCwuNi0uMywxLjg4LDEuODgsMCwwLDAsLjQtMWMuMS0uNS4yLS44LjQtMS44bC4yLS44YTUuNDIsNS40MiwwLDAsMCwuMi0xLjUuNTMuNTMsMCwwLDAtLjYtLjZ2LS4yaDIuNXYuMmEuNi42LDAsMCwwLS42LjMsNi4yMSw2LjIxLDAsMCwwLS43LDIuNmwtLjEuNmMtLjIuOC0uMiwxLjEtLjMsMS40di4zYzAsLjQuMi41LjguNSwxLjEsMCwxLjUtLjIsMS45LTFsLjMuMWExMS4xNCwxMS4xNCwwLDAsMC0uOCwxLjIiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTg3LjksMzgzLjlhLjQ3LjQ3LDAsMCwxLS41LS41LjU4LjU4LDAsMCwxLC42LS42LjQ3LjQ3LDAsMCwxLC41LjUuNjUuNjUsMCwwLDEtLjYuNm0tMS4xLDQuOWEuMjcuMjcsMCwwLDEtLjMtLjMsMS4zNCwxLjM0LDAsMCwxLC4xLS41Yy4xLS41LjMtMS4yLjQtMS42cy4yLS45LjItMSwwLS4yLS4yLS4yYS43Ni43NiwwLDAsMC0uNC4xaC0uMVYzODVhNC41MSw0LjUxLDAsMCwxLDEuMy0uMy4yMi4yMiwwLDAsMSwuMi4yYzAsLjEtLjEuNC0uMiwxLjFsLS4xLjZjLS4yLjktLjMsMS4zLS4zLDEuNGEuMjIuMjIsMCwwLDAsLjIuMiwxLjA5LDEuMDksMCwwLDAsLjUtLjF2LjNhMi42OSwyLjY5LDAsMCwxLTEuMy40IiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik05Mi4yLDM4OC40YTIuMjUsMi4yNSwwLDAsMS0xLjUuNXEtMS4yLDAtMS4yLS4zYTIuMTQsMi4xNCwwLDAsMSwuMS0uNmwuNS0yLjJjLjItLjcuMy0xLjMuNS0yLjFhMy43NSwzLjc1LDAsMCwwLC4xLS44LjIyLjIyLDAsMCwwLS4yLS4yYy0uMSwwLS4zLjEtLjQuMXYtLjNoLjFhNC4wNSw0LjA1LDAsMCwxLDEuMi0uMy4yMi4yMiwwLDAsMSwuMi4yYzAsLjEtLjEuMy0uMiwxLjFsLS4zLDEuM2MtLjEuNC0uMS42LS4yLjdhMi43LDIuNywwLDAsMSwxLjYtLjUuOC44LDAsMCwxLC45LjksMy43LDMuNywwLDAsMS0xLjIsMi41bTAtMy4xYTIuNTQsMi41NCwwLDAsMC0uNy4yLDEsMSwwLDAsMC0uNi41LDEwLDEwLDAsMCwwLS40LDEuMWMtLjEuNi0uMiwxLS4yLDEuMXMuMi4zLjYuM2ExLjM5LDEuMzksMCwwLDAsMS0uNSw0LDQsMCwwLDAsLjctMi4xYzAtLjQtLjItLjYtLjQtLjYiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTk1LjUsMzg3LjJoLS4zdi41YzAsLjUuMi44LjUuOEEzLjYyLDMuNjIsMCwwLDAsOTcsMzg4bC4xLjNhMy44LDMuOCwwLDAsMS0xLjguNmMtLjYsMC0uOS0uNC0uOS0xLDAtMS42LDEuMS0zLDIuMy0zLC42LDAsMSwuMywxLC44LDAsLjgtLjksMS41LTIuMiwxLjVtMS0yYy0uNSwwLTEsLjYtMS4yLDEuNmguMWMuOSwwLDEuNi0uNSwxLjYtMS4xYS40Ny40NywwLDAsMC0uNS0uNSIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTAxLjYsMzg2LjFoLS4zdi0uNGMwLS4yLS4yLS4zLS40LS4zYS43Ni43NiwwLDAsMC0uNC4yLDQuMzIsNC4zMiwwLDAsMC0uNywyLjJsLS4yLjlhMiwyLDAsMCwwLS44LjEsNC40LDQuNCwwLDAsMCwuMi0xbC4yLS45Yy4xLS42LjItMSwuMi0xLjJzLS4xLS4zLS4yLS4zSDk5bC0uMi4xdi0uM2E0LjYsNC42LDAsMCwxLDEuMy0uNGMuMSwwLC4yLDAsLjIuMWEuNi42LDAsMCwwLC4xLjQsMS43NCwxLjc0LDAsMCwxLDEuMS0uNi44Ni44NiwwLDAsMSwuNi4zLDMuNDUsMy40NSwwLDAsMC0uNSwxLjEiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTEwNC45LDM4NS40aC0uOGwtLjQsMmE0LjE4LDQuMTgsMCwwLDAtLjEuNy4yMi4yMiwwLDAsMCwuMi4yLjc2Ljc2LDAsMCwwLC40LS4xaC4xdi4zYTMuOTIsMy45MiwwLDAsMS0xLjMuMy4yNy4yNywwLDAsMS0uMy0uM2MwLS4yLjEtLjQuMS0uN2EzLDMsMCwwLDAsLjItMWwuMy0xLjRoLS41bC4xLS4zYy43LS4xLjktLjYsMS4xLTEuMmwuNS0uMS0uMiwxLjFoLjhaIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xMDcuOSwzODQuMmwtLjMtLjMsMS4yLTEuMy45LjJabS0xLjEsM2gtLjN2LjVjMCwuNS4yLjguNS44YTMuNjIsMy42MiwwLDAsMCwxLjMtLjVsLjEuM2EzLjgsMy44LDAsMCwxLTEuOC42Yy0uNiwwLS45LS40LS45LTEsMC0xLjYsMS4xLTMsMi4zLTMsLjYsMCwxLC4zLDEsLjgsMCwuOC0uOSwxLjUtMi4yLDEuNW0xLTJjLS41LDAtMSwuNi0xLjIsMS42aC4xYy45LDAsMS42LS41LDEuNi0xLjFhLjQ3LjQ3LDAsMCwwLS41LS41IiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xMjQuNiwzODEuNmwtLjMtLjIsMS4yLTEuMy45LjJabTEuOSwyLjFoLS4zdi0uMmMwLS41LS4zLS43LTEuMy0uN0gxMjRjLS4yLjgtLjMsMS41LS41LDIuNGguNGEyLjgxLDIuODEsMCwwLDAsMS4xLS4xLjg1Ljg1LDAsMCwwLC43LS43aC4zYy0uMS42LS4zLDEuNC0uNCwxLjloLS4zdi0uMmMwLS40LS4zLS42LTEuMS0uNmgtLjhjLS4xLjIsMCwwLS4yLDEuMWE1Ljk0LDUuOTQsMCwwLDAtLjEsMS4xYzAsLjMuMi40LjguNCwxLjIsMCwxLjYtLjIsMi0xbC4yLjFjLS4yLjYtLjQsMS4yLS42LDEuM3MtLjIuMS0uNi4xaC0zLjh2LS4yYS42LjYsMCwwLDAsLjYtLjMsMS44OCwxLjg4LDAsMCwwLC40LTFjLjEtLjUuMi0uOC40LTEuOGwuMi0uOGE1LjQyLDUuNDIsMCwwLDAsLjItMS41LjUzLjUzLDAsMCwwLS42LS42di0uMmg0LjRhNy43Miw3LjcyLDAsMCwwLS4yLDEuNSIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTMxLjMsMzg1LjRoLS43YTEuNDIsMS40MiwwLDAsMSwuMi42LDEuNjEsMS42MSwwLDAsMS0xLjcsMS42LjkuOSwwLDAsMS0uNS0uMXEtLjMuMTUtLjMuM2MwLC4xLjEuMi41LjNsLjguMmMuOC4yLDEuMi41LDEuMiwxYTIuMDcsMi4wNywwLDAsMS0yLjMsMS44Yy0xLjEsMC0xLjctLjUtMS43LTEuM3MuNS0xLjEsMS4zLTEuM2MtLjUtLjItLjYtLjMtLjYtLjRzLjMtLjUuOS0uOGExLDEsMCwwLDEtLjQtLjksMS42MSwxLjYxLDAsMCwxLDEuNy0xLjYsMS43LDEuNywwLDAsMSwuNy4xaDEuM1ptLTEuOS0uMmExLjIsMS4yLDAsMCwwLTEsMS4yYzAsLjQuMy44LjYuOC41LDAsLjktLjUuOS0xLjIuMS0uNS0uMS0uOC0uNS0uOG0uMiw0Yy0uMy0uMS0uNy0uMy0xLjEtLjRhMS4zNSwxLjM1LDAsMCwwLTEuMSwxLjIsMSwxLDAsMCwwLDEuMS45LDEuNDgsMS40OCwwLDAsMCwxLjYtMS4yYzAtLjItLjItLjQtLjUtLjUiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTEzNC45LDM4OC44Yy0uMiwwLS4yLS4xLS4zLS42YTMuNDksMy40OSwwLDAsMS0xLjguNmMtLjYsMC0uOS0uMy0uOS0uOGE0Ljc2LDQuNzYsMCwwLDEsLjYtMS44LDIuNDgsMi40OCwwLDAsMSwyLjItMS4zLDYuODgsNi44OCwwLDAsMSwxLjMuMmwtLjEuMmExMC43OCwxMC43OCwwLDAsMC0uNiwyLjhjMCwuMy4xLjQuMi40YTQuMzMsNC4zMywwLDAsMSwuNS0uMXYuM2MtLjQsMC0uOS4xLTEuMS4xbS0uNC0zLjZhMS40LDEuNCwwLDAsMC0xLjEuOCwzLjgxLDMuODEsMCwwLDAtLjYsMS45YzAsLjMuMS41LjQuNWExLjc0LDEuNzQsMCwwLDAsMS4yLS42LDEuNTQsMS41NCwwLDAsMCwuMy0uNyw5LjUxLDkuNTEsMCwwLDAsLjQtMS44Yy0uMiwwLS40LS4xLS42LS4xIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xMzkuMywzODMuMWMtLjMsMS4zLS42LDIuNy0xLDQuMWEzLjQ0LDMuNDQsMCwwLDAtLjEuOS4yMi4yMiwwLDAsMCwuMi4yLDEuMDksMS4wOSwwLDAsMCwuNS0uMXYuM2E1LjA5LDUuMDksMCwwLDEtMS40LjQuMjcuMjcsMCwwLDEtLjMtLjMsMi42OCwyLjY4LDAsMCwxLC4yLS45Yy4zLTEuMy42LTIuNy45LTMuOS4xLS42LjItLjguMi0uOWEuMjIuMjIsMCwwLDAtLjItLjIuNi42LDAsMCwwLS40LjF2LS4zYTMuOTIsMy45MiwwLDAsMSwxLjMtLjMuMjIuMjIsMCwwLDEsLjIuMiw0LjE4LDQuMTgsMCwwLDEtLjEuNyIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTQxLjcsMzgzLjlhLjQ3LjQ3LDAsMCwxLS41LS41LjY1LjY1LDAsMCwxLC42LS42LjQ3LjQ3LDAsMCwxLC41LjUuNjUuNjUsMCwwLDEtLjYuNm0tMS4xLDQuOWEuMjcuMjcsMCwwLDEtLjMtLjMsMS4zNCwxLjM0LDAsMCwxLC4xLS41Yy4xLS41LjMtMS4yLjQtMS42cy4yLS45LjItMWEuMjIuMjIsMCwwLDAtLjItLjIuNzYuNzYsMCwwLDAtLjQuMWgtLjFWMzg1YTQuNTEsNC41MSwwLDAsMSwxLjMtLjNjLjIsMCwuMi4xLjIuMmEzLjg2LDMuODYsMCwwLDEtLjIsMS4xbC0uMS42Yy0uMi45LS4zLDEuMy0uMywxLjRhLjIyLjIyLDAsMCwwLC4yLjIsMS4wOSwxLjA5LDAsMCwwLC41LS4xdi4zYTIuNjksMi42OSwwLDAsMS0xLjMuNCIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTQ1LjUsMzg1LjRoLS44bC0uNCwyYTQuMTgsNC4xOCwwLDAsMC0uMS43LjIyLjIyLDAsMCwwLC4yLjIuNzYuNzYsMCwwLDAsLjQtLjFoLjF2LjNhMy45MiwzLjkyLDAsMCwxLTEuMy4zLjI3LjI3LDAsMCwxLS4zLS4zLDIsMiwwLDAsMSwuMS0uNywzLDMsMCwwLDAsLjItMWwuMy0xLjRoLS41bC4xLS4zYy43LS4xLjktLjYsMS4xLTEuMmwuNS0uMS0uMiwxLjFoLjhaIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xNDguNSwzODQuMmwtLjMtLjMsMS4yLTEuMy45LjJabS0xLjEsM2gtLjN2LjVjMCwuNS4yLjguNS44YTMuNjIsMy42MiwwLDAsMCwxLjMtLjVsLjEuM2EzLjgsMy44LDAsMCwxLTEuOC42Yy0uNiwwLS45LS40LS45LTEsMC0xLjYsMS4xLTMsMi4zLTMsLjYsMCwxLC4zLDEsLjgsMCwuOC0uOSwxLjUtMi4yLDEuNW0xLTJjLS41LDAtMSwuNi0xLjIsMS42aC4xYy45LDAsMS42LS41LDEuNi0xLjFhLjQ3LjQ3LDAsMCwwLS41LS41IiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xNjYuOSwzODMuN2gtLjN2LS4yYS43Ni43NiwwLDAsMC0uMi0uNWMtLjItLjItLjUtLjItMS4zLS4yaC0uN2MtLjIuOC0uMywxLjYtLjUsMi40aC42YzEuMSwwLDEuMy0uMSwxLjUtLjdoLjNhMTAuNjIsMTAuNjIsMCwwLDAtLjQsMS45aC0uM3YtLjJhLjUyLjUyLDAsMCwwLS4yLS40LDEuNjksMS42OSwwLDAsMC0uOS0uMmgtLjZsLS4xLjdhMTEuNjMsMTEuNjMsMCwwLDAtLjMsMS42LjUzLjUzLDAsMCwwLC42LjZ2LjJoLTIuNXYtLjJhLjYuNiwwLDAsMCwuNi0uMywxLjg4LDEuODgsMCwwLDAsLjQtMWMuMS0uNS4yLS44LjQtMS44bC4yLS44Yy4xLS44LjItMS4yLjItMS41YS41My41MywwLDAsMC0uNi0uNnYtLjJoNC4zYTcuODQsNy44NCwwLDAsMS0uMiwxLjQiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTE3MC4yLDM4Ni4xaC0uM3YtLjRjMC0uMi0uMi0uMy0uNC0uM2EuNzYuNzYsMCwwLDAtLjQuMiw0LjMyLDQuMzIsMCwwLDAtLjcsMi4ybC0uMi45YTIsMiwwLDAsMC0uOC4xLDQuNCw0LjQsMCwwLDAsLjItMWwuMi0uOWMuMS0uNi4yLTEsLjItMS4ycy0uMS0uMy0uMi0uM2gtLjJsLS4yLjF2LS4zYTQuNiw0LjYsMCwwLDEsMS4zLS40Yy4xLDAsLjIsMCwuMi4xcy4xLjMuMS40YTEuNzQsMS43NCwwLDAsMSwxLjEtLjYuODYuODYsMCwwLDEsLjYuMywzLjQ1LDMuNDUsMCwwLDAtLjUsMS4xIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xNzQuMSwzODguOGMtLjIsMC0uMi0uMS0uMy0uNmEzLjgsMy44LDAsMCwxLTEuOC42Yy0uNiwwLS45LS4zLS45LS44YTQuNzYsNC43NiwwLDAsMSwuNi0xLjgsMi40OCwyLjQ4LDAsMCwxLDIuMi0xLjMsNi44OCw2Ljg4LDAsMCwxLDEuMy4ydi4yYTEwLjc4LDEwLjc4LDAsMCwwLS42LDIuOGMwLC4zLjEuNC4yLjRhNC4zMyw0LjMzLDAsMCwxLC41LS4xdi4zYy0uNiwwLTEsLjEtMS4yLjFtLS41LTMuNmExLjQsMS40LDAsMCwwLTEuMS44LDMuODEsMy44MSwwLDAsMC0uNiwxLjljMCwuMy4xLjUuNC41YTEuNzQsMS43NCwwLDAsMCwxLjItLjYsMS41NCwxLjU0LDAsMCwwLC4zLS43LDkuNTEsOS41MSwwLDAsMCwuNC0xLjhjLS4yLDAtLjQtLjEtLjYtLjEiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTE3OC43LDM4NS40aC0uOGwtLjQsMmE0LjE4LDQuMTgsMCwwLDAtLjEuNy4yMi4yMiwwLDAsMCwuMi4yLDEuMzQsMS4zNCwwLDAsMCwuNS0uMWguMXYuM2EzLjkyLDMuOTIsMCwwLDEtMS4zLjMuMjcuMjcsMCwwLDEtLjMtLjMsMiwyLDAsMCwxLC4xLS43LDMsMywwLDAsMCwuMi0xbC4zLTEuNGgtLjVsLjEtLjNjLjctLjEuOS0uNiwxLjEtMS4ybC41LS4xLS4zLDEuMWguOFoiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTE4MC42LDM4Ny4yaC0uM2MwLC4yLS4xLjMtLjEuNSwwLC41LjIuOC41LjhhMy42MiwzLjYyLDAsMCwwLDEuMy0uNWwuMS4zYTMuOCwzLjgsMCwwLDEtMS44LjZjLS42LDAtLjktLjQtLjktMSwwLTEuNiwxLjEtMywyLjQtMywuNiwwLDEsLjMsMSwuOCwwLC44LS45LDEuNS0yLjIsMS41bTEtMmMtLjUsMC0xLC42LTEuMiwxLjZoLjFjLjksMCwxLjYtLjUsMS42LTEuMWEuNDcuNDcsMCwwLDAtLjUtLjUiIHN0eWxlPSJmaWxsOiMyMjIyMjEiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBhdGggZD0iTTE4Ni43LDM4Ni4xaC0uM3YtLjRjMC0uMi0uMi0uMy0uNC0uM2EuNTIuNTIsMCwwLDAtLjQuMiw0LjMyLDQuMzIsMCwwLDAtLjcsMi4ybC0uMi45YTIsMiwwLDAsMC0uOC4xLDQuNCw0LjQsMCwwLDAsLjItMWwuMi0uOWMuMS0uNi4yLTEsLjItMS4ycy0uMS0uMy0uMi0uM2gtLjJsLS4yLjF2LS4zYTQuNiw0LjYsMCwwLDEsMS4zLS40Yy4xLDAsLjIsMCwuMi4xcy4xLjMuMS40YTEuNzQsMS43NCwwLDAsMSwxLjEtLjYuODYuODYsMCwwLDEsLjYuMywzLjQ1LDMuNDUsMCwwLDAtLjUsMS4xIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xOTAuNiwzODguOWEuMjcuMjcsMCwwLDEtLjMtLjMsMiwyLDAsMCwxLC4yLS44bC4xLS40YTEyLjI3LDEyLjI3LDAsMCwwLC40LTEuOC4yMi4yMiwwLDAsMC0uMi0uMiwxLjMzLDEuMzMsMCwwLDAtLjcuMyw0LjM1LDQuMzUsMCwwLDAtLjcuNiwyLjE5LDIuMTksMCwwLDAtLjMuOSw2LjA5LDYuMDksMCwwLDAtLjMsMS43LDIuNzcsMi43NywwLDAsMC0uOS4xYy4yLS43LjMtMS4zLjUtMmEzLjg2LDMuODYsMCwwLDAsLjItMS4xYzAtLjItLjEtLjMtLjItLjNhMS4zNCwxLjM0LDAsMCwwLS41LjF2LS4zYTQuMDUsNC4wNSwwLDAsMSwxLjItLjNjLjIsMCwuMy4xLjMuNnYuMWE0LjgsNC44LDAsMCwxLDItLjdjLjMsMCwuNC4xLjQuM2E4LjY3LDguNjcsMCwwLDEtLjMsMS4zLDguMTEsOC4xMSwwLDAsMS0uMywxLjEsMS43NiwxLjc2LDAsMCwwLS4xLjYuMjIuMjIsMCwwLDAsLjIuMiwxLjA5LDEuMDksMCwwLDAsLjUtLjF2LjNhNC4xMiw0LjEyLDAsMCwwLTEuMi4xIiBzdHlsZT0iZmlsbDojMjIyMjIxIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xOTQuNywzODMuOWEuNDcuNDcsMCwwLDEtLjUtLjUuNjUuNjUsMCwwLDEsLjYtLjYuNDcuNDcsMCwwLDEsLjUuNS42NS42NSwwLDAsMS0uNi42bS0xLDQuOWEuMjcuMjcsMCwwLDEtLjMtLjMsMS4zNCwxLjM0LDAsMCwxLC4xLS41Yy4xLS41LjMtMS4yLjQtMS42cy4yLS45LjItMWEuMjIuMjIsMCwwLDAtLjItLjIuNzYuNzYsMCwwLDAtLjQuMWgtLjFWMzg1YTQuNTEsNC41MSwwLDAsMSwxLjMtLjMuMjIuMjIsMCwwLDEsLjIuMmMwLC4xLS4xLjQtLjIsMS4xbC0uMS42Yy0uMi45LS4zLDEuMy0uMywxLjRhLjIyLjIyLDAsMCwwLC4yLjIsMS4wOSwxLjA5LDAsMCwwLC41LS4xdi4zYTMsMywwLDAsMS0xLjMuNCIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTk4LjUsMzg1LjRoLS44bC0uNCwyYTQuMTgsNC4xOCwwLDAsMC0uMS43LjIyLjIyLDAsMCwwLC4yLjIsMS4zNCwxLjM0LDAsMCwwLC41LS4xaC4xdi4zYTMuOTIsMy45MiwwLDAsMS0xLjMuMy4yNy4yNywwLDAsMS0uMy0uMywyLDIsMCwwLDEsLjEtLjcsMywzLDAsMCwwLC4yLTFsLjMtMS40aC0uNWwuMS0uM2MuNy0uMS45LS42LDEuMS0xLjJsLjUtLjEtLjIsMS4xaC44WiIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMjAxLjUsMzg0LjJsLS4zLS4zLDEuMi0xLjMuOS4yWm0tMSwzaC0uM3YuNWMwLC41LjIuOC41LjhhMy42MiwzLjYyLDAsMCwwLDEuMy0uNWwuMS4zYTMuOCwzLjgsMCwwLDEtMS44LjZjLS42LDAtLjktLjQtLjktMSwwLTEuNiwxLjEtMywyLjQtMywuNiwwLDEsLjMsMSwuOGEyLjE5LDIuMTksMCwwLDEtMi4zLDEuNW0uOS0yYy0uNSwwLTEsLjYtMS4yLDEuNmguMWMuOSwwLDEuNi0uNSwxLjYtMS4xYS40Ny40NywwLDAsMC0uNS0uNSIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTU1LjksMzg3YTEuMiwxLjIsMCwxLDAsMC0yLjQsMS4yLDEuMiwwLDAsMCwwLDIuNCIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTE1LjMsMzg3YTEuMiwxLjIsMCwxLDAtMS4yLTEuMiwxLjI5LDEuMjksMCwwLDAsMS4yLDEuMiIgc3R5bGU9ImZpbGw6IzIyMjIyMSIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48bGluZSB4MT0iODEuMyIgeTE9IjM5My4xIiB4Mj0iMjAyLjciIHkyPSIzOTMuMSIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzIyMjIyMTtzdHJva2Utd2lkdGg6MC45NDA5OTk5ODQ3NDEyMTA5cHgiLz48L2c+PGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aC03KSI+PHBvbHlnb24gcG9pbnRzPSI4MS40IDM3Ni42IDgxLjQgMzM1LjcgMjAzIDMzNS44IDIwMyAzNzYuNiA4MS40IDM3Ni42IiBzdHlsZT0iZmlsbDojZmZmIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xMTAuMiwzNjMuOGMuMS0uMi4yLS4yLjMtLjRzMC0uMi0uMS0uMmExLjEyLDEuMTIsMCwwLDAtLjcuOGMwLC4xLjEuMS4yLjFzLjEtLjEuMy0uMyIgc3R5bGU9ImZpbGw6I2ZmZiIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTYwLjcsMzUyLjhhOC41NSw4LjU1LDAsMCwwLTEuNiwwLDExLjY5LDExLjY5LDAsMCwwLTIsLjYsNi4wOCw2LjA4LDAsMCwxLDEuOC0uOSw3LjM3LDcuMzcsMCwwLDEsMS40LS40LDMsMywwLDAsMSwxLjYtLjFjLjUuMiwxLjIuMiwxLjMuNS4yLjYtLjMsMS4xLS44LDEuNS0uMS4yLjMuMy4zLjVhLjcxLjcxLDAsMCwxLS42LjNjLS4yLjEtLjQuNC0uNi42LjIsMCwwLC4zLjIuMy0uNC41LjIsMS40LS40LDEuNmEzLjc1LDMuNzUsMCwwLDEtMi4xLDBjLjQtLjEuOC4xLDEuMS0uM3YtLjZjMC0uMS0uMS0uMS0uMi0uMWEuMzEuMzEsMCwwLDEtLjIuMS40NS40NSwwLDAsMC0uMy0uNCwxLjU0LDEuNTQsMCwwLDEtMS40LS42LDEuMTgsMS4xOCwwLDAsMSwuOC0uMWMuMywwLC4yLS41LjUtLjZoLjNjLjYtLjcsMS43LS45LDEuOS0xLjcsMC0uMS0uNi0uMS0xLS4yIiBzdHlsZT0iZmlsbDojOWI5YTlhIi8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xMjcuNywzNzUuOGExMi4yLDEyLjIsMCwwLDAsMS43LS43di4yYzEuNC0uNiwyLjQtMS44LDMuOC0yLjIuMSwwLC4zLjIuNS4xLjgtLjcsMS44LTEuNiwzLTEuNCwwLC4xLDAsLjIuMS4ycy4yLDAsLjItLjFhNy42Myw3LjYzLDAsMCwxLTEuMS44Yy0uMS4xLDAsLjIuMS4yLjUtLjIuNy0uNiwxLjItLjctLjEuMS0uMS4zLS4yLjRhMjYuODEsMjYuODEsMCwwLDAtNC41LDQuNGgtMi45YzAtLjEsMC0uMi0uMS0uMi0zLjMuMy02LjQuMi05LjcuMiwxLjktLjMsMy43LS44LDUuNi0xYTE5LjUzLDE5LjUzLDAsMCwwLDIuMy0uMiIgc3R5bGU9ImZpbGw6IzJiNDQ5MCIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNODEuNCwzMzUuOGMwLDMuNi4xLDcuMiwwLDEwLjktLjMsMTAuMS4yLDIwLjEsMCwzMC4zLDkuMywwLDE4LjQuMiwyNy43LDAsLjctMS41LDIuNi0xLjMsNC0xLjkuNS0uMiwxLC4xLDEuNSwwYTEuMDgsMS4wOCwwLDAsMSwuOC4yYy0xLC42LTEuOSwxLjItMi45LDEuOGExNC4yLDE0LjIsMCwwLDAsNC42LDAsMTEuMywxMS4zLDAsMCwwLDIuMi0xLjEsMTQuMTcsMTQuMTcsMCwwLDAtMS44LjhjLS4xLDAtLjQuMS0uNC0uMXMuNC0uMy42LS41Yy4xLDAsLjIsMCwuMi4xLDMtMi4zLDctMS44LDEwLjUtMywuMy0uMi41LS40LjgtLjYuNS0uMi44LS42LDEuNC0uOWE0Ljc0LDQuNzQsMCwwLDAsMS42LTIuMS4zNS4zNSwwLDAsMC0uMS0uMiwxNS4zLDE1LjMsMCwwLDEtNC4xLDMuMWMtMS45LDEtNC4xLjgtNi4xLDEuMS4xLS4yLjMtLjIuNS0uMiwwLS4zLjItLjQuNC0uNmguM2MuMSwwLC4xLS4yLjItLjJzLjUtLjEuNC0uMWMtLjMtLjQtLjguMy0xLjMsMCwuMi0uMi4xLS41LjMtLjZoLjRhLjcuNywwLDAsMSwuMi0uNGMxLjQtLjgsMi43LTEuNSw0LTIuMi0uMywwLS41LjMtLjcuMS4yLDAsMC0uMy4yLS4zLDEtLjMsMS45LS44LDIuOS0xLjItLjQsMC0uNy4zLTEsMCwuMi0uMS4zLS4zLjUtLjN2LS4zYzAtLjEuMS0uMS4yLS4xYS4zNS4zNSwwLDAsMS0uMi0uMWMuMS0uMi40LS4xLjYtLjMtLjEsMC0uMywwLS4zLS4xYTEuNzQsMS43NCwwLDAsMSwxLjItLjZjLS4xLS4yLS40LDAtLjQtLjJzLjEtLjEuMi0uMWgtLjJjLS4yLS4xLS4xLS4zLS4xLS40YTQuOTIsNC45MiwwLDAsMCwuOC0yLjJjLS4xLDAtLjIsMC0uMi0uMUE3LjkzLDcuOTMsMCwwLDEsMTI3LDM2NWgtLjVhMS44MSwxLjgxLDAsMCwxLTEuNi0uMSw3LjA1LDcuMDUsMCwwLDEtLjktLjcsMTIsMTIsMCwwLDAtMi4zLTEuMSwyMS40MSwyMS40MSwwLDAsMC03LjEtMSwxMS40NiwxMS40NiwwLDAsMSwzLjMtLjksMTMuMDYsMTMuMDYsMCwwLDEsNC43LS45LDIuNzIsMi43MiwwLDAsMC0uOSwwLDE0LjM4LDE0LjM4LDAsMCwwLTQsLjYsMjYuODEsMjYuODEsMCwwLDEtMi43LjdjLS42LjItLjguNy0xLjUuN1YzNjJhNS4yNCw1LjI0LDAsMCwxLDMuNS0yLjMsMTYsMTYsMCwwLDEsNC45LjJjMS4yLjEsMi4zLjQsMy41LjYuNSwwLC42LjguOS44LjYuMiwxLjEsMCwxLjcuNCwwLS4yLS4xLS40LDAtLjYuNC0uNC44LjEsMS4yLS4xLjctLjUtLjYtMS4zLTEtMS45YS4zNS4zNSwwLDAsMSwuMS0uMiw5LjYyLDkuNjIsMCwwLDAsMi4yLDEuOGMuNS4yLDEuNi41LDEuNC0uMWExOC42LDE4LjYsMCwwLDAtMi4xLTIuOHYtLjRjLS4yLDAtLjItLjEtLjMtLjJ2LS40Yy0uNC0uMi0uMy0uNi0uNS0uOC0uMy0uNS0uMS0xLjEtLjMtMS43YTkuMzYsOS4zNiwwLDAsMS0uNC0xLjZjLS4zLTEuNi0uNi0zLS44LTQuNS0uMi0xLjgsMS0zLjEsMS45LTQuN2E4LjIsOC4yLDAsMCwxLDIuNi0zLDguNTgsOC41OCwwLDAsMSwxLjgtM2MuOC0xLDIuMS0xLjQsMy4yLTJtLTIzLDI2LjhjLjEsMCwuMywwLC4zLjFhLjg4Ljg4LDAsMCwxLS43LjksOSw5LDAsMCwxLDIuMi42Yy0uMS4yLS4zLjEtLjQuMS41LjMsMSwuMSwxLjUuNS0uMy4zLS42LDAtLjgsMCwyLjkuOCw1LjksMS41LDguMywzLjNhMjMuNjIsMjMuNjIsMCwwLDEtNi40LDEuOSwxLjQ4LDEuNDgsMCwwLDEtLjctLjFjMCwuMSwwLC4zLS4xLjMtLjQsMC0uNywwLS45LjJhMS4wNSwxLjA1LDAsMCwxLTEuMiwwYy0uMS0uMS4zLDAsLjQtLjJoLS44Yy0uMSwwLS4xLS4xLS4xLS4yLS41LjEtMSwuMy0xLjUuNC0uNy4yLTEuMi43LTEuOS44LTEsLjQtMS45LDEuMi0zLDEuNi0uMSwwLS4xLS4xLS4xLS4yLjEtLjMuNS0uNC43LS42LDAtLjEsMC0uMi0uMS0uMmExNS40NiwxNS40NiwwLDAsMSwyLjctMi40di0uM2MuMy0uNC43LS42LjktMWExLjgsMS44LDAsMCwxLC45LS44Yy0uMS0uMS0uMy0uMS0uMy0uMy0uNCwwLS43LjItMS4xLS4xYS44Ni44NiwwLDAsMSwuNi0uM2MtLjEsMC0uMiwwLS4yLS4xcy4yLS40LjUtLjVhMi4xLDIuMSwwLDAsMCwxLjEtLjRjLS42LS4xLTEuNC4yLTItLjJhMy45MiwzLjkyLDAsMCwxLDIuMi0yLjhtMS4yLTMuN2EuMzcuMzcsMCwwLDEtLjMtLjEuMzcuMzcsMCwwLDAsLjEtLjNjLS45LDEtMi4yLDEuNS0zLDIuNy0uNi45LS45LDIuMS0yLjEsMi40LS40LjEuMS0uMy0uMS0uMmEzMSwzMSwwLDAsMC03LjEsNi40LjM1LjM1LDAsMCwxLS4xLS4yLDQxLDQxLDAsMCwwLDMtNC43LDEzLDEzLDAsMCwwLDMuMS0yLjYsMTguNDgsMTguNDgsMCwwLDEsNS4yLTQuMSwzLjMyLDMuMzIsMCwwLDEsMi40LjFjLS4yLjQtLjcuMy0xLjEuNiIgc3R5bGU9ImZpbGw6IzJiNDQ5MCIvPjwvZz48ZyBzdHlsZT0iY2xpcC1wYXRoOnVybCgjY2xpcC1wYXRoLTcpIj48cGF0aCBkPSJNMTY0LjMsMzcxLjFjLjItLjcuNS0xLjQuMS0yLS42LS44LjYtMS4xLjktMS43cy0uMi0uNy0uMy0xLjJjLS4xLS4yLS41LS4xLS43LS40LjctLjMsMS43LS44LDEuMi0xLjctLjMtLjUtLjctMS4yLS4yLTEuNy43LS40LDEuNy0uMywxLjktLjkuNS0xLjEtLjYtMi0xLjEtM2ExMywxMywwLDAsMC0xLTEuNSw3LjUsNy41LDAsMCwxLTEtMmMtLjMtLjcuMS0xLjQuMS0yLjFhMTIuMzQsMTIuMzQsMCwwLDAtLjctNC4yLDE1LjE5LDE1LjE5LDAsMCwxLS42LTIsMi4yMiwyLjIyLDAsMCwwLS41LTEuMS42My42MywwLDAsMSwwLS42Yy40LS4zLjctLjYsMS4xLS45YTEsMSwwLDAsMC0uNC0xLjRjLS42LS4zLS42LjctMSwuOGgtLjNjLS4xLS4zLjEtLjQuMy0uNiwwLS4xLDAtLjMtLjEtLjMtLjQsMC0uNy0uMS0uOC0uM2E3LjYxLDcuNjEsMCwwLDAtMy42LTIuNSw0LjI1LDQuMjUsMCwwLDAsMS4xLjIsMy4wNiwzLjA2LDAsMCwwLDEuOS0uMmMuNS0uMi42LS45LjctMS40cy0uMS0uOS0uMy0xLjJhNS44MSw1LjgxLDAsMCwwLTEuOS0xLjZoNDRjLjEsMTMuNy0uMSwyNy41LS4yLDQxLjItMTcuNC4zLTM0LjcsMC01Mi4xLDBBOS4xMiw5LjEyLDAsMCwxLDE1NCwzNzJhNSw1LDAsMCwxLDEuMy0uNGMxLjYsMCwzLjIuNSw0LjcuNmExLjQyLDEuNDIsMCwwLDEsLjYuMiwzLjY3LDMuNjcsMCwwLDAsMS44LS4xLDIsMiwwLDAsMCwxLjktMS4yIiBzdHlsZT0iZmlsbDojYzIyMTI2Ii8+PC9nPjxnIHN0eWxlPSJjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgtNykiPjxwYXRoIGQ9Ik0xMTcuNiwzNzAuOGMtLjQuMi0xLC4yLTEuMS42LS4xLjIuMy4xLjUuMS42LS4zLDEuNCwwLDItLjYtLjItLjItLjUtLjEtLjctLjRhNC44OCw0Ljg4LDAsMCwwLS43LjMiIHN0eWxlPSJmaWxsOiNmZmYiLz48L2c+PGcgc3R5bGU9Imlzb2xhdGlvbjppc29sYXRlIj48cGF0aCBkPSJNODQuMjQsMjgwdjQuODhhNS41MSw1LjUxLDAsMCwwLC4xNywxLjc3LDEuMjMsMS4yMywwLDAsMCwuNTguNTksMy45LDMuOSwwLDAsMCwxLjU3LjIydi40N0g3OHYtLjQ3YTMuNjYsMy42NiwwLDAsMCwxLjU3LS4yMywxLjI1LDEuMjUsMCwwLDAsLjU4LS41OCw1LjUxLDUuNTEsMCwwLDAsLjE3LTEuNzdWMjczLjU5YTUuNTUsNS41NSwwLDAsMC0uMTctMS43OCwxLjIzLDEuMjMsMCwwLDAtLjU4LS41OUE0LDQsMCwwLDAsNzgsMjcxdi0uNDhoNy43N2ExNi4zNSwxNi4zNSwwLDAsMSw0LjQ0LjQ0LDQuNDUsNC40NSwwLDAsMSwyLjI5LDEuNjEsNC4zOCw0LjM4LDAsMCwxLC44OSwyLjc1LDQuMTgsNC4xOCwwLDAsMS0xLjMzLDMuMTgsNS40OSw1LjQ5LDAsMCwxLTIuMzgsMS4ybDQsNS44OUE5LjI3LDkuMjcsMCwwLDAsOTQuODIsMjg3YTIuMDUsMi4wNSwwLDAsMCwxLjE3LjQ0di40N0g5MC43M0w4NS4zNCwyODBabTAtOC41M3Y3LjYyaC43YTcuNTMsNy41MywwLDAsMCwyLjU3LS4zMywyLjYsMi42LDAsMCwwLDEuMzQtMS4xOCw0LjUxLDQuNTEsMCwwLDAsLjQ4LTIuMjIsNC4xNCw0LjE0LDAsMCwwLS44OS0yLjk0LDMuODMsMy44MywwLDAsMC0yLjg4LS45NVoiLz48cGF0aCBkPSJNMTAyLjY1LDI3MS41M3Y3LjA5SDEwM2EyLjYsMi42LDAsMCwwLDIuMy0xLDYuNTcsNi41NywwLDAsMCwuOTEtMy4wN2guNDd2OS4xMWgtLjQ3YTYuNzksNi43OSwwLDAsMC0uNjItMi40NCwyLjc0LDIuNzQsMCwwLDAtMS4xLTEuMjgsNC4yLDQuMiwwLDAsMC0xLjgzLS4zMnY0LjlhNy4yMyw3LjIzLDAsMCwwLC4xMiwxLjc2LDEsMSwwLDAsMCwuNDQuNTIsMS45MywxLjkzLDAsMCwwLDEsLjIxaDFhNS44Nyw1Ljg3LDAsMCwwLDMuNzYtMS4xMyw2LjMyLDYuMzIsMCwwLDAsMi0zLjQ0aC40NWwtLjc1LDUuNTNIOTYuMjh2LS40N2guNTVhMi4yLDIuMiwwLDAsMCwxLjE3LS4yNywxLjE4LDEuMTgsMCwwLDAsLjUtLjYyLDUuNTYsNS41NiwwLDAsMCwuMTMtMS42MlYyNzMuNTFhOS43Miw5LjcyLDAsMCwwLS4wNi0xLjQ1LDEuMTcsMS4xNywwLDAsMC0uNDYtLjY5LDIsMiwwLDAsMC0xLjI4LS4zNmgtLjU1di0uNDhoMTR2NS4xNWgtLjQ2YTYuNDcsNi40NywwLDAsMC0xLTIuNzEsMy43MiwzLjcyLDAsMCwwLTEuODMtMS4yMSw5LjcxLDkuNzEsMCwwLDAtMi41OS0uMjNabTUuMjgtNi45NEwxMDMuODUsMjY5aC0xLjA2bDEuNDMtNC40NVoiLz48cGF0aCBkPSJNMTMwLDI3MC4xM3Y2LjE0aC0uNDVhNy44OCw3Ljg4LDAsMCwwLTIuNDgtMy44Myw1LjcxLDUuNzEsMCwwLDAtMy42MS0xLjMxLDQuNTYsNC41NiwwLDAsMC0zLjEyLDEuMSw2LDYsMCwwLDAtMS43NywzLjA2LDE2LDE2LDAsMCwwLS41Miw0LDE1LjIzLDE1LjIzLDAsMCwwLC41Nyw0LjM5LDUsNSwwLDAsMCwxLjgzLDIuNzcsNS4xMiw1LjEyLDAsMCwwLDMsLjg5LDUuODgsNS44OCwwLDAsMCwxLjIzLS4xNCw4Ljc4LDguNzgsMCwwLDAsMS4zMS0uMzl2LTMuNjJhNCw0LDAsMCwwLS4xNC0xLjMzLDEuMjcsMS4yNywwLDAsMC0uNTYtLjU0LDIuMDcsMi4wNywwLDAsMC0xLS4yNWgtLjQzdi0uNDdIMTMydi40N2EzLjM3LDMuMzcsMCwwLDAtMS4yOC4yNywxLjMsMS4zLDAsMCwwLS41Ny42NiwzLjg5LDMuODksMCwwLDAtLjExLDEuMTl2My42MmExNS43MywxNS43MywwLDAsMS0zLjMzLDEuMTIsMTcsMTcsMCwwLDEtMy42LjM4LDEwLjA4LDEwLjA4LDAsMCwxLTQtLjY3LDkuNzksOS43OSwwLDAsMS0yLjc3LTEuNzcsOC4zOSw4LjM5LDAsMCwxLTEuODktMi40Nyw5LjYxLDkuNjEsMCwwLDEsMS43OS0xMC42LDguOTMsOC45MywwLDAsMSw2LjY3LTIuNzEsMTEsMTEsMCwwLDEsMi4yNS4yMSwxMS4zNywxMS4zNywwLDAsMSwxLjc2LjU4LDcuMyw3LjMsMCwwLDAsMS40My40OCwxLDEsMCwwLDAsLjY0LS4yNiwyLjQ0LDIuNDQsMCwwLDAsLjU1LTFaIi8+PHBhdGggZD0iTTE0MS41MSwyODcuNDZ2LjQ3aC04Ljc0di0uNDdoLjU1YTIuMjcsMi4yNywwLDAsMCwxLjE4LS4yNywxLjIxLDEuMjEsMCwwLDAsLjQ5LS42Miw1LjU2LDUuNTYsMCwwLDAsLjEzLTEuNjJWMjczLjUxYTYuMDUsNi4wNSwwLDAsMC0uMTMtMS42NywxLjIxLDEuMjEsMCwwLDAtLjU1LS41OCwyLjExLDIuMTEsMCwwLDAtMS4xMi0uMjVoLS41NXYtLjQ4aDguNzRWMjcxSDE0MWEyLjIsMi4yLDAsMCwwLTEuMTcuMjcsMS4xNywxLjE3LDAsMCwwLS41MS42MSw1LjY1LDUuNjUsMCwwLDAtLjEzLDEuNjJWMjg1YTUuNTMsNS41MywwLDAsMCwuMTQsMS42NywxLjMzLDEuMzMsMCwwLDAsLjU1LjU5LDIuMjQsMi4yNCwwLDAsMCwxLjEyLjI1WiIvPjxwYXRoIGQ9Ik0xNTEuODUsMjcwLjI5YTguMTYsOC4xNiwwLDAsMSw2LjQ5LDIuNDIsOC44OSw4Ljg5LDAsMCwxLDIuNSw2LjQ2QTkuNTIsOS41MiwwLDAsMSwxNTksMjg1YTguMTYsOC4xNiwwLDAsMS03LDMuMzQsOC4zMSw4LjMxLDAsMCwxLTctMy4xOCw5LjQ3LDkuNDcsMCwwLDEtMS45NS02LDguODUsOC44NSwwLDAsMSwyLjUzLTYuNDZBNy45Miw3LjkyLDAsMCwxLDE1MS44NSwyNzAuMjlabS4xNS44MmEzLjc2LDMuNzYsMCwwLDAtMy40OSwyLjQ0LDEzLjQ0LDEzLjQ0LDAsMCwwLTEsNS43NHEwLDQuNDUsMS41MSw2LjU5YTMuMzcsMy4zNywwLDAsMCwyLjkzLDEuNDksMy40MSwzLjQxLDAsMCwwLDIuMTItLjY1LDUuMTgsNS4xOCwwLDAsMCwxLjY5LTIuNjIsMTUuMTgsMTUuMTgsMCwwLDAsLjYxLTQuNywxNi4zMSwxNi4zMSwwLDAsMC0uNjItNS4xNyw1LjE0LDUuMTQsMCwwLDAtMS41Ny0yLjQyQTMuNjEsMy42MSwwLDAsMCwxNTIsMjcxLjExWiIvPjxwYXRoIGQ9Ik0xNjgsMjcwLjUzbDguMjUsMTAuNzl2LTcuNDhhMy42NiwzLjY2LDAsMCwwLS40My0yLjEyLDIuMzYsMi4zNiwwLDAsMC0yLS43MXYtLjQ4aDUuNTNWMjcxYTQsNCwwLDAsMC0xLjQzLjM2LDEuNDcsMS40NywwLDAsMC0uNTYuNzMsNSw1LDAsMCwwLS4yMSwxLjc0djE0LjQ5aC0uNDJsLTExLjMxLTE0LjQ5VjI4NC45YTIuNSwyLjUsMCwwLDAsLjY2LDIsMi4zOCwyLjM4LDAsMCwwLDEuNTEuNTNoLjR2LjQ3SDE2Mi4xdi0uNDdhMi42MywyLjYzLDAsMCwwLDEuOTItLjU5LDIuODcsMi44NywwLDAsMCwuNTQtMlYyNzIuNjJsLS4zNS0uNDZhMy41LDMuNSwwLDAsMC0uOTQtLjkxLDIuNywyLjcsMCwwLDAtMS4xNy0uMjR2LS40OFoiLz48cGF0aCBkPSJNMTk1LjQxLDI4M0gxODkuNWwtLjcsMS42OWEzLjk0LDMuOTQsMCwwLDAtLjM1LDEuNCwxLjE3LDEuMTcsMCwwLDAsLjU3LDEuMDgsNC41NSw0LjU1LDAsMCwwLDEuNjQuMzF2LjQ3SDE4NS4xdi0uNDdhMi41MiwyLjUyLDAsMCwwLDEuNDgtLjc4LDEwLjY2LDEwLjY2LDAsMCwwLDEuNDMtMi42M2w2LTEzLjg4aC4yM2w2LDE0LjI3YTguODUsOC44NSwwLDAsMCwxLjQyLDIuNTUsMS45MywxLjkzLDAsMCwwLDEuMTkuNDd2LjQ3aC04LjA5di0uNDdoLjMzYTIuNDUsMi40NSwwLDAsMCwxLjM3LS4yOS42OC42OCwwLDAsMCwuMjctLjU5LDEuNiwxLjYsMCwwLDAtLjA4LS40Nyw5LjIyLDkuMjIsMCwwLDAtLjM3LTFabS0uNDItMS0yLjQ5LTYtMi41Nyw2WiIvPjxwYXRoIGQ9Ik0yMjAsMjcwLjEzdjZoLS40OGE2LjQ4LDYuNDgsMCwwLDAtMi0zLjYxLDUsNSwwLDAsMC0zLjM1LTEuMjYsNC43OSw0Ljc5LDAsMCwwLTIuODcuOTQsNS40Nyw1LjQ3LDAsMCwwLTEuOTIsMi40NSwxMS42MSwxMS42MSwwLDAsMC0uNzcsNC4zMSwxNC45MSwxNC45MSwwLDAsMCwuNTcsNC4yNSw1LjY0LDUuNjQsMCwwLDAsMS43NywyLjksNC44NCw0Ljg0LDAsMCwwLDMuMTMsMSw1Ljk0LDUuOTQsMCwwLDAsMi45LS43MiwxMC4xOSwxMC4xOSwwLDAsMCwyLjc2LTIuNDd2MS41YTkuMSw5LjEsMCwwLDEtMi45MiwyLjIxLDguNiw4LjYsMCwwLDEtMy41Ni42OSw5Ljg0LDkuODQsMCwwLDEtNC43Ni0xLjEyLDcuNjgsNy42OCwwLDAsMS0zLjItMy4yMSw5LjEyLDkuMTIsMCwwLDEtMS4xMy00LjQ1LDkuNTUsOS41NSwwLDAsMSwxLjI1LTQuNzIsOC45Myw4LjkzLDAsMCwxLDMuMzgtMy40Niw4Ljc5LDguNzksMCwwLDEsNC41Mi0xLjI0LDkuOSw5LjksMCwwLDEsMy43Mi44LDUuNDUsNS40NSwwLDAsMCwxLjQ1LjQ2LjkxLjkxLDAsMCwwLC42OC0uMywxLjcxLDEuNzEsMCwwLDAsLjM4LTFaIi8+PHBhdGggZD0iTTIzMS44OSwyODNIMjI2bC0uNywxLjY5YTMuOTQsMy45NCwwLDAsMC0uMzUsMS40LDEuMTcsMS4xNywwLDAsMCwuNTcsMS4wOCw0LjU1LDQuNTUsMCwwLDAsMS42NC4zMXYuNDdoLTUuNTZ2LS40N2EyLjUyLDIuNTIsMCwwLDAsMS40OC0uNzgsMTAuNjYsMTAuNjYsMCwwLDAsMS40My0yLjYzbDYtMTMuODhoLjIzbDYsMTQuMjdhOC44NSw4Ljg1LDAsMCwwLDEuNDIsMi41NSwxLjkzLDEuOTMsMCwwLDAsMS4xOS40N3YuNDdoLTguMDl2LS40N2guMzNhMi40NSwyLjQ1LDAsMCwwLDEuMzctLjI5LjY4LjY4LDAsMCwwLC4yNy0uNTksMS42LDEuNiwwLDAsMC0uMDgtLjQ3LDkuMjIsOS4yMiwwLDAsMC0uMzctMVptLS40Mi0xTDIyOSwyNzZsLTIuNTcsNloiLz48cGF0aCBkPSJNMjQwLDI4Ny45M3YtLjQ3aC41NmEyLjEzLDIuMTMsMCwwLDAsMS4xMS0uMjQsMS41MiwxLjUyLDAsMCwwLC41OC0uNjUsNi42Myw2LjYzLDAsMCwwLC4xMS0xLjYyVjI3My41MWE1LjksNS45LDAsMCwwLS4xNC0xLjY3LDEuMjEsMS4yMSwwLDAsMC0uNTUtLjU4LDIuMDcsMi4wNywwLDAsMC0xLjExLS4yNUgyNDB2LS40OGg3LjQ5YTExLjQ3LDExLjQ3LDAsMCwxLDQuODIuODUsNy4yMyw3LjIzLDAsMCwxLDMuMzksMy4xNCw5Ljg2LDkuODYsMCwwLDEsMS4xNSw0Ljc2LDkuNjcsOS42NywwLDAsMS0uNTcsMy4zOCw4LDgsMCwwLDEtMS40NywyLjU2LDcuMTQsNy4xNCwwLDAsMS0yLjA3LDEuNjEsMTEuMDUsMTEuMDUsMCwwLDEtMi44OC45NSwxMy40MywxMy40MywwLDAsMS0yLjM3LjE1Wm02LjM4LTE2LjQxdjEzLjU3YTQuODcsNC44NywwLDAsMCwuMSwxLjMzLjcuNywwLDAsMCwuMzMuMzcsMS45MiwxLjkyLDAsMCwwLDEsLjE5LDMuNzEsMy43MSwwLDAsMCwzLjE1LTEuNDZjMS0xLjMyLDEuNDgtMy4zNiwxLjQ4LTYuMTRhMTEuODEsMTEuODEsMCwwLDAtMS01LjM0LDQuNDEsNC40MSwwLDAsMC0yLjA1LTIuMTRBNy44NSw3Ljg1LDAsMCwwLDI0Ni4zMywyNzEuNTJaIi8+PHBhdGggZD0iTTI2NC43NCwyNzEuNTN2Ny4wOWguMzNhMi42MiwyLjYyLDAsMCwwLDIuMzEtMSw2LjU3LDYuNTcsMCwwLDAsLjkxLTMuMDdoLjQ3djkuMTFoLS40N2E3LDcsMCwwLDAtLjYyLTIuNDQsMi44LDIuOCwwLDAsMC0xLjEtMS4yOCw0LjIsNC4yLDAsMCwwLTEuODMtLjMydjQuOWE3LjIzLDcuMjMsMCwwLDAsLjEyLDEuNzYsMSwxLDAsMCwwLC40NC41MiwxLjkxLDEuOTEsMCwwLDAsMSwuMjFoMWE1Ljg5LDUuODksMCwwLDAsMy43Ni0xLjEzLDYuMzEsNi4zMSwwLDAsMCwyLTMuNDRoLjQ2bC0uNzUsNS41M0gyNTguMzd2LS40N2guNTVhMi4yMywyLjIzLDAsMCwwLDEuMTctLjI3LDEuMTIsMS4xMiwwLDAsMCwuNDktLjYyLDUuMDgsNS4wOCwwLDAsMCwuMTQtMS42MlYyNzMuNTFhOS43Miw5LjcyLDAsMCwwLS4wNi0xLjQ1LDEuMjIsMS4yMiwwLDAsMC0uNDYtLjY5LDIsMiwwLDAsMC0xLjI4LS4zNmgtLjU1di0uNDhoMTR2NS4xNWgtLjQ3YTYuMzUsNi4zNSwwLDAsMC0xLTIuNzEsMy43MiwzLjcyLDAsMCwwLTEuODMtMS4yMSw5Ljc2LDkuNzYsMCwwLDAtMi41OS0uMjNabTUuMjgtNi45NEwyNjUuOTQsMjY5aC0xLjA2bDEuNDMtNC40NVoiLz48cGF0aCBkPSJNMjg2Ljc0LDI4Mmw0LjU0LTExLjQ3aDYuODFWMjcxaC0uNTRhMi4yOCwyLjI4LDAsMCwwLTEuMTkuMjcsMS4yNSwxLjI1LDAsMCwwLS40OS42LDUuMzQsNS4zNCwwLDAsMC0uMTQsMS42VjI4NWE1LjksNS45LDAsMCwwLC4xNCwxLjY3LDEuMjgsMS4yOCwwLDAsMCwuNTUuNTksMi4yOCwyLjI4LDAsMCwwLDEuMTMuMjVoLjU0di40N2gtOC43M3YtLjQ3aC41NGEyLjI0LDIuMjQsMCwwLDAsMS4xOC0uMjcsMS4yOCwxLjI4LDAsMCwwLC41LS42Miw1LjU2LDUuNTYsMCwwLDAsLjEzLTEuNjJWMjcyLjA2bC02LjQxLDE1Ljg3SDI4NWwtNi41MS0xNS43NnYxMi4yNmExMS42OSwxMS42OSwwLDAsMCwuMDYsMS41OCwxLjg1LDEuODUsMCwwLDAsLjcsMSwyLjgxLDIuODEsMCwwLDAsMS42OC40MXYuNDdoLTUuNzJ2LS40N2guMTdhMi43NSwyLjc1LDAsMCwwLDEtLjE5LDEuNzEsMS43MSwwLDAsMCwuNzMtLjUzLDIuNjYsMi42NiwwLDAsMCwuMzgtLjk0YzAtLjA5LDAtLjUzLDAtMS4zMXYtMTFhNS45Miw1LjkyLDAsMCwwLS4xMy0xLjY1LDEuMjcsMS4yNywwLDAsMC0uNTYtLjU3LDIuMTQsMi4xNCwwLDAsMC0xLjEyLS4yNWgtLjUzdi0uNDhIMjgyWiIvPjxwYXRoIGQ9Ik0zMDcuNzksMjg3LjQ2di40N2gtOC43NHYtLjQ3aC41NWEyLjI3LDIuMjcsMCwwLDAsMS4xOC0uMjcsMS4yMSwxLjIxLDAsMCwwLC40OS0uNjIsNS40MSw1LjQxLDAsMCwwLC4xNC0xLjYyVjI3My41MWE1LjksNS45LDAsMCwwLS4xNC0xLjY3LDEuMjEsMS4yMSwwLDAsMC0uNTUtLjU4LDIuMTEsMi4xMSwwLDAsMC0xLjEyLS4yNWgtLjU1di0uNDhoOC43NFYyNzFoLS41NWEyLjIsMi4yLDAsMCwwLTEuMTcuMjcsMS4yMSwxLjIxLDAsMCwwLS41MS42MSw1LjY1LDUuNjUsMCwwLDAtLjEzLDEuNjJWMjg1YTUuNTMsNS41MywwLDAsMCwuMTQsMS42NywxLjMzLDEuMzMsMCwwLDAsLjU1LjU5LDIuMjQsMi4yNCwwLDAsMCwxLjEyLjI1WiIvPjxwYXRoIGQ9Ik0zMjAuNDUsMjg4LjA4YTUsNSwwLDAsMCwxLjc2LDIuNTcsNSw1LDAsMCwwLDMsLjg2LDUuNjMsNS42MywwLDAsMCwxLjA1LS4xdi43OGExMy42NywxMy42NywwLDAsMS0zLjMzLjQ5LDcuMzYsNy4zNiwwLDAsMS00LjEtMS4xNyw3LDcsMCwwLDEtMi43Mi0zLjQzLDguMDksOC4wOSwwLDAsMS00Ljg5LTMuMDksOS4yLDkuMiwwLDAsMS0xLjg2LTUuNzgsOC45Miw4LjkyLDAsMCwxLDIuNTItNi40OSw5LjEzLDkuMTMsMCwwLDEsMTIuNzUsMCw4LjkyLDguOTIsMCwwLDEsMi41LDYuNDgsOS4yMiw5LjIyLDAsMCwxLTIsNS44OEE3LjU3LDcuNTcsMCwwLDEsMzIwLjQ1LDI4OC4wOFptLTIuMi0xN2EzLjc1LDMuNzUsMCwwLDAtMy40MywyLjQsMTMuMSwxMy4xLDAsMCwwLTEsNS43M3EwLDQuNDcsMS41Miw2LjYyYTMuNiwzLjYsMCwwLDAsNS44NCwwYzEtMS40MSwxLjUyLTMuNTMsMS41Mi02LjM2YTE0LjE0LDE0LjE0LDAsMCwwLS45NS02LjA2QTMuNzYsMy43NiwwLDAsMCwzMTguMjUsMjcxLjExWiIvPjxwYXRoIGQ9Ik0zMjguNjEsMjcwLjUzaDguNjNWMjcxaC0uNDNhMywzLDAsMCwwLTEuMzQuMjEsMS4xNSwxLjE1LDAsMCwwLS41MS41OCw2LjE4LDYuMTgsMCwwLDAtLjE2LDEuODZ2OC41MmE5LjEsOS4xLDAsMCwwLC4zNCwzLjA5LDIuODgsMi44OCwwLDAsMCwxLjEyLDEuMjYsMy41LDMuNSwwLDAsMCwyLC41LDQuMTIsNC4xMiwwLDAsMCwyLjMxLS42MywzLjg1LDMuODUsMCwwLDAsMS40My0xLjc1LDExLDExLDAsMCwwLC40OC0zLjg5di03LjFhNC4xOSw0LjE5LDAsMCwwLS4yNC0xLjY3LDEuNDEsMS40MSwwLDAsMC0uNTktLjY5QTMuNDksMy40OSwwLDAsMCwzNDAsMjcxdi0uNDhoNS43OVYyNzFoLS4zNWEyLjIsMi4yLDAsMCwwLTEuMTcuMjksMS42OCwxLjY4LDAsMCwwLS42OC44OSw0Ljc2LDQuNzYsMCwwLDAtLjE2LDEuNDd2Ni42MWExNy44NCwxNy44NCwwLDAsMS0uMzksNC40Myw1LDUsMCwwLDEtMS44OSwyLjUsNi42NCw2LjY0LDAsMCwxLTQuMTEsMS4xNCw3LjU3LDcuNTcsMCwwLDEtMy4zNS0uNiw1LDUsMCwwLDEtMi4yOC0yLjExLDcuNDIsNy40MiwwLDAsMS0uNjctMy40NXYtOC41MmE2LjA5LDYuMDksMCwwLDAtLjE2LTEuODYsMS4yNSwxLjI1LDAsMCwwLS41NS0uNTksMy4zNiwzLjM2LDAsMCwwLTEuNDYtLjJaIi8+PHBhdGggZD0iTTM1My4xNCwyNzEuNTN2Ny4wOWguMzNhMi42MSwyLjYxLDAsMCwwLDIuMzEtMSw2LjU3LDYuNTcsMCwwLDAsLjkxLTMuMDdoLjQ3djkuMTFoLS40N2E3LDcsMCwwLDAtLjYyLTIuNDQsMi44LDIuOCwwLDAsMC0xLjEtMS4yOCw0LjIsNC4yLDAsMCwwLTEuODMtLjMydjQuOWE3LjIzLDcuMjMsMCwwLDAsLjEyLDEuNzYsMSwxLDAsMCwwLC40NC41MiwxLjkzLDEuOTMsMCwwLDAsMSwuMjFoMWE1Ljg5LDUuODksMCwwLDAsMy43Ni0xLjEzLDYuMzgsNi4zOCwwLDAsMCwyLTMuNDRIMzYybC0uNzUsNS41M0gzNDYuNzd2LS40N2guNTVhMi4yLDIuMiwwLDAsMCwxLjE3LS4yNywxLjE4LDEuMTgsMCwwLDAsLjUtLjYyLDUuNTYsNS41NiwwLDAsMCwuMTMtMS42MlYyNzMuNTFhOS43Miw5LjcyLDAsMCwwLS4wNi0xLjQ1LDEuMTcsMS4xNywwLDAsMC0uNDYtLjY5LDIsMiwwLDAsMC0xLjI4LS4zNmgtLjU1di0uNDhoMTR2NS4xNWgtLjQ3YTYuMzUsNi4zNSwwLDAsMC0xLTIuNzEsMy43MiwzLjcyLDAsMCwwLTEuODMtMS4yMSw5Ljc2LDkuNzYsMCwwLDAtMi41OS0uMjNaIi8+PC9nPjxnIHN0eWxlPSJpc29sYXRpb246aXNvbGF0ZSI+PHBhdGggZD0iTTYzLjgyLDMxMEg1Ny45MWwtLjcsMS42OWEzLjk0LDMuOTQsMCwwLDAtLjM1LDEuNCwxLjE3LDEuMTcsMCwwLDAsLjU3LDEuMDgsNC41NSw0LjU1LDAsMCwwLDEuNjQuMzF2LjQ3SDUzLjUxdi0uNDdhMi41MiwyLjUyLDAsMCwwLDEuNDgtLjc4LDEwLjY2LDEwLjY2LDAsMCwwLDEuNDMtMi42M2w2LTEzLjg4aC4yM2w2LDE0LjI3QTguODUsOC44NSwwLDAsMCw3MC4wOCwzMTRhMS45MywxLjkzLDAsMCwwLDEuMTkuNDd2LjQ3SDYzLjE4di0uNDdoLjMzYTIuNDUsMi40NSwwLDAsMCwxLjM3LS4yOS42OC42OCwwLDAsMCwuMjctLjU5LDEuNiwxLjYsMCwwLDAtLjA4LS40Nyw5LjIyLDkuMjIsMCwwLDAtLjM3LTFabS0uNDItMS0yLjQ5LTYtMi41Nyw2WiIvPjxwYXRoIGQ9Ik03Mi4xNCwyOTcuNTNoOC42M1YyOThoLS40M2EzLDMsMCwwLDAtMS4zNC4yMSwxLjE1LDEuMTUsMCwwLDAtLjUxLjU4LDYuMTgsNi4xOCwwLDAsMC0uMTYsMS44NnY4LjUyYTguODUsOC44NSwwLDAsMCwuMzQsMy4wOSwyLjg4LDIuODgsMCwwLDAsMS4xMiwxLjI2LDMuNSwzLjUsMCwwLDAsMiwuNSw0LjEyLDQuMTIsMCwwLDAsMi4zMS0uNjMsMy45MiwzLjkyLDAsMCwwLDEuNDMtMS43NSwxMSwxMSwwLDAsMCwuNDgtMy44OXYtNy4xYTQuMTksNC4xOSwwLDAsMC0uMjQtMS42NywxLjQxLDEuNDEsMCwwLDAtLjU5LS42OSwzLjQ5LDMuNDksMCwwLDAtMS41Ny0uMjl2LS40OGg1Ljc5VjI5OEg4OWEyLjIsMi4yLDAsMCwwLTEuMTcuMjksMS42OCwxLjY4LDAsMCwwLS42OC44OSw0Ljc2LDQuNzYsMCwwLDAtLjE2LDEuNDd2Ni42MWExNy44NCwxNy44NCwwLDAsMS0uMzksNC40Myw1LDUsMCwwLDEtMS44OSwyLjUsNi42NCw2LjY0LDAsMCwxLTQuMTEsMS4xNCw3LjU3LDcuNTcsMCwwLDEtMy4zNS0uNkE1LDUsMCwwLDEsNzUsMzEyLjYzYTcuNDIsNy40MiwwLDAsMS0uNjctMy40NXYtOC41MmE2LjA5LDYuMDksMCwwLDAtLjE2LTEuODYsMS4yNSwxLjI1LDAsMCwwLS41NS0uNTksMy4zNiwzLjM2LDAsMCwwLTEuNDYtLjJaIi8+PHBhdGggZD0iTTEwNy43NywyOTcuNTNWMjk4YTIuNywyLjcsMCwwLDAtMS42MywxLDE2LDE2LDAsMCwwLTEuNTQsM2wtNS43NiwxMy4yOWgtLjQxTDkyLjcsMzAxLjVhMTcuMTgsMTcuMTgsMCwwLDAtMS4zOS0yLjk0QTEuODksMS44OSwwLDAsMCw5MCwyOTh2LS40OGg4VjI5OGgtLjI3YTIuNzEsMi43MSwwLDAsMC0xLjQ4LjI4LjY0LjY0LDAsMCwwLS4yOC41NiwxLjc0LDEuNzQsMCwwLDAsLjEuNTVjLjA2LjIxLjI4Ljc3LjY2LDEuNjlsMy41Nyw4LjY2LDMuMy03LjcxYTE5LjYzLDE5LjYzLDAsMCwwLC43My0xLjg4LDIuOTQsMi45NCwwLDAsMCwuMTMtLjgxLDEuMjIsMS4yMiwwLDAsMC0uMTktLjY4LDEuMzQsMS4zNCwwLDAsMC0uNTgtLjQ1LDMuOTIsMy45MiwwLDAsMC0xLjQxLS4yMXYtLjQ4WiIvPjxwYXRoIGQ9Ik0xMTQuOTEsMjk4LjUzdjcuMDloLjMzYTIuNjIsMi42MiwwLDAsMCwyLjMxLTEsNi41Nyw2LjU3LDAsMCwwLC45MS0zLjA3aC40N3Y5LjExaC0uNDdhNyw3LDAsMCwwLS42Mi0yLjQ0LDIuODYsMi44NiwwLDAsMC0xLjEtMS4yOCw0LjIsNC4yLDAsMCwwLTEuODMtLjMydjQuOWE3LjIzLDcuMjMsMCwwLDAsLjEyLDEuNzYsMSwxLDAsMCwwLC40NC41MiwxLjkxLDEuOTEsMCwwLDAsMSwuMjFoMWE1Ljg5LDUuODksMCwwLDAsMy43Ni0xLjEzLDYuMzEsNi4zMSwwLDAsMCwyLTMuNDRoLjQ2bC0uNzUsNS41M0gxMDguNTN2LS40N2guNTZhMi4yNSwyLjI1LDAsMCwwLDEuMTctLjI3LDEuMTYsMS4xNiwwLDAsMCwuNDktLjYyLDUuNDEsNS40MSwwLDAsMCwuMTQtMS42MlYzMDAuNTFhOS43Miw5LjcyLDAsMCwwLS4wNi0xLjQ1LDEuMjIsMS4yMiwwLDAsMC0uNDYtLjY5LDIsMiwwLDAsMC0xLjI4LS4zNmgtLjU2di0uNDhoMTR2NS4xNWgtLjQ3YTYuNDgsNi40OCwwLDAsMC0xLTIuNzEsMy43MiwzLjcyLDAsMCwwLTEuODMtMS4yMSw5Ljc2LDkuNzYsMCwwLDAtMi41OS0uMjNaIi8+PHBhdGggZD0iTTEzMS41OCwzMDd2NC44OGE1LjUxLDUuNTEsMCwwLDAsLjE3LDEuNzcsMS4yNSwxLjI1LDAsMCwwLC41OS41OSwzLjg4LDMuODgsMCwwLDAsMS41Ni4yMnYuNDdoLTguNTZ2LS40N2EzLjcxLDMuNzEsMCwwLDAsMS41OC0uMjMsMS4zLDEuMywwLDAsMCwuNTgtLjU4LDUuNjMsNS42MywwLDAsMCwuMTYtMS43N1YzMDAuNTlhNS42Niw1LjY2LDAsMCwwLS4xNi0xLjc4LDEuMjUsMS4yNSwwLDAsMC0uNTktLjU5LDQsNCwwLDAsMC0xLjU3LS4yMXYtLjQ4aDcuNzdhMTYuMjUsMTYuMjUsMCwwLDEsNC40NC40NCw0LjQ4LDQuNDgsMCwwLDEsMy4xOSw0LjM2LDQuMTksNC4xOSwwLDAsMS0xLjM0LDMuMTgsNS40NCw1LjQ0LDAsMCwxLTIuMzgsMS4ybDQsNS44OWE4LjU0LDguNTQsMCwwLDAsMS4xMywxLjQyLDIsMiwwLDAsMCwxLjE3LjQ0di40N2gtNS4yN0wxMzIuNjgsMzA3Wm0wLTguNTN2Ny42MmguNzFhNy40Niw3LjQ2LDAsMCwwLDIuNTYtLjMzLDIuNTYsMi41NiwwLDAsMCwxLjM0LTEuMTgsNC40LDQuNCwwLDAsMCwuNDktMi4yMiw0LjE0LDQuMTQsMCwwLDAtLjktMi45NCwzLjgsMy44LDAsMCwwLTIuODgtLjk1WiIvPjxwYXRoIGQ9Ik0xNjAuNTQsMjk3LjEzdjYuMTRoLS40NmE3Ljg3LDcuODcsMCwwLDAtMi40Ny0zLjgzLDUuNzQsNS43NCwwLDAsMC0zLjYyLTEuMzEsNC41Niw0LjU2LDAsMCwwLTMuMTIsMS4xLDUuOTQsNS45NCwwLDAsMC0xLjc2LDMuMDYsMTUuNTIsMTUuNTIsMCwwLDAtLjUyLDQsMTUuMjMsMTUuMjMsMCwwLDAsLjU3LDQuMzksNSw1LDAsMCwwLDEuODMsMi43Nyw1LjA5LDUuMDksMCwwLDAsMywuODksNS44OSw1Ljg5LDAsMCwwLDEuMjQtLjE0LDguMzQsOC4zNCwwLDAsMCwxLjMtLjM5di0zLjYyYTQuMSw0LjEsMCwwLDAtLjEzLTEuMzMsMS4yNywxLjI3LDAsMCwwLS41Ni0uNTQsMi4wOSwyLjA5LDAsMCwwLTEtLjI1aC0uNDN2LS40N2g4LjEydi40N2EzLjQ4LDMuNDgsMCwwLDAtMS4yOS4yNywxLjI4LDEuMjgsMCwwLDAtLjU2LjY2LDMuODksMy44OSwwLDAsMC0uMTEsMS4xOXYzLjYyYTE1LjczLDE1LjczLDAsMCwxLTMuMzMsMS4xMiwxNywxNywwLDAsMS0zLjYuMzgsMTAsMTAsMCwwLDEtNC0uNjcsOS44NCw5Ljg0LDAsMCwxLTIuNzgtMS43Nyw4LjM2LDguMzYsMCwwLDEtMS44OC0yLjQ3LDkuNjEsOS42MSwwLDAsMSwxLjc5LTEwLjYsOC45Myw4LjkzLDAsMCwxLDYuNjctMi43MSwxMSwxMSwwLDAsMSwyLjI1LjIxLDExLjM1LDExLjM1LDAsMCwxLDEuNzUuNTgsNy4wNyw3LjA3LDAsMCwwLDEuNDQuNDgsMSwxLDAsMCwwLC42NC0uMjYsMi4zMywyLjMzLDAsMCwwLC41NC0xWiIvPjxwYXRoIGQ9Ik0xNjkuMDUsMjk3LjUzbDguMjUsMTAuNzl2LTcuNDhhMy42NiwzLjY2LDAsMCwwLS40My0yLjEyLDIuMzQsMi4zNCwwLDAsMC0yLS43MXYtLjQ4aDUuNTNWMjk4YTQuMDgsNC4wOCwwLDAsMC0xLjQzLjM2LDEuNDcsMS40NywwLDAsMC0uNTYuNzMsNSw1LDAsMCwwLS4yMSwxLjc0djE0LjQ5aC0uNDJsLTExLjMtMTQuNDlWMzExLjlhMi41LDIuNSwwLDAsMCwuNjYsMiwyLjM2LDIuMzYsMCwwLDAsMS41MS41M2guMzl2LjQ3aC01Ljkzdi0uNDdhMi42MywyLjYzLDAsMCwwLDEuOTItLjU5LDIuODYsMi44NiwwLDAsMCwuNTUtMlYyOTkuNjJsLS4zNi0uNDZhMy41LDMuNSwwLDAsMC0uOTQtLjkxLDIuNywyLjcsMCwwLDAtMS4xNy0uMjR2LS40OFoiLz48cGF0aCBkPSJNMTg3Ljg4LDI5OC41M3Y3LjA5aC4zNGEyLjU5LDIuNTksMCwwLDAsMi4zLTEsNi42OCw2LjY4LDAsMCwwLC45Mi0zLjA3aC40NnY5LjExaC0uNDZhNyw3LDAsMCwwLS42My0yLjQ0LDIuNzQsMi43NCwwLDAsMC0xLjEtMS4yOCw0LjIsNC4yLDAsMCwwLTEuODMtLjMydjQuOWE3LjIzLDcuMjMsMCwwLDAsLjEyLDEuNzYsMSwxLDAsMCwwLC40NC41MiwxLjkzLDEuOTMsMCwwLDAsMSwuMjFoMWE1Ljg1LDUuODUsMCwwLDAsMy43Ni0xLjEzLDYuMzIsNi4zMiwwLDAsMCwyLTMuNDRoLjQ1bC0uNzUsNS41M0gxODEuNTF2LS40N2guNTVhMi4yLDIuMiwwLDAsMCwxLjE3LS4yNywxLjE4LDEuMTgsMCwwLDAsLjUtLjYyLDUuNTYsNS41NiwwLDAsMCwuMTMtMS42MlYzMDAuNTFhOS43Miw5LjcyLDAsMCwwLS4wNi0xLjQ1LDEuMTcsMS4xNywwLDAsMC0uNDYtLjY5LDIsMiwwLDAsMC0xLjI4LS4zNmgtLjU1di0uNDhoMTR2NS4xNUgxOTVhNi40Nyw2LjQ3LDAsMCwwLTEtMi43MSwzLjcyLDMuNzIsMCwwLDAtMS44My0xLjIxLDkuNzEsOS43MSwwLDAsMC0yLjU5LS4yM1oiLz48cGF0aCBkPSJNMjA1LjY1LDMxMC4yMmgtNy4xOXYtMi42NWg3LjE5WiIvPjxwYXRoIGQ9Ik0yMTMsMzA3djQuODhhNS42Myw1LjYzLDAsMCwwLC4xNiwxLjc3LDEuMjUsMS4yNSwwLDAsMCwuNTkuNTksMy45LDMuOSwwLDAsMCwxLjU3LjIydi40N2gtOC41NnYtLjQ3YTMuNjksMy42OSwwLDAsMCwxLjU3LS4yMywxLjMsMS4zLDAsMCwwLC41OC0uNTgsNS41MSw1LjUxLDAsMCwwLC4xNy0xLjc3VjMwMC41OWE1LjU1LDUuNTUsMCwwLDAtLjE3LTEuNzgsMS4yNSwxLjI1LDAsMCwwLS41OS0uNTksMy45MiwzLjkyLDAsMCwwLTEuNTYtLjIxdi0uNDhoNy43N2ExNi4zNSwxNi4zNSwwLDAsMSw0LjQ0LjQ0LDQuNDksNC40OSwwLDAsMSwyLjI5LDEuNjEsNC40NCw0LjQ0LDAsMCwxLC44OSwyLjc1LDQuMjIsNC4yMiwwLDAsMS0xLjMzLDMuMTgsNS40OSw1LjQ5LDAsMCwxLTIuMzgsMS4ybDQsNS44OWE4LjY3LDguNjcsMCwwLDAsMS4xMiwxLjQyLDIuMDUsMi4wNSwwLDAsMCwxLjE3LjQ0di40N2gtNS4yN0wyMTQuMDYsMzA3Wm0wLTguNTN2Ny42MmguN2E3LjU3LDcuNTcsMCwwLDAsMi41Ny0uMzMsMi41OCwyLjU4LDAsMCwwLDEuMzMtMS4xOCw0LjQsNC40LDAsMCwwLC40OS0yLjIyLDQuMTksNC4xOSwwLDAsMC0uODktMi45NCwzLjgzLDMuODMsMCwwLDAtMi44OC0uOTVaIi8+PHBhdGggZD0iTTIzMS40LDMwNi41NlYzMTJhNS40LDUuNCwwLDAsMCwuMTUsMS42NywxLjMzLDEuMzMsMCwwLDAsLjU1LjU5LDIuMjQsMi4yNCwwLDAsMCwxLjEyLjI1aC41NXYuNDdIMjI1di0uNDdoLjU1YTIuMjcsMi4yNywwLDAsMCwxLjE4LS4yNywxLjIxLDEuMjEsMCwwLDAsLjQ5LS42Miw1LjU2LDUuNTYsMCwwLDAsLjEzLTEuNjJWMzAwLjUxYTYuMDUsNi4wNSwwLDAsMC0uMTMtMS42NywxLjIxLDEuMjEsMCwwLDAtLjU1LS41OCwyLjE0LDIuMTQsMCwwLDAtMS4xMi0uMjVIMjI1di0uNDhoOC43NFYyOThoLS41NWEyLjIsMi4yLDAsMCwwLTEuMTcuMjcsMS4xNywxLjE3LDAsMCwwLS41MS42MSw1LjUxLDUuNTEsMCwwLDAtLjE0LDEuNjJ2NC45M2g1Ljkxdi00LjkzYTYuMDUsNi4wNSwwLDAsMC0uMTMtMS42NywxLjI0LDEuMjQsMCwwLDAtLjU2LS41OCwyLjE0LDIuMTQsMCwwLDAtMS4xMi0uMjVIMjM1di0uNDhoOC43M1YyOThoLS41NGEyLjIyLDIuMjIsMCwwLDAtMS4xOC4yNywxLjIsMS4yLDAsMCwwLS41LjYxLDUuNTEsNS41MSwwLDAsMC0uMTQsMS42MlYzMTJhNS45LDUuOSwwLDAsMCwuMTQsMS42NywxLjI4LDEuMjgsMCwwLDAsLjU1LjU5LDIuMjgsMi4yOCwwLDAsMCwxLjEzLjI1aC41NHYuNDdIMjM1di0uNDdoLjU0YTIuMiwyLjIsMCwwLDAsMS4xNy0uMjcsMS4yOSwxLjI5LDAsMCwwLC41MS0uNjIsNS41Niw1LjU2LDAsMCwwLC4xMy0xLjYydi01LjM5WiIvPjxwYXRoIGQ9Ik0yNTMuOSwyOTcuMjlhOC4xNiw4LjE2LDAsMCwxLDYuNDksMi40Miw4Ljg5LDguODksMCwwLDEsMi41LDYuNDZBOS41Miw5LjUyLDAsMCwxLDI2MSwzMTJhOC4xNiw4LjE2LDAsMCwxLTcsMy4zNCw4LjMxLDguMzEsMCwwLDEtNy0zLjE4LDkuNDcsOS40NywwLDAsMS0yLTYsOC44Niw4Ljg2LDAsMCwxLDIuNTQtNi40NkE3Ljg5LDcuODksMCwwLDEsMjUzLjksMjk3LjI5Wm0uMTUuODJhMy43NiwzLjc2LDAsMCwwLTMuNDksMi40NCwxMy40NCwxMy40NCwwLDAsMC0xLDUuNzRxMCw0LjQ1LDEuNTEsNi41OWEzLjY4LDMuNjgsMCwwLDAsNSwuODQsNS4xOCw1LjE4LDAsMCwwLDEuNjktMi42MiwxNC44OSwxNC44OSwwLDAsMCwuNjEtNC43LDE2LjMxLDE2LjMxLDAsMCwwLS42Mi01LjE3LDUuMDcsNS4wNywwLDAsMC0xLjU3LTIuNDJBMy42MSwzLjYxLDAsMCwwLDI1NC4wNSwyOTguMTFabTEuMzgtNi41MiwyLjUsNC45SDI1N2wtMi45My0yLjY0LTMsMi41N2gtMWwyLjYzLTQuODNaIi8+PHBhdGggZD0iTTI3MC4wOCwyOTcuNTNsOC4yNSwxMC43OXYtNy40OGEzLjY2LDMuNjYsMCwwLDAtLjQzLTIuMTIsMi4zNiwyLjM2LDAsMCwwLTItLjcxdi0uNDhoNS41M1YyOThhNC4wOCw0LjA4LDAsMCwwLTEuNDMuMzYsMS40NywxLjQ3LDAsMCwwLS41Ni43Myw1LDUsMCwwLDAtLjIxLDEuNzR2MTQuNDloLS40MmwtMTEuMzEtMTQuNDlWMzExLjlhMi41LDIuNSwwLDAsMCwuNjYsMiwyLjM4LDIuMzgsMCwwLDAsMS41Mi41M2guMzl2LjQ3aC01Ljkzdi0uNDdhMi42MywyLjYzLDAsMCwwLDEuOTItLjU5LDIuODcsMi44NywwLDAsMCwuNTQtMlYyOTkuNjJsLS4zNS0uNDZhMy41LDMuNSwwLDAsMC0uOTQtLjkxLDIuNywyLjcsMCwwLDAtMS4xNy0uMjR2LS40OFoiLz48cGF0aCBkPSJNMjg4LjkxLDI5OC41M3Y3LjA5aC4zM2EyLjYxLDIuNjEsMCwwLDAsMi4zMS0xLDYuNTcsNi41NywwLDAsMCwuOTEtMy4wN2guNDd2OS4xMWgtLjQ3YTYuNzksNi43OSwwLDAsMC0uNjItMi40NCwyLjgsMi44LDAsMCwwLTEuMS0xLjI4LDQuMiw0LjIsMCwwLDAtMS44My0uMzJ2NC45YTcuMjMsNy4yMywwLDAsMCwuMTIsMS43NiwxLDEsMCwwLDAsLjQ0LjUyLDEuOTMsMS45MywwLDAsMCwxLC4yMWgxYTUuODcsNS44NywwLDAsMCwzLjc2LTEuMTMsNi4zOCw2LjM4LDAsMCwwLDItMy40NGguNDVsLS43NSw1LjUzSDI4Mi41NHYtLjQ3aC41NWEyLjIsMi4yLDAsMCwwLDEuMTctLjI3LDEuMTgsMS4xOCwwLDAsMCwuNS0uNjIsNS41Niw1LjU2LDAsMCwwLC4xMy0xLjYyVjMwMC41MWE5LjcyLDkuNzIsMCwwLDAtLjA2LTEuNDUsMS4xNywxLjE3LDAsMCwwLS40Ni0uNjksMiwyLDAsMCwwLTEuMjgtLjM2aC0uNTV2LS40OGgxNHY1LjE1aC0uNDdhNi4zNSw2LjM1LDAsMCwwLTEtMi43MSwzLjcyLDMuNzIsMCwwLDAtMS44My0xLjIxLDkuNzYsOS43NiwwLDAsMC0yLjU5LS4yM1oiLz48cGF0aCBkPSJNMzA2LjY4LDMxMC4yMmgtNy4xOXYtMi42NWg3LjE5WiIvPjxwYXRoIGQ9Ik0zMTcuNzksMzEwaC01LjlsLS43MSwxLjY5YTMuODksMy44OSwwLDAsMC0uMzQsMS40LDEuMTcsMS4xNywwLDAsMCwuNTcsMS4wOCw0LjU1LDQuNTUsMCwwLDAsMS42NC4zMXYuNDdoLTUuNTd2LS40N2EyLjQ5LDIuNDksMCwwLDAsMS40OC0uNzgsMTAuMjcsMTAuMjcsMCwwLDAsMS40NC0yLjYzbDYtMTMuODhoLjIzbDYsMTQuMjdhOC44NSw4Ljg1LDAsMCwwLDEuNDIsMi41NSwxLjksMS45LDAsMCwwLDEuMTguNDd2LjQ3aC04LjA5di0uNDdoLjM0YTIuNDUsMi40NSwwLDAsMCwxLjM3LS4yOS42OC42OCwwLDAsMCwuMjctLjU5LDEuNiwxLjYsMCwwLDAtLjA4LS40Nyw5LjIyLDkuMjIsMCwwLDAtLjM3LTFabS0uNDEtMS0yLjUtNi0yLjU2LDZaIi8+PHBhdGggZD0iTTM0MS40NywzMDguODJsLS42Myw2LjExSDMyNnYtLjQ3aC41NWEyLjIsMi4yLDAsMCwwLDEuMTctLjI3LDEuMTgsMS4xOCwwLDAsMCwuNS0uNjIsNS41Niw1LjU2LDAsMCwwLC4xMy0xLjYyVjMwMC41MWE2LjA1LDYuMDUsMCwwLDAtLjEzLTEuNjcsMS4yNiwxLjI2LDAsMCwwLS41NS0uNTgsMi4xNCwyLjE0LDAsMCwwLTEuMTItLjI1SDMyNnYtLjQ4aDguOTFWMjk4aC0uNzJhMi4yNywyLjI3LDAsMCwwLTEuMTguMjcsMS4yLDEuMiwwLDAsMC0uNS42MSw1LjUxLDUuNTEsMCwwLDAtLjE0LDEuNjJ2MTEuMDhhNS43NCw1Ljc0LDAsMCwwLC4xNSwxLjcsMSwxLDAsMCwwLC41OC41NSw1LjQ0LDUuNDQsMCwwLDAsMS40OS4xMkgzMzZhNC42Nyw0LjY3LDAsMCwwLDIuMjItLjQ5LDQuMjYsNC4yNiwwLDAsMCwxLjUzLTEuNTQsMTMsMTMsMCwwLDAsMS4yMy0zLjExWiIvPjxwYXRoIGQ9Ik0zNDkuMTksMzA3LjA1djQuODNhNS41MSw1LjUxLDAsMCwwLC4xNywxLjc3LDEuMjUsMS4yNSwwLDAsMCwuNTkuNTksMy45NCwzLjk0LDAsMCwwLDEuNTYuMjJ2LjQ3SDM0M3YtLjQ3YTMuNjksMy42OSwwLDAsMCwxLjU3LS4yMywxLjMsMS4zLDAsMCwwLC41OC0uNTgsNS42Myw1LjYzLDAsMCwwLC4xNi0xLjc3VjMwMC41OWE1LjY2LDUuNjYsMCwwLDAtLjE2LTEuNzgsMS4yNSwxLjI1LDAsMCwwLS41OS0uNTlBMy45MiwzLjkyLDAsMCwwLDM0MywyOTh2LS40OGg3LjI4YzIuNCwwLDQuMTMuNDUsNS4xNywxLjM0QTQuMTksNC4xOSwwLDAsMSwzNTcsMzAyLjJhNC4zOCw0LjM4LDAsMCwxLTEsMi45LDUuMSw1LjEsMCwwLDEtMi43OSwxLjY0QTE4LjA2LDE4LjA2LDAsMCwxLDM0OS4xOSwzMDcuMDVabTAtOC41MnY3LjUybC42MiwwYTIuOTIsMi45MiwwLDAsMCwyLjMyLS45Myw0LjMxLDQuMzEsMCwwLDAsLjgxLTIuODgsNC4xNSw0LjE1LDAsMCwwLS44MS0yLjg0LDMuMSwzLjEsMCwwLDAtMi40My0uOVoiLz48cGF0aCBkPSJNMzY0LjY4LDI5OC41M3Y3LjA5SDM2NWEyLjU5LDIuNTksMCwwLDAsMi4zLTEsNi42OCw2LjY4LDAsMCwwLC45Mi0zLjA3aC40NnY5LjExaC0uNDZhNyw3LDAsMCwwLS42My0yLjQ0LDIuNzQsMi43NCwwLDAsMC0xLjEtMS4yOCw0LjIsNC4yLDAsMCwwLTEuODMtLjMydjQuOWE3LjIzLDcuMjMsMCwwLDAsLjEyLDEuNzYsMSwxLDAsMCwwLC40NC41MiwxLjkzLDEuOTMsMCwwLDAsMSwuMjFoMWE1Ljg1LDUuODUsMCwwLDAsMy43Ni0xLjEzLDYuMzIsNi4zMiwwLDAsMCwyLTMuNDRoLjQ1bC0uNzUsNS41M0gzNTguMzF2LS40N2guNTVhMi4yLDIuMiwwLDAsMCwxLjE3LS4yNywxLjE4LDEuMTgsMCwwLDAsLjUtLjYyLDUuNTYsNS41NiwwLDAsMCwuMTMtMS42MlYzMDAuNTFhOS43Miw5LjcyLDAsMCwwLS4wNi0xLjQ1LDEuMiwxLjIsMCwwLDAtLjQ1LS42OSwyLjEsMi4xLDAsMCwwLTEuMjktLjM2aC0uNTV2LS40OGgxNHY1LjE1aC0uNDdhNi40Nyw2LjQ3LDAsMCwwLTEtMi43MSwzLjcyLDMuNzIsMCwwLDAtMS44My0xLjIxLDkuNzEsOS43MSwwLDAsMC0yLjU5LS4yM1oiLz48cGF0aCBkPSJNMzg2LjUxLDI5Ny4xM2wuMTQsNS44aC0uNTFhNi4wNyw2LjA3LDAsMCwwLTEuNzUtMy41MSw0LjM3LDQuMzcsMCwwLDAtMy0xLjMyLDIuNzMsMi43MywwLDAsMC0yLC43LDIuMTUsMi4xNSwwLDAsMC0uNzQsMS42MSwyLDIsMCwwLDAsLjI2LDEsNC40LDQuNCwwLDAsMCwxLjE1LDEuMiwyNi4xNCwyNi4xNCwwLDAsMCwyLjY3LDEuNSwxMS44NCwxMS44NCwwLDAsMSw0LDIuODMsNC45LDQuOSwwLDAsMSwxLDMuMDYsNSw1LDAsMCwxLTEuNjMsMy43NSw1LjczLDUuNzMsMCwwLDEtNC4xNSwxLjU3LDYsNiwwLDAsMS0xLjQ5LS4xNywxMC43NywxMC43NywwLDAsMS0xLjc3LS42MywyLjU2LDIuNTYsMCwwLDAtMS0uMjUsMS4xOSwxLjE5LDAsMCwwLS42OC4yNSwxLjg3LDEuODcsMCwwLDAtLjU4Ljc5SDM3NnYtNi41N2guNDVBNy42Myw3LjYzLDAsMCwwLDM3OC41LDMxM2E0LjgsNC44LDAsMCwwLDMuMzQsMS40NSwzLjA3LDMuMDcsMCwwLDAsMi4yLS43OCwyLjQzLDIuNDMsMCwwLDAsLjgyLTEuODIsMi42MSwyLjYxLDAsMCwwLS4zMS0xLjIsMy42OSwzLjY5LDAsMCwwLTEtMS4wOSwxNC4xNywxNC4xNywwLDAsMC0yLjI3LTEuMzYsMTkuNjgsMTkuNjgsMCwwLDEtMy4yOC0yLDYsNiwwLDAsMS0xLjU0LTEuODQsNSw1LDAsMCwxLC45NC01Ljc3LDUsNSwwLDAsMSwzLjctMS40Nyw1Ljg5LDUuODksMCwwLDEsMS41Ny4yMSw3LjQ1LDcuNDUsMCwwLDEsMS40Mi41NywzLjE5LDMuMTksMCwwLDAsMS4xNi40Mi42NS42NSwwLDAsMCwuNTEtLjIxLDIuMzEsMi4zMSwwLDAsMCwuMzQtMVoiLz48L2c+PHBhdGggZD0iTTQ2Mi4xLDIwMFY0OS41aDUxLjZjOS4xLDAsMTYsLjUsMjAuOCwxLjRhMzkuMjUsMzkuMjUsMCwwLDEsMTYuOSw3LDM3LjQ2LDM3LjQ2LDAsMCwxLDExLDE0LjUsNDkuNDUsNDkuNDUsMCwwLDEsNC4yLDIwLjVjMCwxMi44LTMuNywyMy42LTExLjEsMzIuNXMtMjAuOCwxMy4zLTQwLjIsMTMuM0g0ODAuMlYyMDBabTE4LjEtNzloMzUuNHExNy41NSwwLDI0LjktNy4yYzQuOS00LjgsNy40LTExLjUsNy40LTIwLjIsMC02LjMtMS40LTExLjctNC4zLTE2LjJhMjAuNzIsMjAuNzIsMCwwLDAtMTEuNC04LjljLTMuMS0uOS04LjctMS4zLTE2LjktMS4zaC0zNVYxMjFaIiBzdHlsZT0iZmlsbDojZmZmIi8+PHBhdGggZD0iTTU4OC45LDIwMFY0OS41SDYwN1YxODIuMmg2Ny40VjIwMFoiIHN0eWxlPSJmaWxsOiNmZmYiLz48cGF0aCBkPSJNNjgxLDIwMCw3MzMuNiw0OS41aDE5LjVsNTYsMTUwLjVINzg4LjVsLTE2LTQ1LjZINzE1LjNsLTE1LDQ1LjZabTM5LjUtNjEuOGg0Ni40TDc1Mi42LDk2LjVjLTQuNC0xMi43LTcuNi0yMy4xLTkuNy0zMS4yQTE5OC40NiwxOTguNDYsMCwwLDEsNzM1LjUsOTRaIiBzdHlsZT0iZmlsbDojZmZmIi8+PHBhdGggZD0iTTgyMy40LDIwMFY0OS41SDg0Mmw3MS45LDExOC4yVjQ5LjVoMTcuNFYyMDBIOTEyLjdMODQwLjgsODEuN1YyMDBaIiBzdHlsZT0iZmlsbDojZmZmIi8+PHBhdGggZD0iTTk2Mi4xLDIwMFY0OS41aDk5VjY3LjNIOTgwLjJ2NDYuMWg3NS43VjEzMUg5ODAuMnY1MS4yaDg0LjFWMjAwWm02NC4zLTE1OS44aC0xMy41TDk5MS4zLDExLjVoMjIuNVoiIHN0eWxlPSJmaWxsOiNmZmYiLz48cGF0aCBkPSJNMTEyNC4yLDIwMFY2Ny4ySDEwNzlWNDkuNWgxMDguNVY2Ny4zaC00NS4zVjIwMFoiIHN0eWxlPSJmaWxsOiNmZmYiLz48cGF0aCBkPSJNMTIwNi41LDIwMFY0OS41aDk5VjY3LjNoLTgwLjl2NDYuMWg3NS43VjEzMWgtNzUuN3Y1MS4yaDg0LjFWMjAwWiIgc3R5bGU9ImZpbGw6I2ZmZiIvPjxwYXRoIGQ9Ik00NjEuNiw0NTIuM1YzMDEuOGgyNy4zbDMyLjQsMTA2LjZjMyw5LjksNS4yLDE3LjMsNi41LDIyLjMsMS42LTUuNSw0LTEzLjUsNy4zLTI0LjFsMzIuOC0xMDQuN2gyNC40VjQ1Mi40SDU3NC44di0xMjZMNTM1LDQ1Mi40SDUxOC43TDQ3OSwzMjQuMVY0NTIuMkg0NjEuNloiIHN0eWxlPSJmaWxsOiNmZmYiLz48cGF0aCBkPSJNNjA2LjQsNDUyLjMsNjU5LDMwMS44aDE5LjVsNTYsMTUwLjVINzEzLjlsLTE2LTQ1LjZINjQwLjdsLTE1LDQ1LjZabTM5LjUtNjEuOGg0Ni40TDY3OCwzNDguOGMtNC40LTEyLjctNy42LTIzLjEtOS43LTMxLjJhMTk1LjE3LDE5NS4xNywwLDAsMS03LjQsMjguN1oiIHN0eWxlPSJmaWxsOiNmZmYiLz48cGF0aCBkPSJNNzY5LjYsNDUyLjNWMzE5LjVINzI0LjVWMzAxLjdIODMzdjE3LjhINzg3LjdWNDUyLjJINzY5LjZaIiBzdHlsZT0iZmlsbDojZmZmIi8+PHBhdGggZD0iTTg1Mi4yLDQ1Mi4zVjMwMS44aDE4LjF2NjEuOGg3MS4yVjMwMS44aDE4LjFWNDUyLjNIOTQxLjVWMzgxLjRIODcwLjN2NzAuOVoiIHN0eWxlPSJmaWxsOiNmZmYiLz48cGF0aCBkPSJNOTgzLjYsNDAzLjlsMTcuMS0xLjZjLjgsNy41LDIuNywxMy43LDUuNiwxOC41czcuNSw4LjcsMTMuOCwxMS43YTQ3LjYsNDcuNiwwLDAsMCwyMSw0LjUsNDUuNjEsNDUuNjEsMCwwLDAsMTguMy0zLjRjNS4zLTIuMyw5LjItNS40LDExLjgtOS4zYTIyLjc3LDIyLjc3LDAsMCwwLDMuOS0xMi45LDIxLjEsMjEuMSwwLDAsMC0zLjctMTIuNGMtMi41LTMuNS02LjYtNi41LTEyLjMtOC45LTMuNy0xLjYtMTEuOC00LTI0LjQtNy4zcy0yMS40LTYuNS0yNi40LTkuNGMtNi41LTMuOC0xMS40LTguNC0xNC42LTE0YTM2LjkzLDM2LjkzLDAsMCwxLTQuOC0xOC43LDQxLjIxLDQxLjIxLDAsMCwxLDUuOS0yMS4zLDM3LjIyLDM3LjIyLDAsMCwxLDE3LjItMTUsNjAuMjIsNjAuMjIsMCwwLDEsMjUuMS01LjFjMTAuMSwwLDE5LjEsMS44LDI2LjgsNS40YTM5LjY1LDM5LjY1LDAsMCwxLDE3LjksMTUuOSw0OC40Myw0OC40MywwLDAsMSw2LjcsMjMuN2wtMTcuNCwxLjRjLS45LTkuNS00LjEtMTYuNy05LjUtMjEuNnMtMTMuMy03LjMtMjMuOS03LjNjLTExLDAtMTguOSwyLjItMjQsNi42cy03LjUsOS43LTcuNSwxNmExNy44NSwxNy44NSwwLDAsMCw1LjMsMTMuM2MzLjUsMy41LDEyLjYsNy4xLDI3LjMsMTAuN3MyNC44LDYuOSwzMC4zLDkuNmM4LDQsMTMuOSw5LjIsMTcuNywxNS4zYTQwLDQwLDAsMCwxLDUuNywyMS40LDQzLjM0LDQzLjM0LDAsMCwxLTYuMywyMi42LDQyLjM3LDQyLjM3LDAsMCwxLTE4LDE2LjUsNTguMjQsNTguMjQsMCwwLDEtMjYuNCw1LjljLTEyLjQsMC0yMi44LTItMzEuMS02QTQ0Ljg5LDQ0Ljg5LDAsMCwxLDk5MSw0MzAuOCw1NC4zNCw1NC4zNCwwLDAsMSw5ODMuNiw0MDMuOVoiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=';
+
+
+class Scratch3PMBlocks {
+    constructor (runtime) {
+        /**
+         * The runtime instantiating this block package.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+    }
+
+   
+    getInfo () {
+        this.setupTranslations();
+        return {
+            id: 'planetemaths',
+            name: formatMessage({
+                        id: 'pm.title',
+                        default: 'Maths',
+                        description: ''
+                    }),
+            color1:'#4879b7',
+            color2:'#000000',
+            blocks: [
+                {
+                    opcode: 'add',
+                    text: formatMessage({
+                        id: 'pm.add',
+                        default: '[NUM1] + [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                {
+                    opcode: 'substract',
+                    text: formatMessage({
+                        id: 'pm.substract',
+                        default: '[NUM1] - [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                {
+                    opcode: 'multiply',
+                    text: formatMessage({
+                        id: 'pm.multiply',
+                        default: '[NUM1] x [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                {
+                    opcode: 'divide',
+                    text: formatMessage({
+                        id: 'pm.divide',
+                        default: '[NUM1] / [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                '---',
+                {
+                    opcode: 'pow',
+                    text: formatMessage({
+                        id: 'pm.pow',
+                        default: '[NUM1] ^ [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                '---',
+                {
+                    opcode: 'mathop',
+                    text: formatMessage({
+                        id: 'pm.mathop',
+                        default: '[OPERATOR] of [NUM1]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         OPERATOR: {
+                            type: ArgumentType.STRING,
+                            menu: 'LIST_MATHOP',
+                            defaultValue: ''
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'mathopdiv',
+                    text: formatMessage({
+                        id: 'pm.mathopdiv',
+                        default: '[OPERATOR] of [NUM1] divided by [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                        NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         OPERATOR: {
+                            type: ArgumentType.STRING,
+                            menu: 'LIST_MATHOPDIV',
+                            defaultValue: ''
+                        }
+                    }
+                },
+                 {
+                    opcode: 'mathop2',
+                    text: formatMessage({
+                        id: 'pm.mathop2',
+                        default: '[OPERATOR] of [NUM1] and [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                        NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         OPERATOR: {
+                            type: ArgumentType.STRING,
+                            menu: 'LIST_MATHOP2',
+                            defaultValue: ''
+                        }
+                    }
+                },
+
+                 {
+                    opcode: 'multiple',
+                    text: formatMessage({
+                        id: 'pm.multiple',
+                        default: '[NUM1] is a [choix1] of [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         choix1: {
+                            type: ArgumentType.STRING,
+                            menu: 'MULTIPLE_DIVISEUR',
+                            defaultValue: ''
+                        }
+                    }
+                },
+                '---',
+                 {
+                    opcode: 'arrondis',
+                    text: formatMessage({
+                        id: 'pm.arrondis',
+                        default: '[TYPE] [NUM1] to [CHIFFRE]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                        TYPE: {
+                            type: ArgumentType.STRING,
+                            menu: 'ARRONDIS',
+                            defaultValue: ''
+                        },
+                         CHIFFRE: {
+                            type: ArgumentType.STRING,
+                            menu: 'CHIFFRE_ARRONDIS',
+                            defaultValue: ''
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'chiffre_pentiere',
+                    text: formatMessage({
+                        id: 'pm.pentiere',
+                        default: '[choix1] digit of [NUM1]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         choix1: {
+                            type: ArgumentType.STRING,
+                            menu: 'PARTIE_ENTIERE',
+                            defaultValue: ''
+                        }
+                    }
+                },
+                {
+                    opcode: 'chiffre_pdecimale',
+                    text: formatMessage({
+                        id: 'pm.pdecimale',
+                        default: '[choix1] digit of [NUM1]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         choix1: {
+                            type: ArgumentType.STRING,
+                            menu: 'PARTIE_DECIMALE',
+                            defaultValue: ''
+                        }
+                    }
+                },
+                {
+                    opcode: 'sommechiffres',
+                    text: formatMessage({
+                        id: 'pm.sommechiffres',
+                        default: 'somme des chiffres de [NUM1]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        }
+                    }
+                },
+                '---',
+                                {
+                    opcode: 'nombre_pi',
+                    text: formatMessage({
+                        id: 'pm.pi',
+                        default: 'π',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER
+                },
+                {
+                    opcode: 'oppose',
+                    text: formatMessage({
+                        id: 'pm.oppose',
+                        default: '- [NUM1]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        }
+                    }
+                },
+                {
+                    opcode: 'inverse',
+                    text: formatMessage({
+                        id: 'pm.inverse',
+                        default: '1 / [NUM1]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        }
+                    }
+                },
+                {
+                    opcode: 'pourcent',
+                    text: formatMessage({
+                        id: 'pm.pourcent',
+                        default: '[NUM1] %',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        }
+                    }
+                },
+                '---',
+                {
+                    opcode: 'random',
+                    text: formatMessage({
+                        id: 'pm.random',
+                        default: 'pick random [NUM1] to [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '1'
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '10'
+                        },
+                    }
+                },
+                '---',
+                {
+                    opcode: 'gt',
+                    text: formatMessage({
+                        id: 'pm.gt',
+                        default: '[NUM1] < [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '50'
+                        },
+                    }
+                },
+                {
+                    opcode: 'gte',
+                    text: formatMessage({
+                        id: 'pm.gte',
+                        default: '[NUM1] ≤ [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '50'
+                        },
+                    }
+                },
+                {
+                    opcode: 'equals',
+                    text: formatMessage({
+                        id: 'pm.equals',
+                        default: '[NUM1] = [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '50'
+                        },
+                    }
+                },
+                {
+                    opcode: 'lt',
+                    text: formatMessage({
+                        id: 'pm.lt',
+                        default: '[NUM1] > [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '50'
+                        },
+                    }
+                },
+                {
+                    opcode: 'lte',
+                    text: formatMessage({
+                        id: 'pm.lte',
+                        default: '[NUM1] ≥ [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '50'
+                        },
+                    }
+                },
+                {
+                    opcode: 'min',
+                    text: formatMessage({
+                        id: 'pm.min',
+                        default: 'mininum of [NUM1] and [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                {
+                    opcode: 'max',
+                    text: formatMessage({
+                        id: 'pm.max',
+                        default: 'maximum of [NUM1] and [NUM2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                         NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                '---',
+                 {
+                    opcode: 'and',
+                    text: formatMessage({
+                        id: 'pm.and',
+                        default: '[OPERAND1] and [OPERAND2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        OPERAND1: {
+                            type: ArgumentType.BOOLEAN,
+                            defaultValue: ' '
+                        },
+                         OPERAND2: {
+                            type: ArgumentType.BOOLEAN,
+                            defaultValue: ' '
+                        },
+                    }
+                },
+                {
+                    opcode: 'or',
+                    text: formatMessage({
+                        id: 'pm.or',
+                        default: '[OPERAND1] or [OPERAND2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        OPERAND1: {
+                            type: ArgumentType.BOOLEAN,
+                            defaultValue: ' '
+                        },
+                         OPERAND2: {
+                            type: ArgumentType.BOOLEAN
+                            
+                        },
+                    }
+                },
+                 {
+                    opcode: 'not',
+                    text: formatMessage({
+                        id: 'pm.not',
+                        default: 'not [OPERAND1]',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        OPERAND1: {
+                            type: ArgumentType.BOOLEAN,
+                            defaultValue: ' '
+                        }
+                    }
+                },
+                '---',
+                 {
+                    opcode: 'join',
+                    text: formatMessage({
+                        id: 'pm.join',
+                        default: 'join [STRING1] [STRING2]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        STRING1: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'Planète '
+                        },
+                         STRING2: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'Maths'
+                            
+                        },
+                    }
+                },
+                 {
+                    opcode: 'letterOf',
+                    text: formatMessage({
+                        id: 'pm.letterof',
+                        default: 'letter [LETTER] of [STRING]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        STRING: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'Maths'
+                        },
+                         LETTER: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '1'
+                            
+                        },
+                    }
+                },  
+                {
+                    opcode: 'length',
+                    text: formatMessage({
+                        id: 'pm.length',
+                        default: 'length of [STRING]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        STRING: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'Maths'
+                        }
+                    }
+                },
+                {
+                    opcode: 'contains',
+                    text: formatMessage({
+                        id: 'pm.contains',
+                        default: '[STRING1] contains [STRING2] ?',
+                        description: ''
+                    }),
+                    blockType: BlockType.BOOLEAN,
+                    arguments: {
+                        STRING1: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'Maths'
+                        },
+                         STRING2: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 's'
+                            
+                        },
+                    }
+                },
+                {
+                    opcode: 'extract',
+                    text: formatMessage({
+                        id: 'pm.extract',
+                        default: 'extract characters from [NUM1] to [NUM2] of [STRING]',
+                        description: ''
+                    }),
+                    blockType: BlockType.REPORTER,
+                    arguments: {
+                        STRING: {
+                            type: ArgumentType.STRING,
+                            defaultValue: 'Planète Maths'
+                        },
+                         NUM1: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '1'
+                        },
+                        NUM2: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: '7'
+                        },
+                    }
+                },
+            ],
+        menus: {
+            PARTIE_ENTIERE: {
+            items: [{
+                 text: formatMessage({
+              id:'text.c1',
+              default:'units'
+              }),
+              value: '0'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c2',
+              default:'tens'
+              }),
+              value: '1'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c3',
+              default:'hundreds'
+              }),
+              value: '2'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c4',
+              default:'thousands'
+              }),
+              value: '3'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c5',
+              default:'tens of thousands'
+              }),
+              value: '4'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c6',
+              default:'hundreds of thousands'
+              }),
+              value: '5'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c7',
+              default:'millions'
+              }),
+              value: '6'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c8',
+              default:'tens of millions'
+              }),
+              value: '7'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c9',
+              default:'hundreds of millions'
+              }),
+              value: '8'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c10',
+              default:'billions'
+              }),
+              value: '9'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c11',
+              default:'tens of billions'
+              }),
+              value: '10'
+                },
+                {
+                 text: formatMessage({
+              id:'text.c12',
+              default:'hundreds of billions'
+              }),
+              value: '11'
+                }
+
+
+
+                ]
+          },
+
+          PARTIE_DECIMALE: {
+            items: [
+            {
+                 text: formatMessage({
+              id:'text.d1',
+              default:'tenths'
+              }),
+              value: '1'
+                },
+                {
+                 text: formatMessage({
+              id:'text.d2',
+              default:'hundredths'
+              }),
+              value: '2'
+                },
+                {
+                 text: formatMessage({
+              id:'text.d3',
+              default:'thousandths'
+              }),
+              value: '3'
+                },
+                {
+                 text: formatMessage({
+              id:'text.d4',
+              default:'ten thousandths'
+              }),
+              value: '4'
+                },
+                {
+                 text: formatMessage({
+              id:'text.d5',
+              default:'hundred thousandths'
+              }),
+              value: '5'
+                },
+                {
+                 text: formatMessage({
+              id:'text.d6',
+              default:'millionths'
+              }),
+              value: '6'
+                }                
+                ]
+          },
+           CHIFFRE_ARRONDIS: {
+            items: [
+            { text: formatMessage({
+              id:'text.a0',
+              default:'the unit'
+              }),
+              value: '0'
+                },
+            {
+                 text: formatMessage({
+              id:'text.a1',
+              default:'tenth'
+              }),
+              value: '1'
+                },
+                {
+                 text: formatMessage({
+              id:'text.a2',
+              default:'hundredth'
+              }),
+              value: '2'
+                },
+                {
+                 text: formatMessage({
+              id:'text.a3',
+              default:'thousandth'
+              }),
+              value: '3'
+                },
+                {
+                 text: formatMessage({
+              id:'text.a4',
+              default:'ten thousandth'
+              }),
+              value: '4'
+                },
+                {
+                 text: formatMessage({
+              id:'text.a5',
+              default:'hundred thousandth'
+              }),
+              value: '5'
+                },
+                {
+                 text: formatMessage({
+              id:'text.a6',
+              default:'millionth'
+              }),
+              value: '6'
+                }                
+                ]
+          },
+          LIST_MATHOP: {
+            items: [
+            {
+             text: formatMessage({
+              id:'text.sqrt',
+              default:'√'
+              }),
+             value: 'sqrt'
+                },
+            {
+             text: formatMessage({
+              id:'text.cos',
+              default:'cos'
+              }),
+             value: 'cos'
+                },
+            {
+             text: formatMessage({
+              id:'text.sin',
+              default:'sin'
+              }),
+             value: 'sin'
+                },
+                 {
+             text: formatMessage({
+              id:'text.tan',
+              default:'tan'
+              }),
+             value: 'tan'
+                },
+                {
+             text: formatMessage({
+              id:'text.acos',
+              default:'arccos'
+              }),
+             value: 'acos'
+                },
+            {
+             text: formatMessage({
+              id:'text.asin',
+              default:'arcsin'
+              }),
+             value: 'asin'
+                },
+                 {
+             text: formatMessage({
+              id:'text.atan',
+              default:'arctan'
+              }),
+             value: 'atan'
+                },
+                    {
+             text: formatMessage({
+              id:'text.pow10',
+              default:'10 ^'
+              }),
+             value: '10 ^'
+                },
+
+
+
+            ]
+
+
+          },
+          LIST_MATHOP2: {
+            items: [
+            {
+             text: formatMessage({
+              id:'text.pgcd',
+              default:'GCD'
+              }),
+             value: 'pgcd'
+                },
+                 {
+             text: formatMessage({
+              id:'text.ppcm',
+              default:'LCM'
+              }),
+             value: 'ppcm'
+                },
+
+                ]
+            },
+             LIST_MATHOPDIV: {
+            items: [
+            {
+             text: formatMessage({
+              id:'text.reste',
+              default:'rest'
+              }),
+             value: 'reste'
+                },
+                 {
+             text: formatMessage({
+              id:'text.quotient',
+              default:'quotient'
+              }),
+             value: 'quotient'
+                },
+
+                ]
+            },
+            ARRONDIS: {
+            items: [
+            {
+             text: formatMessage({
+              id:'text.vad',
+              default:'Approximate value by defect of'
+              }),
+             value: 'vad'
+                },
+                 {
+             text: formatMessage({
+              id:'text.vae',
+              default:'Approximate value by excess of'
+              }),
+             value: 'vae'
+                },
+                 {
+             text: formatMessage({
+              id:'text.arrondi',
+              default:'Round'
+              }),
+             value: 'arrondi'
+                },
+
+                ]
+            },
+              MULTIPLE_DIVISEUR: {
+            items: [
+            {
+             text: formatMessage({
+              id:'text.multiple',
+              default:'multiple'
+              }),
+             value: 'multiple'
+                },
+                 {
+             text: formatMessage({
+              id:'text.diviseur',
+              default:'divider'
+              }),
+             value: 'diviseur'
+                },
+          
+
+                ]
+            }
+
+
+        },
+         translationMap: extensionTranslations
+        };
+    }
+
+add (args, util) {
+return Cast.toNumber(args.NUM1)+Cast.toNumber(args.NUM2);
+}
+
+substract (args, util) {
+        return Cast.toNumber(args.NUM1) - Cast.toNumber(args.NUM2);
+    }
+
+multiply (args, util) {
+        return Cast.toNumber(args.NUM1) * Cast.toNumber(args.NUM2);
+    }
+
+divide (args, util) {
+        return Cast.toNumber(args.NUM1) / Cast.toNumber(args.NUM2);
+    }
+
+pow (args, util) {
+        const n = Cast.toNumber(args.NUM1);
+        const m = Cast.toNumber(args.NUM2);
+        return Math.pow(n, m);;
+    }
+
+
+ gt (args) {
+        return Cast.compare(args.NUM1, args.NUM2) < 0;
+    }
+
+gte (args) {
+        return Cast.compare(args.NUM1, args.NUM2) <= 0;
+    }
+
+equals (args) {
+        return Cast.compare(args.NUM1, args.NUM2) === 0;
+    }
+
+ lt (args) {
+        return Cast.compare(args.NUM1, args.NUM2) > 0;
+    }
+ lte (args) {
+        return Cast.compare(args.NUM1, args.NUM2) >= 0;
+    }
+
+ min (args) {
+        return Math.min(Cast.toNumber(args.NUM1),Cast.toNumber(args.NUM2));
+    }
+
+max (args) {
+        return Math.max(Cast.toNumber(args.NUM1),Cast.toNumber(args.NUM2));
+    }
+
+ oppose (args) {
+        return -1*Cast.toNumber(args.NUM1);
+    }
+
+ inverse (args) {
+        return 1/Cast.toNumber(args.NUM1);
+    }
+random (args) {
+        const nFrom = Cast.toNumber(args.NUM1);
+        const nTo = Cast.toNumber(args.NUM2);
+        const low = nFrom <= nTo ? nFrom : nTo;
+        const high = nFrom <= nTo ? nTo : nFrom;
+        if (low === high) return low;
+        // If both arguments are ints, truncate the result to an int.
+        if (Cast.isInt(args.NUM1) && Cast.isInt(args.NUM2)) {
+            return low + Math.floor(Math.random() * ((high + 1) - low));
+        }
+        return (Math.random() * (high - low)) + low;
+    }
+
+
+
+    and (args) {
+        return Cast.toBoolean(args.OPERAND1) && Cast.toBoolean(args.OPERAND2);
+    }
+
+    or (args) {
+        return Cast.toBoolean(args.OPERAND1) || Cast.toBoolean(args.OPERAND2);
+    }
+
+    not (args) {
+        return !Cast.toBoolean(args.OPERAND1);
+    }
+
+pourcent (args, util) {
+return Cast.toNumber(args.NUM1)/100;
+}
+
+mathop (args, util) {
+        const operator = Cast.toString(args.OPERATOR).toLowerCase();
+        const n = Cast.toNumber(args.NUM1);
+        switch (operator) {
+        case 'sqrt': return Math.sqrt(n);
+        case 'sin': return parseFloat(Math.sin((Math.PI * n) / 180).toFixed(10));
+        case 'cos': return parseFloat(Math.cos((Math.PI * n) / 180).toFixed(10));
+        case 'tan': return MathUtil.tan(n);
+        case 'asin': return (Math.asin(n) * 180) / Math.PI;
+        case 'acos': return (Math.acos(n) * 180) / Math.PI;
+        case 'atan': return (Math.atan(n) * 180) / Math.PI;
+        case '10 ^': return Math.pow(10, n);
+        }
+        return 0;
+    }
+
+mathop2 (args, util) {
+ const operator = Cast.toString(args.OPERATOR).toLowerCase();
+        const n1 = Cast.toNumber(args.NUM1);
+        const n2 = Cast.toNumber(args.NUM2);
+         if (Number.isInteger(n1) && Number.isInteger(n2)) {
+        switch (operator) {
+        case 'pgcd': return this.pgcd(n1,n2);
+        case 'ppcm': return n1*n2/this.pgcd(n1,n2);
+        }
+        return 0;}
+        return ""
+    }
+
+
+mathopdiv (args, util) {
+ const operator = Cast.toString(args.OPERATOR).toLowerCase();
+        const n1 = Cast.toNumber(args.NUM1);
+        const n2 = Cast.toNumber(args.NUM2);
+        if (Number.isInteger(n1) && Number.isInteger(n2)) {
+        let result = n1 % n2;
+        if (result / n2 < 0) result += n2;
+        switch (operator) {
+        case 'reste': return result;
+        case 'quotient': return (n1-result)/n2;
+        }
+        return 0;}
+return ""
+
+    }
+
+    arrondis (args, util) {
+ const type = Cast.toString(args.TYPE).toLowerCase();
+const n1 = Cast.toNumber(args.NUM1);
+const c = Cast.toNumber(args.CHIFFRE);
+        switch (type) {
+        case 'vad': return Math.floor(n1*Math.pow(10,c))/Math.pow(10,c);
+        case 'vae': return Math.floor(n1*Math.pow(10,c)+1)/Math.pow(10,c);
+        case 'arrondi': return Math.round(n1*Math.pow(10,c))/Math.pow(10,c);
+        }
+        return 0;
+    }
+
+    sqrt (args, util) {
+        return Math.sqrt(Cast.toNumber(args.NUM1));
+    }
+
+chiffre_pentiere(args, util) {
+return Math.floor(Cast.toNumber(args.NUM1)/Math.pow(10,Cast.toNumber(args.choix1)))-Math.floor(Cast.toNumber(args.NUM1)/Math.pow(10,Cast.toNumber(args.choix1)+1))*10;
+}
+
+chiffre_pdecimale(args, util) {
+return Math.floor(Cast.toNumber(args.NUM1)*Math.pow(10,Cast.toNumber(args.choix1)))-Math.floor(Cast.toNumber(args.NUM1)*Math.pow(10,Cast.toNumber(args.choix1)-1))*10;
+}
+
+multiple(args){
+const type = Cast.toString(args.choix1).toLowerCase();
+const n1 = Cast.toNumber(args.NUM1);
+const n2 = Cast.toNumber(args.NUM2);
+if (Number.isInteger(n1) && Number.isInteger(n2)) {
+        switch (type) {
+        case 'multiple': return n1 % n2 === 0;
+        case 'diviseur': return n2 % n1 === 0;
+        }
+        return 0;
+    }
+    return ""
+    
+}
+
+sommechiffres(args){
+
+var value = Cast.toNumber(args.NUM1);
+var somme = 0;
+ if (Number.isInteger(value)) {
+while (value) {
+    somme += value % 10;
+    value = Math.floor(value / 10);
+}
+return somme;}
+return "";
+    }
+
+
+pgcd(a, b) {
+    if (b) {
+        return this.pgcd(b, a % b);
+    } else {
+        return Math.abs(a);
+    }
+}
+
+nombre_pi(args, util){
+    return Math.PI;
+}
+
+ join (args) {
+        return Cast.toString(args.STRING1) + Cast.toString(args.STRING2);
+    }
+
+    letterOf (args) {
+        const index = Cast.toNumber(args.LETTER) - 1;
+        const str = Cast.toString(args.STRING);
+        // Out of bounds?
+        if (index < 0 || index >= str.length) {
+            return '';
+        }
+        return str.charAt(index);
+    }
+
+    length (args) {
+        return Cast.toString(args.STRING).length;
+    }
+
+    contains (args) {
+        const format = function (string) {
+            return Cast.toString(string).toLowerCase();
+        };
+        return format(args.STRING1).includes(format(args.STRING2));
+    }
+
+reverseString(str) {
+  if (str === "")
+    return "";
+  else
+    return this.reverseString(str.substr(1)) + str.charAt(0);
+}
+
+extract (args) {
+        const from = Cast.toNumber(args.NUM1)-1;
+        const to = Cast.toNumber(args.NUM2)-Cast.toNumber(args.NUM1)+1;
+        const str = Cast.toString(args.STRING);
+        const rts = this.reverseString(str);
+        // Out of bounds?
+        if (to < 0) {
+            return rts.substr(rts.length-from-1,2-to);
+        }
+        return str.substr(from,to)
+    }
+
+  setupTranslations () {
+        const localeSetup = formatMessage.setup();
+        if (localeSetup && localeSetup.translations[localeSetup.locale]) {
+            Object.assign(
+                localeSetup.translations[localeSetup.locale],
+                // eslint-disable-next-line no-use-before-define
+                extensionTranslations[localeSetup.locale]
+            );
+        }
+    }
+
+}
+
+const extensionTranslations = {
+    'de': {
+'pm.mathop':'[OPERATOR] von [NUM1]',
+'pm.mathopdiv':'[OPERATOR] der Division von [NUM1] durch [NUM2]',
+'pm.mathop2':'[OPERATOR] von [NUM1] und [NUM2]',
+'text.pgcd':'ggT',
+'text.ppcm':'kgV',
+'text.reste':'Rest',
+'text.quotient':'Quotient',
+'pm.multiple': '[NUM1] ist ein [choix1] von [NUM2]',
+'text.multiple':'Vielfaches',
+'text.diviseur':'Teiler',
+'text.vad':'Abrundung',
+'text.vae':'Aufrundung',
+'text.arrondi':'Rundung',
+'text.c1':'Einerstelle',
+'text.c2':'Zehnerstelle', 
+'text.c3':'Hunderterstelle', 
+'text.c4':'Tausenderstelle', 
+'text.c5':'Zehntausenderstelle', 
+'text.c6':'Hunderttausenderstelle',
+'text.c7':'Einmillionstelle',
+'text.c8':'Zehnmillionstelle',
+'text.c9':'Hundertmillionstelle',
+'text.c10':'Einmilliardenstelle',
+'text.c11':'Zehnmilliardenstelle',
+'text.c12':'Hundertmilliardenstelle',
+'pm.pentiere':'[choix1] von [NUM1]',
+'pm.pdecimale':'[choix1] von [NUM1]',
+'pm.sommechiffres':'Quersumme von [NUM1]',
+'pm.arrondis':'[TYPE] von [NUM1] auf [CHIFFRE]',
+'pm.random':'Zufallszahl von [NUM1] bis [NUM2]',
+'pm.min':'Mininum von [NUM1] und [NUM2]',
+'pm.max':'Maximum von [NUM1] und [NUM2]',
+'pm.and':'[OPERAND1] und [OPERAND2]',
+'pm.or':'[OPERAND1] oder [OPERAND2]',
+'pm.not':'nicht [OPERAND1]',
+'pm.join':'verbinde [STRING1] und [STRING2]',
+'pm.letterof':'Zeichen [LETTER] von [STRING]',
+'pm.length':'Länge von [STRING]',
+'pm.contains':'[STRING1] enthält [STRING2] ?',
+'pm.extract':'Extrahieren der Zeichen [NUM1] bis [NUM2] aus [STRING]',
+'text.d1':'Zehntelstelle',
+'text.d2':'Hundertstelstelle', 
+'text.d3':'Tausendstelstelle', 
+'text.d4':'Zehntausendstelstelle', 
+'text.d5':'Hunderttausendstelstelle', 
+'text.d6':'Millionstelstelle',
+'text.a0':'Einer',
+'text.a1':'Zehntel', 
+'text.a2':'Hundertstel', 
+'text.a3':'Tausendstel', 
+'text.a4':'Zehntausendstel', 
+'text.a5':'Hunderttausendstel',
+'text.a6':'Millionstel',
+'pm.title':'Mathe'
+        },
+
+    'fr': {
+'pm.mathop':'[OPERATOR] de [NUM1]',
+'pm.mathopdiv':'[OPERATOR] de [NUM1] divisé par [NUM2]',
+'pm.mathop2':'[OPERATOR] de [NUM1] et [NUM2]',
+'text.pgcd':'PGCD',
+'text.ppcm':'PPCM',
+'text.reste':'reste',
+'text.quotient':'quotient',
+'pm.multiple': '[NUM1] est un [choix1] de [NUM2]',
+'text.multiple':'multiple',
+'text.diviseur':'diviseur',
+'text.vad':'Valeur approchée par défaut',
+'text.vae':'Valeur approchée par excès',
+'text.arrondi':'Arrondi',
+'text.c1':'unités',
+'text.c2':'dizaines', 
+'text.c3':'centaines', 
+'text.c4':'unités de mille', 
+'text.c5':'dizaines de mille', 
+'text.c6':'centaines de mille',
+'text.c7':'unités de millions',
+'text.c8':'dizaines de millions',
+'text.c9':'centaines de millions',
+'text.c10':'unités de milliards',
+'text.c11':'dizaines de milliards',
+'text.c12':'centaines de milliards',
+'pm.pentiere':'chiffre des [choix1] de [NUM1]',
+'pm.pdecimale':'chiffre des [choix1] de [NUM1]',
+'pm.sommechiffres':'somme des chiffres de [NUM1]',
+'pm.arrondis':'[TYPE] de [NUM1] [CHIFFRE]',
+'pm.random':'nombre aléatoire entre [NUM1] et [NUM2]',
+'pm.min':'mininum de [NUM1] et [NUM2]',
+'pm.max':'maximum de [NUM1] et [NUM2]',
+'pm.and':'[OPERAND1] et [OPERAND2]',
+'pm.or':'[OPERAND1] ou [OPERAND2]',
+'pm.not':'non [OPERAND1]',
+'pm.join':'regrouper [STRING1] et [STRING2]',
+'pm.letterof':'lettre [LETTER] de [STRING]',
+'pm.length':'longueur de [STRING]',
+'pm.contains':'[STRING1] contient [STRING2] ?',
+'pm.extract':'extraire caractères [NUM1] à [NUM2] de [STRING]',
+'text.d1':'dixièmes',
+'text.d2':'centièmes', 
+'text.d3':'millièmes', 
+'text.d4':'dix-millièmes', 
+'text.d5':'cent-millièmes', 
+'text.d6':'millionièmes',
+'text.a0':'à l\'unité',
+'text.a1':'au dixième', 
+'text.a2':'au centième', 
+'text.a3':'au millième', 
+'text.a4':'au dix-millième', 
+'text.a5':'au cent-millième',
+'text.a6':'au millionième',
+'pm.title':'Maths'
+        }
+    };
+module.exports = Scratch3PMBlocks;
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_qrcode/index.js b/node_modules/scratch-vm/src/extensions/scratch3_qrcode/index.js
new file mode 100644
index 0000000..0d83bc5
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_qrcode/index.js
@@ -0,0 +1,406 @@
+// Importation des modules nécessaires pour l'extension Scratch
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const TargetType = require('../../extension-support/target-type');
+const Cast = require('../../util/cast.js');
+const formatMessage = require('format-message'); // Gestion des messages multilingues
+const Video = require('../../io/video');
+const StageLayering = require('../../engine/stage-layering');
+
+const jsQR = require('jsqr'); //Reconnaissance de QR Code
+
+
+const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDgwIDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zOnNlcmlmPSJodHRwOi8vd3d3LnNlcmlmLmNvbS8iIHN0eWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MS41OyI+CiAgICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCg1LjUxODIyLDAsMCwxMC45Mjg1LC02ODEuOTk4LC0xOTkuNjE0KSI+CiAgICAgICAgPHJlY3QgeD0iMTIzLjU5NCIgeT0iMTguMTY5IiB3aWR0aD0iNjYuMzEyIiBoZWlnaHQ9IjMzLjEzNyIgc3R5bGU9ImZpbGw6cmdiKDEzLDE4OSwxNDApO3N0cm9rZTpyZ2IoMTMsMTg5LDE0MCk7c3Ryb2tlLXdpZHRoOjAuMTJweDsiLz4KICAgIDwvZz4KICAgIDxnIGlkPSJBc3NvY2llciIgdHJhbnNmb3JtPSJtYXRyaXgoMC43MjQzNjIsMCwwLDAuNzI0MzYyLDUuMjgyNiw0LjY2Mzk3KSI+CiAgICAgICAgPHVzZSB4bGluazpocmVmPSIjX0ltYWdlMSIgeD0iMCIgeT0iMCIgd2lkdGg9Ijk3cHgiIGhlaWdodD0iOTdweCIvPgogICAgPC9nPgogICAgPGRlZnM+CiAgICAgICAgPGltYWdlIGlkPSJfSW1hZ2UxIiB3aWR0aD0iOTdweCIgaGVpZ2h0PSI5N3B4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUdFQUFBQmhDQVlBQUFER0JzK2pBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBQ0hFbEVRVlI0bk8yY3kyN0RJQkFBY1pYLy85eGMzVnNWV1EzbXNjRFlucm0yQ2xpalhmQjZZZHYzZlUreWxKL1ZFeEFsSUZBQ0FDVUFVQUlBSlFCUUFnQWxBRkFDQUNVQWVKWCs0N1p0SStmeHgyY1ZKV3JNWTJWbXhyUFVWSU9NQkFCS0FGQ2NqbzVFRlY5bnBibHZFSjdEU0FDZ0JBQktBTkM4Smh3cHpZazFPYmgxYTltVDUydHllOVI2WWlRQVVBSUFKUUFJV3hObWsxc3Zqbm1kM2xCaUpBQlFBZ0IwT3FwSkt5T3FyN013RWdBb0FZQVNBSVN0Q2JPM2dibjFvbWN1SzdhelJnSUFKUUJvVGtma2JXRE4xcGJ3SEVZQ0FDVUFVQUtBalh4bXJUVmZneC9wWDR3RUFFb0FvQVFBUXhxQ2UvYmxFZmw4VkNOeHpUZzJCRjhNSlFBWThtV3RwOEpaR3VJelB1YWZqUkgxTmM5SUFLQUVBRW9BVUx3bTlPVHl6NytkTmZuT0tEbms1bE16bDZpdHNKRUFRQWtBd3Fxb1VXK1BwYW1yNXEyOGRmd2pvMUtsa1FCQUNRQ1VBQ0NzMjZMMEZUNnFpaHBWR3NtVklzN0d6R0VWOVdJb0FjQ2xQdlNYcHJ5ZVcxMW1WMnBUTWhJUUtBR0FFZ0FVcndrcmJ2N0tRYnU5cTJmOU1CSUFLQUdBRWdDZ3IxOWJjWURETTJzUFJRa0Fibm56Vnc4cnprUVlDUUNVQUVBSkFOQlg3ZVFnVk9CdC9yb1JTZ0NBVGtjMWI5TlJEV2FsNDBmT3gwZ0FvQVFBU2dCd3FadS9JaHJEem41blJlWFdTQUNnQkFCS0FIQ3A2OWRHbkRYck9adnNPZVlib1FRQTZJYmdwMkFrQUZBQ0FDVUFVQUlBSlFCUUFnQWxBRkFDQUNVQWVLV1UzcXNuOFhSK0FXQjI3clB3UXk3Q0FBQUFBRWxGVGtTdVFtQ0MiLz4KICAgIDwvZGVmcz4KPC9zdmc+Cg==';
+
+// Définition des langues disponibles pour l'interface utilisateur
+const AvailableLocales = ['en', 'fr', 'de'];
+
+// Messages traduits pour chaque fonctionnalité du scanner QR code
+const Message = {
+    qrCode: {
+        'en': 'QR Code',
+        'fr': 'QR Code',
+        'de': 'QR code'
+    },
+    qrStart: {
+        'en': 'start scanning',
+        'fr': 'commencer le scan',
+        'de': 'Scannen starten'
+    },
+    qrStop: {
+        'en': 'stop scanning',
+        'fr': 'arrêter le scan',
+        'de': 'Scannen beenden'
+    },
+    qrScanning: {
+        'en': 'scanning?',
+        'fr': 'scan actif ?',
+        'de': 'aktiven Scan ?'
+    },
+    qrSetInterval: {
+        'en': 'set scan interval [INTERVAL] sec',
+        'fr': 'définir l\'intervalle de scan à [INTERVAL] sec',
+        'de': 'Abfrageintervall einstellen [INTERVALL] sec'
+    },
+    qrData: {
+        'en': 'data from the last QR code scanned',
+        'fr': 'données du dernier code QR scanné',
+        'de': 'Daten des zuletzt gescannten QR-Codes'
+    },
+    qrReset: {
+        'en': 'reset scanned data',
+        'fr': 'effacer données scannées',
+        'de': 'gescannte Daten zurücksetzen'
+    },
+    qrSetCameraTransparency: {
+        'en': 'set camera transparency to [TRANSPARENCY]',
+        'fr': 'définir la transparence de la caméra à [TRANSPARENCY]'
+    },
+    videoToggle: {
+        'en': 'turn video [VIDEO_STATE]',
+        'fr': 'mettre caméra sur [VIDEO_STATE]',
+        'de': 'schalte Video [VIDEO_STATE]'
+    },
+    onfront: {
+        'en': 'front camera on',
+        'fr': 'allumer caméra avant',
+        'de': 'Frontkamera einschalten'
+    },
+    onback: {
+        'en': 'back camera on',
+        'fr': 'allumer caméra arrière',
+        'de': 'Rückfahrkamera einschalten'
+    },
+    off: {
+        'en': 'camera off',
+        'fr': 'arrêter la caméra',
+        'de': 'Stopp Kamera'
+    },
+    video_on_flipped: {
+        'en': 'flip camera image',
+        'fr': 'retourner l\'image de la caméra',
+        'de': 'Kameraspiegel'
+    },
+};
+
+
+// Valeur par défaut de l'intervalle de scan
+const DefaultInterval = 300;
+
+// Dimensions par défaut de la scène
+const DefaultStageWidth = 480;
+const DefaultStageHeight = 360;
+
+// Attributs du marqueur visuel pour la détection des QR codes
+const MakerAttributes = {
+    color4f: [1, 0, 0, 0.7], // Rouge avec transparence de 0.7
+    diameter: 4
+};
+
+
+// Classe utilitaire pour gérer les transformations des QR codes
+class QRUtils {
+    // Méthode statique pour ajuster l'emplacement du QR code selon les dimensions
+    static scaleLocation(location, width, height) {
+        const widthScale = DefaultStageWidth / width;
+        const heightScale = DefaultStageHeight / height;
+        const halfWidth = width / 2 * widthScale;
+
+        // Retourne les coordonnées ajustées pour chaque coin du QR code
+        return {
+            topLeftCorner: {
+                x: location.topLeftCorner.x * widthScale - halfWidth,
+                y: height / 2 * heightScale - location.topLeftCorner.y * heightScale
+            },
+            topRightCorner: {
+                x: location.topRightCorner.x * widthScale - halfWidth,
+                y: height / 2 * heightScale - location.topRightCorner.y * heightScale
+            },
+            bottomRightCorner: {
+                x: location.bottomRightCorner.x * widthScale - halfWidth,
+                y: height / 2 * heightScale - location.bottomRightCorner.y * heightScale
+            },
+            bottomLeftCorner: {
+                x: location.bottomLeftCorner.x * widthScale - halfWidth,
+                y: height / 2 * heightScale - location.bottomLeftCorner.y * heightScale
+            }
+        };
+    }
+
+    // Méthode statique pour dessiner un carré autour du QR code
+    static drawSquare(renderer, skinId, location) {
+        // Dessine les lignes reliant les coins du QR code pour former un carré
+        renderer.penLine(skinId, MakerAttributes, location.topLeftCorner.x, location.topLeftCorner.y, location.topRightCorner.x, location.topRightCorner.y);
+        renderer.penLine(skinId, MakerAttributes, location.topRightCorner.x, location.topRightCorner.y, location.bottomRightCorner.x, location.bottomRightCorner.y);
+        renderer.penLine(skinId, MakerAttributes, location.bottomRightCorner.x, location.bottomRightCorner.y, location.bottomLeftCorner.x, location.bottomLeftCorner.y);
+        renderer.penLine(skinId, MakerAttributes, location.bottomLeftCorner.x, location.bottomLeftCorner.y, location.topLeftCorner.x, location.topLeftCorner.y);
+    }
+}
+
+
+
+// Définition de la classe pour gérer les blocs liés au QR code dans Scratch
+class Scratch3QRCodeBlocks {
+
+    // Menu pour gérer l'état de la caméra vidéo
+    get VIDEO_MENU() {
+        return [
+            'onback', 'onfront', 'video_on_flipped', 'off'
+        ].map(key => ({
+            text: Message[key][this.locale],
+            value: key
+        }));
+    }
+
+    // Constructeur de la classe, initialise les variables et événements
+    constructor(runtime) {
+        this.runtime = runtime;
+        this.locale = this.setLocale(); // Définit la langue
+        this._canvas = document.querySelector('canvas'); // Référence au canvas de la scène
+        this._scanning = false; // Indicateur si un scan est actif
+        this._interval = DefaultInterval; // Intervalle de scan par défaut
+        this._data = ''; // Données du dernier code scanné
+        this._binaryData = null;  // Données binaires du QR code
+
+        // Lorsque le projet s'arrête, arrêter aussi le scan QR
+        this.runtime.on('PROJECT_STOP_ALL', this.qrStop.bind(this));
+
+        // Création d'un "skin" pour dessiner les marques
+        this._penSkinId = this.runtime.renderer.createPenSkin();
+        const penDrawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);
+        this.runtime.renderer.updateDrawableProperties(penDrawableId, {
+            skinId: this._penSkinId
+        });
+    }
+
+
+    // Fournit des informations sur les blocs disponibles
+    getInfo() {
+        return {
+            id: 'qrcode',
+            name: Message.qrCode[this.locale],
+            color1: '#00a4a6',
+            color2: '#006a6b',
+            blockIconURI: blockIconURI,
+            blocks: [{
+                    opcode: 'qrStart',
+                    text: Message.qrStart[this.locale],
+                    blockType: BlockType.COMMAND
+
+                },
+                {
+                    opcode: 'qrStop',
+                    text: Message.qrStop[this.locale],
+                    blockType: BlockType.COMMAND
+                },
+                {
+                    opcode: 'qrScanning',
+                    text: Message.qrScanning[this.locale],
+                    blockType: BlockType.BOOLEAN
+                },
+                '---',
+                '---',
+                {
+                    opcode: 'videoToggle',
+                    blockType: BlockType.COMMAND,
+                    text: Message.videoToggle[this.locale],
+                    arguments: {
+                        VIDEO_STATE: {
+                            type: ArgumentType.STRING,
+                            menu: 'videoMenu',
+                            defaultValue: 'onback'
+                        }
+                    }
+                },
+                {
+                    opcode: 'setVideoTransparency',
+                    text: formatMessage({
+                        id: 'videoSensing.setVideoTransparency',
+                        default: 'set video transparency to [TRANSPARENCY]',
+                        description: 'Controls transparency of the video preview layer'
+                    }),
+                    arguments: {
+                        TRANSPARENCY: {
+                            type: ArgumentType.NUMBER,
+                            defaultValue: 50
+                        }
+                    }
+                },
+                '---',
+                '---',
+                {
+                    opcode: 'qrSetInterval',
+                    text: Message.qrSetInterval[this.locale],
+                    blockType: BlockType.COMMAND,
+                    arguments: {
+                        INTERVAL: {
+                            type: ArgumentType.NUMBER,
+                            menu: 'intervalMenu',
+                            defaultValue: 0.3
+                        }
+                    }
+                },
+
+                '---',
+                '---',
+                {
+                    opcode: 'qrData',
+                    text: Message.qrData[this.locale],
+                    blockType: BlockType.REPORTER
+                },
+
+                {
+                    opcode: 'qrReset',
+                    text: Message.qrReset[this.locale],
+                    blockType: BlockType.COMMAND
+                }
+
+            ],
+            menus: {
+                intervalMenu: {
+                    acceptReporters: false,
+                    items: ['0.3', '0.5', '1']
+                },
+                videoMenu: {
+                    acceptReporters: true,
+                    items: this.VIDEO_MENU
+                },
+            }
+        }
+    };
+
+    // Efface les marques de QR code dessinées sur la scène
+    clearMark() {
+        this.runtime.renderer.penClear(this._penSkinId);
+    }
+
+    // Fonction principale qui lance le scan des QR codes
+    scan(){
+
+        if(!this._scanning ||  (!this.runtime.ioDevices.video.videoReady)){// Si le scan n'est pas actif ou la vidéo n'est pas prête on continue
+            
+        }
+        else {
+            // Récupère la frame vidéo pour analyser le QR code
+        let frame = null;
+        let width, height;
+        frame = this.runtime.ioDevices.video.getFrame({
+                format: Video.FORMAT_IMAGE_DATA,
+                dimensions: Video.DIMENSIONS
+            }).data;
+            width = DefaultStageWidth;
+            height = DefaultStageHeight;
+        
+            // Analyse la frame pour détecter un QR code
+        const code = jsQR(frame, width, height, {
+            inversionAttempts: 'dontInvert',
+        });
+
+
+        this.clearMark();
+        if(code){
+            this._data = code.data; // Enregistre les données du QR code
+            this.drawMark(code.location, width, height); // Dessine une marque autour du QR code détecté
+        }
+    }
+        setTimeout(this.scan.bind(this), this._interval); // Relance le scan après l'intervalle spécifié
+    }
+
+    // Dessine la marque sur la position du QR code détecté
+    drawMark(location, width, height) {
+        const scaledLocation = QRUtils.scaleLocation(location, width, height);
+        QRUtils.drawSquare(this.runtime.renderer, this._penSkinId, scaledLocation);
+    }
+
+
+    // Décodage des données binaires du QR code
+    decodeBinaryData(binaryData) {
+        try {
+             const encode = typeof binaryData === 'string' ? binaryData : 'UTF-8'; // Défaut à UTF-8 si non spécifié
+            return new TextDecoder(encode).decode(Uint8Array.from(binaryData).buffer);
+        } catch (e) {
+            console.error('Erreur lors du décodage des données binaires:', e);
+            return ''; // Retourne une chaîne vide en cas d'erreur
+        }
+    }
+
+    // Commande pour démarrer le scan
+    qrStart(args, util) {
+        if (this._scanning) return; // Si le scan est déjà actif, quitter
+
+        if (this.runtime.ioDevices.video.videoReady) {
+            this.scan(); // Lance le scan
+            this._scanning = true; // Indique que le scan est en cours
+        } else {
+            alert('Il faut d\'abord activer la vidéo'); // Message si la vidéo n'est pas active
+        }
+    }
+
+
+    // Commande pour arrêter le scan
+    qrStop(args, util) {
+        if (this._scanning) {
+            this.runtime.ioDevices.video.disableVideo();
+            this.clearMark();
+            this._scanning = false;
+        }
+    }
+
+    // Commande pour définir l'intervalle de scan
+    qrSetInterval(args, util) {
+        this._interval = args.INTERVAL * 1000;
+    }
+
+    // Renvoie si le scan est actif ou non
+    qrScanning(args, util) {
+        return this._scanning;
+    }
+
+    // Renvoie les données du dernier QR code scanné
+    qrData(args, util) {
+        return this._data;
+    }
+
+    // Réinitialise les données scannées
+    qrReset(args, util) {
+        this._data = '';
+        this._binaryData = null;
+    }
+
+    // Fonction permettant d'activer la vidéo et de changer de caméra
+    videoToggle(args) {
+        switch (args.VIDEO_STATE) {
+            case 'off':
+                this.runtime.ioDevices.video.disableVideo();
+                break;
+            case 'onback':
+                this.runtime.ioDevices.video.enableVideo('environment');
+                this.runtime.ioDevices.video.mirror = false;
+                break;
+            case 'onfront':
+                this.runtime.ioDevices.video.enableVideo('user');
+                this.runtime.ioDevices.video.mirror = true;
+                break;
+            default:
+                this.runtime.ioDevices.video.mirror = !this.runtime.ioDevices.video.mirror;
+        }
+
+    }
+
+    // Fonction permettant de changer la transparence d'affichage de la caméra sur la scène
+    setVideoTransparency(args) {
+        const transparency = Cast.toNumber(args.TRANSPARENCY);
+        this.globalVideoTransparency = transparency;
+        this.runtime.ioDevices.video.setPreviewGhost(transparency);
+    }
+
+    // Fonction permettant de définir la langue de l'extension en fonction de la langue définit dans Scratch.
+    // Si la traduction d'une langue n'est pas disponible dans l'extension, c'est l'anglais qui est choisi
+    setLocale() {
+        let locale = formatMessage.setup().locale;
+        return AvailableLocales.includes(locale) ? locale : 'en';
+    }
+
+}
+
+module.exports = Scratch3QRCodeBlocks;
\ No newline at end of file
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_text/index.js b/node_modules/scratch-vm/src/extensions/scratch3_text/index.js
new file mode 100644
index 0000000..42969d9
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_text/index.js
@@ -0,0 +1,725 @@
+const formatMessage = require('format-message');
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const Clone = require('../../util/clone');
+const Timer = require('../../util/timer');
+const StageLayering = require('../../engine/stage-layering');
+
+const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMjcuODM0IDlhMyAzIDAgMDEyLjU0NiAxLjQxMmwuMDk3LjE2Ny4wNTQuMTEuMDUyLjExMi4wNDguMTEyIDYuMjIyIDE2YTMuMDAxIDMuMDAxIDAgMDEtMi4yNyA0LjA0MWwtLjE4LjAyNS0uMTE1LjAxMS0uMTE2LjAwNy0uMTE1LjAwM2gtMS44NTVhMyAzIDAgMDEtMi41NDUtMS40MTJsLS4wOTYtLjE2Ny0uMTA3LS4yMjItLjA0OC0uMTExTDI4Ljk4MyAyOGgtNC45M2wtLjQyMiAxLjA4N2EzLjAwMyAzLjAwMyAwIDAxLTIuNDEgMS44ODlsLS4xOTMuMDE4LS4xOTQuMDA2LTEuOTQtLjAwMi0uMDk2LjAwMkg3YTMgMyAwIDAxLTIuODctMy44NzJsLjA3Mi0uMjA5IDYuMTgzLTE2YTMuMDAxIDMuMDAxIDAgMDEyLjYwNC0xLjkxM0wxMy4xODQgOWwzLjkuMDAxLjA5OS0uMDAxIDMuOTI0LjAwMi4wOTUtLjAwMiAzLjkwNS4wMDIuMDk1LS4wMDJoMi42MzJ6IiBmaWxsLW9wYWNpdHk9Ii4xNSIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yNS42NjMgMjFsLjgxNi0yLjA5OS44MTYgMi4wOTloLTEuNjMyem0xMC4yNTggNi4yNzVsLTYuMjIzLTE2LS4wNzUtLjE2OC0uMDg1LS4xNDVjLS4zODctLjYxMS0xLjAxOS0uOTYyLTEuNzAzLS45NjJoLTIuNjMzbC0uMDk2LjAwMi0uMDYyLS4wMDFMMjEuMjAyIDEwbC0uMDk2LjAwMi0uMDYyLS4wMDFMMTcuMTgzIDEwbC0uMDg2LjAwMkwxMy4xODQgMTBsLS4xNjUuMDA3YTIuMDAzIDIuMDAzIDAgMDAtMS43MDIgMS4yNzJsLTYuMTgyIDE2LS4wNTkuMTc1QTIgMiAwIDAwNyAzMGgxMS43OThsLjA4OC0uMDAyIDEuOTQ5LjAwMi4xNjMtLjAwNy4xNjEtLjAxOWEyIDIgMCAwMDEuNTM5LTEuMjQ5bC42Ny0xLjcyNWg2LjI5OWwuNjcyIDEuNzI2LjA3NC4xNjcuMDg2LjE0NWMuMzg3LjYxMSAxLjAxOC45NjIgMS43MDMuOTYyaDEuODU1bC4xNzQtLjAwOS4xNjQtLjAyNGMuOTc2LS4xODcgMS42NjItMS4wMDMgMS42NjItMS45NjcgMC0uMjQ4LS4wNDYtLjQ5NC0uMTM2LS43MjV6IiBmaWxsLW9wYWNpdHk9Ii4yNSIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0xMy4xODMgMTFoMy44MThhMSAxIDAgMDEuOTQxIDEuMzM4bC01Ljc0MiAxNmExIDEgMCAwMS0uOTQuNjYySDdhMSAxIDAgMDEtLjkzMy0xLjM2bDYuMTgzLTE2YTEgMSAwIDAxLjkzMy0uNjR6IiBmaWxsPSIjNEM5N0ZGIi8+PHBhdGggZD0iTTE3LjE4MyAxMUgyMWExIDEgMCAwMS45NDIgMS4zMzhsLTUuNzQyIDE2YTEgMSAwIDAxLS45NDEuNjYyaC00LjI2YTEgMSAwIDAxLS45MzItMS4zNmw2LjE4My0xNmExIDEgMCAwMS45MzMtLjY0eiIgZmlsbD0iI0NGNjNDRiIvPjxwYXRoIGQ9Ik0yMS4yMDIgMTFIMjVhMSAxIDAgMDEuOTMzIDEuMzYxbC02LjIwMyAxNmExIDEgMCAwMS0uOTMyLjYzOUgxNWExIDEgMCAwMS0uOTMzLTEuMzYxbDYuMjAzLTE2YTEgMSAwIDAxLjkzMi0uNjM5eiIgZmlsbD0iI0ZGQkYwMCIvPjxwYXRoIGQ9Ik0yNy44MzQgMTFhMSAxIDAgMDEuOTMyLjYzOGw2LjIyMiAxNkExIDEgMCAwMTM0LjA1NiAyOWgtMS44NTRhMSAxIDAgMDEtLjkzMi0uNjM4TDMwLjM1MSAyNmgtNy42NjZsLS45MTkgMi4zNjJhMSAxIDAgMDEtLjkzMi42MzhIMTguOThhMSAxIDAgMDEtLjkzMi0xLjM2Mmw2LjIyMi0xNmExIDEgMCAwMS45MzItLjYzOHptLTEuMzE2IDUuMTQzTDI0LjI0IDIyaDQuNTU2bC0yLjI3OC01Ljg1N3oiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+';
+const menuIconURI = blockIconURI;
+const DefaultText = formatMessage({
+  id: 'text.defaulttext',
+  default: 'Hello world !',
+  description: ''
+})
+const DefaultAnimateText = formatMessage({
+  id: 'text.defaultanimate',
+  default: 'Animate this !'
+})
+const SANS_SERIF_ID = 'Sans Serif';
+const SERIF_ID = 'Serif';
+const HANDWRITING_ID = 'Handwriting';
+const MARKER_ID = 'Marker';
+const CURLY_ID = 'Curly';
+const PIXEL_ID = 'Pixel';
+const RANDOM_ID = 'Random';
+
+const FONT_IDS = [SANS_SERIF_ID, SERIF_ID, HANDWRITING_ID, MARKER_ID, CURLY_ID, PIXEL_ID];
+
+class Scratch3TextBlocks {
+  constructor(runtime) {
+
+    this.runtime = runtime;
+    this._onTargetWillExit = this._onTargetWillExit.bind(this);
+    this.runtime.on('targetWasRemoved', this._onTargetWillExit);
+    this._onTargetCreated = this._onTargetCreated.bind(this);
+    this.runtime.on('targetWasCreated', this._onTargetCreated);
+    this.runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));
+  }
+
+  getInfo() {
+    this.setupTranslations();
+    return {
+      id: 'text',
+      name: formatMessage({
+        id: 'text.defaultname',
+        default: 'Animated Text'
+      }),
+      color1: '#732ffa',
+      color2: '#3903a3',
+      blockIconURI: blockIconURI,
+      menuIconURI: menuIconURI,
+      blocks: [{
+          opcode: 'setText',
+          text: formatMessage({
+            id: 'text.setText',
+            "default": 'show text [TEXT]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            TEXT: {
+              type: ArgumentType.STRING,
+              defaultValue: formatMessage({
+                id: 'text.defaulttext',
+                default: 'Hello world !',
+                description: ''
+              })
+            }
+          }
+        }, {
+          opcode: 'animateText',
+          text: formatMessage({
+            id: 'text.animateText',
+            "default": '[ANIMATE] text [TEXT]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            ANIMATE: {
+              type: ArgumentType.STRING,
+              menu: 'ANIMATE',
+              defaultValue: 'rainbow'
+            },
+            TEXT: {
+              type: ArgumentType.STRING,
+              defaultValue: formatMessage({
+                id: 'text.defaultanimate',
+                default: 'Animate this !'
+              })
+            }
+          }
+        }, {
+          opcode: 'clearText',
+          text: formatMessage({
+            id: 'text.clearText',
+            "default": 'show sprite',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {}
+        }, '---', {
+          opcode: 'setFont',
+          text: formatMessage({
+            id: 'text.setFont',
+            "default": 'set font to [FONT]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            FONT: {
+              type: ArgumentType.STRING,
+              menu: 'FONT',
+              defaultValue: 'Pixel'
+            }
+          }
+        }, {
+          opcode: 'setColor',
+          text: formatMessage({
+            id: 'text.setColor',
+            "default": 'set text color to [COLOR]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            COLOR: {
+              type: ArgumentType.COLOR
+            }
+          }
+        }, {
+          opcode: 'setSize',
+          text: formatMessage({
+            id: 'text.setSize',
+            default: 'set text size to [SIZE]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            SIZE: {
+              type: ArgumentType.NUMBER,
+              defaultValue: 30
+            }
+          }
+        },
+        {
+          opcode: 'setWidth',
+          text: formatMessage({
+            id: 'text.setWidth',
+            "default": 'set width to [WIDTH] aligned [ALIGN]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            WIDTH: {
+              type: ArgumentType.NUMBER,
+              defaultValue: 200
+            },
+            ALIGN: {
+              type: ArgumentType.STRING,
+              defaultValue: 'left',
+              menu: 'ALIGN'
+            }
+          }
+        },
+        {
+          opcode: 'addText',
+          text: formatMessage({
+            id: 'text.addText',
+            default: 'add text [TEXT]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            TEXT: {
+              type: ArgumentType.STRING,
+              defaultValue: formatMessage({
+                id: 'text.moretext',
+                default: 'and more !',
+                description: ''
+              })
+            }
+          }
+        },
+        {
+          opcode: 'addLine',
+          text: formatMessage({
+            id: 'text.addLine',
+            default: 'add line [TEXT]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            TEXT: {
+              type: ArgumentType.STRING,
+              defaultValue: formatMessage({
+                id: 'text.moreline',
+                default: 'and more !',
+                description: ''
+              })
+            }
+          }
+        },
+        // '---',
+        {
+          opcode: 'setOutlineWidth',
+          text: formatMessage({
+            id: 'text.setOutlineWidth',
+            default: 'set outline width to [WIDTH]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            WIDTH: {
+              type: ArgumentType.NUMBER,
+              defaultValue: 1
+            }
+          }
+        },
+        {
+          opcode: 'setOutlineColor',
+          text: formatMessage({
+            id: 'text.setOutlineColor',
+            default: 'set outline color to [COLOR]',
+            description: ''
+          }),
+          blockType: BlockType.COMMAND,
+          arguments: {
+            COLOR: {
+              type: ArgumentType.COLOR
+            }
+          }
+        }
+      ],
+      menus: {
+        FONT: {
+          items: [{
+            text: 'Sans Serif',
+            value: SANS_SERIF_ID
+          }, {
+            text: 'Serif',
+            value: SERIF_ID
+          }, {
+            text: 'Handwriting',
+            value: HANDWRITING_ID
+          }, {
+            text: 'Marker',
+            value: MARKER_ID
+          }, {
+            text: 'Curly',
+            value: CURLY_ID
+          }, {
+            text: 'Pixel',
+            value: PIXEL_ID
+          }, {
+            text: 'random font',
+            value: RANDOM_ID
+          }]
+        },
+        ALIGN: {
+          items: [{
+            text: formatMessage({
+              id: 'text.alignleft',
+              default: 'left'
+            }),
+            value: 'left'
+          }, {
+            text: formatMessage({
+              id: 'text.aligncenter',
+              default: 'center'
+            }),
+            value: 'center'
+          }, {
+            text: formatMessage({
+              id: 'text.alignright',
+              default: 'right'
+            }),
+            value: 'right'
+          }]
+        },
+        ANIMATE: {
+          items: [{
+            text: formatMessage({
+              id: 'text.animtype',
+              default: 'type'
+            }),
+            value: 'type'
+          }, {
+            text: formatMessage({
+              id: 'text.animrainbow',
+              default: 'rainbow'
+            }),
+            value: 'rainbow'
+          }, {
+            text: formatMessage({
+              id: 'text.animzoom',
+              default: 'zoom'
+            }),
+            value: 'zoom'
+          }]
+        }
+      },
+      translationMap: extensionTranslations
+    };
+
+  }
+  setText(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.text = this._formatText(args.TEXT);
+    textState.visible = true;
+    textState.animating = false;
+
+    this._renderText(util.target);
+
+    return Promise.resolve();
+
+  }
+
+  clearText(args, util) {
+    var target = util.target;
+
+    var textState = this._getTextState(target);
+
+    textState.visible = false;
+
+    textState.animating = false;
+    var costume = target.getCostumes()[target.currentCostume];
+    this.runtime.renderer.updateDrawableSkinId(target.drawableID, costume.skinId);
+
+    return Promise.resolve();
+
+  }
+
+  stopAll() {
+    var _this = this;
+
+    this.runtime.targets.forEach(function(target) {
+      _this.clearText({}, {
+        target: target
+      });
+    });
+
+  }
+  addText(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.text += this._formatText(args.TEXT);
+    textState.visible = true;
+    textState.animating = false;
+
+    this._renderText(util.target);
+
+    return Promise.resolve();
+
+  }
+  addLine(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.text += "\n".concat(this._formatText(args.TEXT));
+    textState.visible = true;
+    textState.animating = false;
+
+    this._renderText(util.target);
+
+    return Promise.resolve();
+
+  }
+  setFont(args, util) {
+    var textState = this._getTextState(util.target);
+
+    if (args.FONT === RANDOM_ID) {
+      textState.font = this._randomFontOtherThan(textState.font);
+    } else {
+      textState.font = args.FONT;
+    }
+    this._renderText(util.target);
+
+  }
+  _randomFontOtherThan(currentFont) {
+    var otherFonts = FONT_IDS.filter(function(id) {
+      return id !== currentFont;
+    });
+    return otherFonts[Math.floor(Math.random() * otherFonts.length)];
+
+  }
+  setColor(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.color = args.COLOR;
+
+    this._renderText(util.target);
+
+  }
+  setWidth(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.maxWidth = Cast.toNumber(args.WIDTH);
+    textState.align = args.ALIGN;
+
+    this._renderText(util.target);
+
+  }
+  setSize(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.size = Cast.toNumber(args.SIZE);
+
+    this._renderText(util.target);
+
+  }
+  setAlign(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.maxWidth = Cast.toNumber(args.WIDTH);
+    textState.align = args.ALIGN;
+
+    this._renderText(util.target);
+
+  }
+  setOutlineWidth(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.strokeWidth = Cast.toNumber(args.WIDTH);
+
+    this._renderText(util.target);
+
+  }
+  setOutlineColor(args, util) {
+    var textState = this._getTextState(util.target);
+
+    textState.strokeColor = args.COLOR;
+    textState.visible = true;
+
+    this._renderText(util.target);
+
+  }
+  _animateText(args, util) {
+    var _this2 = this;
+
+    var target = util.target;
+
+    var textState = this._getTextState(target);
+
+    if (textState.fullText !== null) return;
+
+    textState.fullText = this._formatText(args.TEXT);
+    textState.text = textState.fullText[0];
+
+    textState.visible = true;
+    textState.animating = true;
+
+    this._renderText(target);
+
+    this.runtime.requestRedraw();
+    return new Promise(function(resolve) {
+      var interval = setInterval(function() {
+        if (textState.animating && textState.visible && textState.text !== textState.fullText) {
+          textState.text = textState.fullText.substring(0, textState.text.length + 1);
+        } else {
+          textState.fullText = null;
+          clearInterval(interval);
+          resolve();
+        }
+
+        _this2._renderText(target);
+
+        _this2.runtime.requestRedraw();
+      }, 60);
+    });
+
+  }
+
+  _zoomText(args, util) {
+    var _this3 = this;
+
+    var target = util.target;
+
+    var textState = this._getTextState(target);
+
+    if (textState.targetSize !== null) return;
+
+    var timer = new Timer();
+    var durationMs = Cast.toNumber(args.SECS || 0.5) * 1000;
+
+    textState.text = this._formatText(args.TEXT);
+    textState.visible = true;
+    textState.animating = true;
+    textState.targetSize = target.size;
+    target.setSize(0);
+
+    this._renderText(target);
+
+    this.runtime.requestRedraw();
+    timer.start();
+    return new Promise(function(resolve) {
+      var interval = setInterval(function() {
+        var timeElapsed = timer.timeElapsed();
+
+        if (textState.animating && textState.visible && timeElapsed < durationMs) {
+          target.setSize(textState.targetSize * timeElapsed / durationMs);
+        } else {
+          target.setSize(textState.targetSize);
+          textState.targetSize = null;
+          clearInterval(interval);
+          resolve();
+        }
+
+        _this3._renderText(target);
+
+        _this3.runtime.requestRedraw();
+      }, _this3.runtime.currentStepTime);
+    });
+
+  }
+  animateText(args, util) {
+    switch (args.ANIMATE) {
+      case 'rainbow':
+        return this.rainbow(args, util);
+
+      case 'type':
+        return this._animateText(args, util);
+
+      case 'zoom':
+        return this._zoomText(args, util);
+    }
+
+  }
+  rainbow(args, util) {
+    var _this4 = this;
+
+    var target = util.target;
+
+    var textState = this._getTextState(target);
+
+    if (textState.rainbow) return;
+
+    var timer = new Timer();
+    var durationMs = Cast.toNumber(args.SECS || 2) * 1000;
+
+    textState.text = this._formatText(args.TEXT);
+    textState.visible = true;
+    textState.animating = true;
+    textState.rainbow = true;
+
+    this._renderText(target);
+
+    timer.start();
+    return new Promise(function(resolve) {
+      var interval = setInterval(function() {
+        var timeElapsed = timer.timeElapsed();
+
+        if (textState.animating && textState.visible && timeElapsed < durationMs) {
+          textState.rainbow = true;
+          target.setEffect('color', timeElapsed / -5);
+        } else {
+          textState.rainbow = false;
+          target.setEffect('color', 0);
+          clearInterval(interval);
+          resolve();
+        }
+
+        _this4._renderText(target);
+      }, _this4.runtime.currentStepTime);
+    });
+
+  }
+  _getTextState(target) {
+    var textState = target.getCustomState(Scratch3TextBlocks.STATE_KEY);
+
+    if (!textState) {
+      textState = Clone.simple(Scratch3TextBlocks.DEFAULT_TEXT_STATE);
+      target.setCustomState(Scratch3TextBlocks.STATE_KEY, textState);
+    }
+
+    return textState;
+
+  }
+  _formatText(text) {
+    if (text === '') return text;
+
+    if (typeof text === 'number' && Math.abs(text) >= 0.01 && text % 1 !== 0) {
+      text = text.toFixed(2);
+    }
+
+    text = Cast.toString(text);
+    return text;
+
+  }
+  _renderText(target) {
+    if (!this.runtime.renderer) return;
+
+    var textState = this._getTextState(target);
+
+    if (!textState.visible) return; // Resetting to costume is done in clear block, early return here is for clones
+
+    textState.skinId = this.runtime.renderer.updateTextCostumeSkin(textState);
+    this.runtime.renderer.updateDrawableSkinId(target.drawableID, textState.skinId);
+
+  }
+  _onTargetCreated(newTarget, sourceTarget) {
+    var _this5 = this;
+
+    if (sourceTarget) {
+      var sourceTextState = sourceTarget.getCustomState(Scratch3TextBlocks.STATE_KEY);
+
+      if (sourceTextState) {
+        newTarget.setCustomState(Scratch3TextBlocks.STATE_KEY, Clone.simple(sourceTextState));
+        var newTargetState = newTarget.getCustomState(Scratch3TextBlocks.STATE_KEY);
+
+        newTargetState.skinId = null;
+
+        newTargetState.rainbow = false;
+        newTargetState.targetSize = null;
+        newTargetState.fullText = null;
+        newTargetState.animating = false;
+
+        var onDrawableReady = function onDrawableReady() {
+          _this5._renderText(newTarget);
+
+          newTarget.off('EVENT_TARGET_VISUAL_CHANGE', onDrawableReady);
+        };
+
+        newTarget.on('EVENT_TARGET_VISUAL_CHANGE', onDrawableReady);
+      }
+    }
+
+  }
+  _onTargetWillExit(target) {
+    var textState = this._getTextState(target);
+
+    if (textState.skinId) {
+      this.runtime.renderer.destroySkin(textState.skinId);
+      textState.skinId = null;
+    }
+
+  }
+
+  static get DEFAULT_TEXT_STATE() {
+    return {
+      skinId: null,
+      text: DefaultText,
+      font: 'Handwriting',
+      color: 'hsla(225, 15%, 40%, 1',
+      // GUI's text-primary color
+      size: 24,
+      maxWidth: 480,
+      align: 'center',
+      strokeWidth: 0,
+      strokeColor: 'black',
+      rainbow: false,
+      visible: false,
+      targetSize: null,
+      fullText: null
+    };
+  }
+
+  static get STATE_KEY() {
+    return 'Scratch.text';
+
+  }
+
+  setupTranslations() {
+    const localeSetup = formatMessage.setup();
+    if (localeSetup && localeSetup.translations[localeSetup.locale]) {
+      Object.assign(
+        localeSetup.translations[localeSetup.locale],
+        extensionTranslations[localeSetup.locale]
+      );
+    }
+  }
+
+}
+
+const extensionTranslations = {
+  'fr': {
+    'text.setText': 'Afficher le texte [TEXT]',
+    'text.animateText': 'Animer le texte [TEXT] avec [ANIMATE]',
+    'text.clearText': 'Afficher le sprite',
+    'text.setFont': 'Mettre police à [FONT]',
+    'text.setColor': 'Mettre couleur du texte à [COLOR]',
+    'text.setSize': 'Mettre taille du texte à [SIZE]',
+    'text.setWidth': 'Mettre largeur du texte à [WIDTH] et aligner à [ALIGN]',
+    'text.addText': 'Ajouter au texte [TEXT]',
+    'text.addLine': 'Ajouter ligne et écrire [TEXT]',
+    'text.setOutlineWidth': 'Mettre la taille du contour à [WIDTH]',
+    'text.setOutlineColor': 'Mettre la couleur du contour à [COLOR]',
+    'text.alignleft': 'gauche',
+    'text.aligncenter': 'centre',
+    'text.alignright': 'droite',
+    'text.animtype': 'machine à écrire',
+    'text.animrainbow': 'arc en ciel',
+    'text.animzoom': 'zoom',
+    'text.defaulttext': 'Planète Maths !',
+    'text.defaultanimate': 'Anime ça !',
+    'text.moretext': 'et encore !',
+    'text.defaultname': 'Texte',
+    'text.moreline': 'nouvelle ligne !'
+  },
+  'de': {
+    'text.setText': 'Text anzeigen [TEXT]',
+    'text.animateText': 'Beleben Text [TEXT] mit [ANIMATE]',
+    'text.clearText': 'Sprite anzeigen',
+    'text.setFont': 'setze Schriftart auf [FONT]',
+    'text.setColor': 'setze Textfarbe auf [COLOR]',
+    'text.setSize': 'setze Textgröße auf [SIZE]',
+    'text.setWidth': 'setze Textbreite auf [WIDTH] und [ALIGN] ausrichten',
+    'text.addText': 'zum Text hinzufügen [TEXT]',
+    'text.addLine': 'Zeile hinzufügen und schreiben [TEXT]',
+    'text.setOutlineWidth': 'setze Größe des Umrisses auf [WIDTH]',
+    'text.setOutlineColor': 'setze Farbe des Umrisses auf [COLOR]',
+    'text.alignleft': 'linksbündig',
+    'text.aligncenter': 'zentriert',
+    'text.alignright': 'rechtsbündig',
+    'text.animtype': 'Schreibmaschine',
+    'text.animrainbow': 'Regenbogen',
+    'text.animzoom': 'vergrößern',
+    'text.defaulttext': 'Hallo !',
+    'text.defaultanimate': 'Beleben !',
+    'text.moretext': 'und mehr !',
+    'text.defaultname': 'Text',
+    'text.moreline': 'neue Linie !'
+  }
+};
+
+module.exports = Scratch3TextBlocks;
\ No newline at end of file
diff --git a/node_modules/scratch-vm/src/extensions/scratch3_tm/index.js b/node_modules/scratch-vm/src/extensions/scratch3_tm/index.js
new file mode 100644
index 0000000..0ae49a7
--- /dev/null
+++ b/node_modules/scratch-vm/src/extensions/scratch3_tm/index.js
@@ -0,0 +1,799 @@
+// Importation des modules nécessaires pour l'extension Scratch
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const Cast = require('../../util/cast');
+const MathUtil = require('../../util/math-util');
+const log = require('../../util/log');
+const ml5 = require('ml5'); // Bibliothèque ml5 pour utiliser les modèles de machine learning
+const formatMessage = require('format-message');// Gestion des messages multilingues
+// Icone pour l'extension
+const blockIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAmGVYSWZNTQAqAAAACAAGARIAAwAAAAEAAQAAARoABQAAAAEAAABWARsABQAAAAEAAABeASgAAwAAAAEAAgAAATEAAgAAABMAAABmh2kABAAAAAEAAAB6AAAAAAAAAEgAAAABAAAASAAAAAFQaXhlbG1hdG9yIFBybyAzLjQAAAACoAIABAAAAAEAAADAoAMABAAAAAEAAADAAAAAACpBGEYAAAAJcEhZcwAACxMAAAsTAQCanBgAAAi6aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA2LjAuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOlBpeGVsbWF0b3JUZWFtPSJodHRwOi8vd3d3LnBpeGVsbWF0b3IuY29tL3htcC8xLjAvbmFtZXNwYWNlIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxQaXhlbG1hdG9yVGVhbTpTaWRlY2FyRGF0YVZlcnNpb24+MTwvUGl4ZWxtYXRvclRlYW06U2lkZWNhckRhdGFWZXJzaW9uPgogICAgICAgICA8UGl4ZWxtYXRvclRlYW06U2lkZWNhcldyaXRlckFwcGxpY2F0aW9uPnBpeGVsbWF0b3JQcm88L1BpeGVsbWF0b3JUZWFtOlNpZGVjYXJXcml0ZXJBcHBsaWNhdGlvbj4KICAgICAgICAgPFBpeGVsbWF0b3JUZWFtOlNpZGVjYXJXcml0ZXJEZXZpY2U+TWFjQm9va1BybzE3LDE8L1BpeGVsbWF0b3JUZWFtOlNpZGVjYXJXcml0ZXJEZXZpY2U+CiAgICAgICAgIDxQaXhlbG1hdG9yVGVhbTpTaWRlY2FyV3JpdGVyT1M+MTQuMC4wPC9QaXhlbG1hdG9yVGVhbTpTaWRlY2FyV3JpdGVyT1M+CiAgICAgICAgIDxQaXhlbG1hdG9yVGVhbTpTaWRlY2FyRW5hYmxlZD5UcnVlPC9QaXhlbG1hdG9yVGVhbTpTaWRlY2FyRW5hYmxlZD4KICAgICAgICAgPFBpeGVsbWF0b3JUZWFtOlNpZGVjYXJVVEk+Y29tLnBpeGVsbWF0b3J0ZWFtLnBpeGVsbWF0b3IuZG9jdW1lbnQtcHJvLXNpZGVjYXIuYmluYXJ5PC9QaXhlbG1hdG9yVGVhbTpTaWRlY2FyVVRJPgogICAgICAgICA8UGl4ZWxtYXRvclRlYW06U2lkZWNhcldyaXRlclBsYXRmb3JtPm1hY09TPC9QaXhlbG1hdG9yVGVhbTpTaWRlY2FyV3JpdGVyUGxhdGZvcm0+CiAgICAgICAgIDxQaXhlbG1hdG9yVGVhbTpTaWRlY2FyVmVyc2lvbj4yPC9QaXhlbG1hdG9yVGVhbTpTaWRlY2FyVmVyc2lvbj4KICAgICAgICAgPFBpeGVsbWF0b3JUZWFtOlNpZGVjYXJXcml0ZXJCdWlsZD5hN2M5ZjgyPC9QaXhlbG1hdG9yVGVhbTpTaWRlY2FyV3JpdGVyQnVpbGQ+CiAgICAgICAgIDxQaXhlbG1hdG9yVGVhbTpTaWRlY2FySWRlbnRpZmllcj4xOTZCQjA3RS1BNzg5LTREMUItQTVCQS1FNzU3RjA3NkM2NUU8L1BpeGVsbWF0b3JUZWFtOlNpZGVjYXJJZGVudGlmaWVyPgogICAgICAgICA8UGl4ZWxtYXRvclRlYW06U2lkZWNhckxvY2F0aW9uPmlDbG91ZDwvUGl4ZWxtYXRvclRlYW06U2lkZWNhckxvY2F0aW9uPgogICAgICAgICA8UGl4ZWxtYXRvclRlYW06U2lkZWNhckJhc2VGaWxlbmFtZT50bS1zbWFsbDwvUGl4ZWxtYXRvclRlYW06U2lkZWNhckJhc2VGaWxlbmFtZT4KICAgICAgICAgPFBpeGVsbWF0b3JUZWFtOlNpZGVjYXJTaG9ydEhhc2g+MTk2QkIwN0U8L1BpeGVsbWF0b3JUZWFtOlNpZGVjYXJTaG9ydEhhc2g+CiAgICAgICAgIDxQaXhlbG1hdG9yVGVhbTpTaWRlY2FyV3JpdGVyVmVyc2lvbj4zLjQ8L1BpeGVsbWF0b3JUZWFtOlNpZGVjYXJXcml0ZXJWZXJzaW9uPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPlBpeGVsbWF0b3IgUHJvIDMuNDwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDIzLTA5LTEzVDIyOjMwOjQxKzAyOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjE5MjwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj4xOTI8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KuCMztAAAIABJREFUeJztfXmwJVd53+87fd82mzSSrF2jZdCCltGCIpZBmwUEENgQICpjy4jCCSaOTZVJ7DI4pEKCXY6TgMFL2RhMGYhMyibCCTIgR7s0orAsacZCEkIINBqBhpFGo9HMvDfvdn/54/RZ+/R6+27v9U96c+/tPn3Wbz+nzyE0wMPMs/0f4aepn2wlwdcw8zkAbWySV4cOTUCE5xn8GFjcmUTitr1LuOPq02mxdj51Ej/41OFfFiR+B+AjASIwA1Qriw4dBgTDJ1sigJmZQM8xkg9vOWX2M1VzK6VeZqYHn8aVEcW3getXt0OH0YEBJjA4xmzvtVuOw7eIqJBqCxngkaf56MPJ8tcEiVd2tN9hWkAAEmYwx/esm5v7Fy87nnYXpQ3iH55a3DzD4gESYj2AztrpMEHImkH5KZOXEiSXXHzK/OOh+yJ08aEfLr1zBtFjJKL16lqW+Dud0GFcqEb8BIAQrYs4emT7U/23Vcrp4d38sv5i/1EhKOKOxjusEDBzTHO9s7YcR9+3rzsM8NCP+Vgs958g0Dr3cUIn8TtMO4h4/6zonXH2ibRHXdMmEDMTLfVvEhbxG+7oiL/D9IOZ1i/Fy3/LzJru9ZcdP8LlIHq1Teod2XdYKSAlzplevWMnXquuGye4H986vihPx2odhgtWNEYEYPkOdV0AwIM/PPx+IkTjI8NJja92jLkiQQLbnzr8K0BKedt39vcAOHqslZpydGGC6UE6Vs9vOaV3ND3MPBs/HS9icsVwhw6tg5l5zVJvQcRPx68jyif+jis6rEQIIlpeh2t6zHx1EZl3ar3DSgQDONzvXy4AvmLclZlekPfZYTogxysiXCGEEJvDiTrZXw62PjsmmB7IcWPGuYI5L/ozYQPq8+Owf9dGQQbdoqrhonH30pHB1aDtoGUG8rMb9u8GVcpPOGHCZKWhcvdmOWWIDLDypd7Kb+FKg80pcvR6zTPz7d683yuFTPy2dFJ9uiHHryIDqIG3B500SRABYNI0wuld1qmm2000dacMWzdj8ZUkGKYbOQzgk2towBisiFsHQ9i6a32m2fG0sIBuviFzvZhKvndtJSU4/VXp3dGO+CcFOT5AdgBJy0AbnL52lvc8edmx9+nmVZymye+8xd3+Pe8+2V88QeARt+mVlL1Jsov9JIFT4dAR/qQhoAHyjBUjv0nZPczyhxJ6mUc58JWNdPUtK6VB1E4W+rd/v+pvu7yy9FT8m61MVWNZ1tUoC84If2Ueqq7pjJ/JQoYBSKt7OZIJM/a+uIiDSwlElNI8ABJyOIkM3VNGOhozSRIKpTQVcibzrGrDWSa/MmeUnecCnBa8r/wWv2T1g9hqj1WUXStmgC1TMALjmCPm0etFTit9dIwxHngMoIZSES3h439+D+56cJdlxwMu8ZhnQ2Em5KR3mCPwO6yJXHfU1CX7O4uQI2/XkK0ah5iyOL3NnH6oYKYn8JmPvAEnHLshOylGBHAChkDHAqOH5wOQ8/Wuf9yJOx/YhYRt6SYlHLsX/ATa5LXTy0/5l5T89tP71xIn7+zv8LP59xP22+c+A+/Pbh/YrhuQpH/MQMyMpeU+PvgHt4PjJEvi7GupDu0jv29zw6DMwF/f+t2MyeH6s5w6fa48VOlCNq8xM+yc88wQt/R8Y8mWvCZ/r8Zpqmw9XUnu15cD5RkIq77G0jcVpdSfeOnAYSScQKAHQpI1pYoQUoYdaiC/8zImkExPoJixnMQZ0tbESwRAePEUOyYS5js7bZYUfeKmQNl5v8P5ZdP7caxsGpvQ2WKK4vZkBYHtH3GcQLGLipQWMVZJUzq0BI8BrPClYIS2FXWDob4cC2iKATDycbco0i+7al2KntPBhawfXZpnZyANB8IdDGXYGtsW8MerHbIcNJehMIfl/7cFrUnYRMkIJKOqFam6I/7hQWR710gom/xtu9z93Qzjfn5UICVEQozVmTZjR2AmmI0rELqXfnZjVxWWWcmuQ91h/HAYIGTwKMjZTrJ/dagEIzS6YM7kwWEAPwhoz+yyTNChLkj/42BaTLiVDs8EcoOO9pR+R/uDg9jq4VIO6Hp8FAj4AGbZgoi6QRgY9trpog2Ygss+OgwbOUsh5GcShwahY4rGKOy6juDHgZz3AeSyXqbQ4oFhDNQoBn90BOaURNYVDoSQO3kyVgggP+5DPCqiqUIFbU2dDb9N4bWjKsjgpalSnU45DA09IGeNCysNYISY9dqvvp4/NnlLpk20iZ2lce6TmfoMMPdg14ItMvTbUc4iflvMIrzQgj3boCQG5GogtcCuRms6LTE05K4GJQKOWDsLOZRyrXpoFiCzAlKDvc/sPb18jdl9mSbwXu0gNED+98CSnLw0LvKX46l+CD3GAHozPfNENyEwMSjcF+iGt54PIgEGgwnu2vh0wZBZM+Sur0fuunyWXoW9th7Q1xhS87Sp9X1WNFVWazztyaq0/hSud17b5AQ6p2+NqbaoZRCMTcevg1BMt+o3ypocm4627+wX1uaBR5/Fb3zqDsQcoycEYBGnawSoK9Xgmwh6ER6AJGHMRAKJetFmIIJRppYsYmZGIIGU1YnVEEWszGbtk70JSrhlykRkvb7ZLIhmvajwn7/mDPy7X7gMWbbu1nnmImAFDAOlDECQRMFIIIhAxCAIsH5xndzEZVBvQJHUJkTSJ1CkwEjADHz2q9tx4y2Pg5NkAGshJWNVVTC+/ol3QkQCJAgiQkq0qhlmNyP5YbmuYfMfJme7fXIWPQGQcJLmUDQHYNCMJXwPZMSYYpOudGMsBqBeaAckMySw3xVIvxCkl6cQHEnXRZS0Qs6Ms9ImBxf7EMxplpIBra24KjXOp9pIEObne6k5ZzSOpHVCZjeK1GDXdjuc7Nz8PWnFLEleQGhGr4Jm+mDM1DelxA+UboxlEX7mjisGMy/PaAJh77Ll+KaffkREyUu2SjXys5KaQVZkG7fDL0vX0WHq/FiRMaoSaB3BnN83VjStM3gmC5oB3MExxOMOq00uGQs+Bz7B2nln7yi+kURDSpTWRP4DKn9OUiKmLFOUxIecT/Ke58wzpl2cubJakdf+0feLOSke2W9S2hVJXvb+Qtfy0pi0odg5q8hSoFal4NBTxuQiThnM5rhg20Kfds1VUYbs1V8oJ50oo/Py2lEl0aSiaOTyGlatwW1aXAETqE78PXS3qqtnPv2dJwxNSqe7aq4me49ppScPXxYXT3RnpX0ZiocvLdu3tqpUYSpRx2QFsmZniRZvCZX3Bg3daW98XEkNGBr2oyv1mq+oTTnw6f496a326l/VL+mQj+FQVhlyF8PlgSulGgSSQgWlVdOEX1eiWGmVh+7ZJ4PUf5zCuVpAdZgYATOPqIlDPCGmJjxCN+0neBca5C0fFiD4Ua3GWQavtjlqRUJo3NpkBNQ5oiZODgN49rm/0W6JwV6aNUFu9Ksd0BpjGE4aivuGzbR8lst/ZsodAAfeDAnCbS4KmBT1UxHK004OA3gmoMiPnjaA2TjXN6jKngvNZIS/5/02a4KMAwLLKbednRABTA9CETDdfr3uygpvh+ZaOP3T/WL1j+3AWfln13TZNSruxwHOCGsZOt5vppJcDMIBVkd4AYb8LmLrX/tBZaIVbcWY4684Sfx72fZNz2yB6ivbweK0TTkmrNVepy+Dgo/c63ZAjwhqyUq2TmGWtFHOAMURqcbIDK4+YUOdI+ANfQv1IFKmlR+ODJFaYCTU6lc9eJz+T9Z45lRUF2HdZ053iFPPp/mRtf5oRIvCBofXpnS+hfVSdxV6TsndvlYU8kyXkZglZOlMPKdlpuNhjyB5eRaRTjkDjKnvMwzfQj3UpJXqu3LxylDvQjAx/uqbj2L7d38CABBCaCa1aVRqaoag7LsBbH3Rm+OmFwUZckiYcfSGBVx16Sa86oITEceJlcOkMYOvUgkRAU/t3oev3P597N7zEpbjBFGqDdSWkHZ/5bVI9SWBrP4x5J2wXNe7dk0P1772TFx01rHQx7sopinIH2hoArWtmrOdULx4rAkZKMNKkXTi3A0bXGw9dcNHb8Yzew5Yab0aB4i6qDJ5CtsqHLd860lsvWQTPvKey9ITZiaN+AF4kpaTBJ/7vw/ji1/7J0QzUWqiuy88ZbrHNmkCOXOgv9znGXc/+Ax+64ZX4sqLTwbIPomouM8aOcFDsUu9MKhtAZF/oTHIWD92/hluc5ezPfT4HvzouQNWbQL2umXqSlOr4C9cM1N6qqIYAtse2Im///ZOXenwcI6LMdj9yow7HngaX77lUUS9SN/OHp3l/VG431SCstYxCcRxgk/91T8gioQuo0q/TE4USAcLjVkRuu9+q4gcYtcShv2Eigml+r1vxy5wUlG6DwQrSpT6Q30Gfv8L94EEpe9lKGIJGlcjhlUHIfvqk1/8NpLEr09b9fMiPTr4I6+9sH8JLx44nN6qVuZEMIB2+MwHhB8HtX7W7k6yn2EtbeBcy48YHO7HVtShoBDNxPXryZa4M+9Kpzkz4ZZv/cCymxnMSTCfsYEJdz30NA4ux4Gb5JMu3L4qcIKd59w+Zn/IBGFpqZ86xdXE5MgYoKg6o5NfRXIhMDyWXaO7PTcDM1SqrXU0FXlvE2lHHQAJwp/8zYNaslZV76OAqkWcMD530/bc/smKF7st+aOSJ5b0dT9YSAge7JKHidAAIXAVF742KLev85U2I9KUOEyiM3WzB53SMOuBg0v47lN70xq1vRqobm5278iAxZ69B7Frz4GCZ4YDd+dJoa9V3Xhm4hhAyQXOXBscRDIaUZ5fWotUqEeRgB9rHorW0iYOjLJJTaI4Af7n17/jrZINR6Tqo25r7IgOIUmA//alb49Ok/sBEvsGW76dnziAkTJAlWFSKtF2AdqSdgz7NUu7UN+osCaiCNr0sF2A8jo1MYTcx22GA4B7t+/Czh/vt+rrDnU9tEOuBIATxgOP/Li9SF3we/llMy/D5YlTTJwGGCpSie6TjdoC0lXs5rcKavgEWV6Ym2sT2GUSET7/tYfBSRXZ5uZR9WoT/NYf3QESEYA22GoQ3U+gGg4wMGIGqNIcbQINUZ+G7P2i2LxepqC/jwBsWNAuctv2XVhaPFyrHmVd2ahJ6QAtLcf4zg+eB/T+HaOFM1/UoPCJ1QBD8QFgxc/ZeBpZye72ZCS8EOfQNw22Z4LcUODycoz7Hn423cCrnXqEcymZZ0j78eZ7nsDS4RicklJZWLM1hGIknktUwZhabT6A+VcGXdLSCgsgd2JnJJ6eNw8AE/pkAP/5L7al70oPc/jCdrRDVBFw49cf0RsYmPtF4eKWEBgzvcmm232Z7zYmVgMMC/arxboPCweL4XoEwMgUfaYYE526/dtPFc5qDAu2uXjz3U9i7/4lWSc/4Yi6qFh4lWNV+gBuWeXQ7ycDY5t/Yis0TAT88Vcesg53CCwebNR/5Q8RJNHFcYwv3fzwgOUNirwt1apjYjVAqz6AbUoE1gIVP6imge1Q6ehH296hCQQ8/+IhfG/nXmltsC0wAgZwjVLKwJAa6IVDfezeu6ivZVONAkVz4sVtUXdXhw8QmjyiYJLgg4m9dynnpx4WMuSUOvB//tUdkBJvGCGD/MqQIHz8T++Gsrot+ZBidP1jv2XqY+Kc4EkAW1+qks24152F4jHMhAceexZ79h4ASGTSDbMyy8sxdjzxE71aNovRaUh/UWPer1DoG1hlPoAVzq9BLZ597WQyQmQCUYQ4YXzh649oDh1WrezmJ8z47T+5EyBRsNRgTI6SNlcB3z+YOg0wLKUe8gHKrEVnafYYTCAX7s5G39z2JA4u9d33A1qcrXNmGxhIEuCfnnhO36uX0xCQJ9orGoarwwdIkSexyhgs+4LHGKB9W/u8AjlH8fD3n9PxXamg2quvMblk5n/9/x7D0nITm3AYfcgecfivwpdjYjXAsJDdyrzCM/liZiwwTicj4QQf/qM7EPXMTGy7stYsAUnAuOmO7wYnmsaD7MpeuRS6OlafD5BTmTDRyAkwx9HLhjzGCoZAkgC3bHvSrIZM7zWtZdY0lH1w74O78Py+JZhRaophCRTK/FuGidUAo/ABKj4R8AEGROBUnKYgMEgQ/uym7UjYHfqmVWXnU04u9eMEn/ry/dn9mvyHKsFve4tGru2wVMCq8wE06dXItH0fILuv3KDYu28Re/YdGELOgCDCnn2HsO+lZX0tU0bDQcqPJDXLy8g3N0A7dVGgoaHGOi0jCVsR+3aAohXYpk7MjD/7m4esUlp0hInxh//rHx1BMAibZVdVhTqkfic5EauCMm2sXh+gcvqQDzBY6QJy9zQX9RvsD/g9D+7Enr2LJS+FlDXAte8ZjCROcM+DO2vmkw9K/0QkvNKy9aiS1yB1mlgNMHQfoHKm7fkAKpeYE3zw+sssf4TQlKBsCRoz4aY7HwOzv/OdjTIVmC7/SA1GMPDrn7gNUSQPVXYerdwXfkLCTC/CljOPTe3SpjqWvUho/Vw6H6AC2vYBEjBOOHIOC3Ozab0Gzd88/5Vbv4elpWXnaNYMghfdOlC66c5yzHhi14uab5os+fEdfgZw+cUnYUYA8sTCwRRr1qQKJgtiYjXA0DA2H0BCraRYWJjFdW84s4W4vWuNx3GM+x971lseUV30mJ+y1V+7+3tYXOwPRKT+c0ncx7+//jLMpNsn1p+azEfnAxSgFR+gSUYWGHKnYxDwc288BzTwQju3fgkDH//sNijGsJdNFOXhfleTX4TP/+2OwEbCRe5mce5gxpuvOBM9QVjup7vIZfqzagf7s16dD1CKgX2AmhUKt0MOnECE695wTkpONacwCyq0uBTjmWdfqlFVP2Ao/+556GkcPBx7OkYRf3ViM5vRECAivP9nLkQCc6aC3uu/ATJvhNXsw84HqIBBfIBsLFravGpC6R2vOwu9npBENlBDrTfGBPChT9+OQdRowozPfXWHJqjBNLJZwHfBGRuxdk0EEkAkhA7cNzMz2dsGMX9b/c4HUBizDwBIchCQRHXE+nmcevwR2Te6asO4mkSEffsX8aPn5MRY9RyNx/DMTw7i6d379dV6E+gc/JkkjOuvPQ9CCG1p6QMtdOJ67fdHpvMBCtDaPEALKkkGWaSm+9Rv/jQ4MafANGI4r8OW+wlu/PojsNm3arXjJMF//8ttSEKRnwo5+WsyOT3D66zTjsYl5xwPd5ZWsWizCTyXMTsfoBStzAMMaA6o8wAptftnoh5O+Kk1ejQbLWfQx9MY3LztSbx4cNGpuksjjlciSyZCFEXY8cTzAIdOyQSKZhlsS84wHiESjH/1ti3pSTpq6xJO0zG4ESkGCL7zAfIx/nkAS8qxJbSZ8bv/9qq0zQXx+7KsPR4QYHzh7x71ojB2PbJTSAkzPvTJ22A2wgiZUAW1Izd3FfZduzCLi152tHV2l2/4NOzjzgeoiZH5ANkuV/LUPVFSpjzxmHU47qh1qC3CvOJc6Uv4xr1P4vBS39neMTTs6rnFw3089tTzgVNzKoBDdZAXfuFN50JEkX8Slve1fts7H6AGBvMB6lbIT692nE43cLWOWmUAURThX799S8OaZktWORxaXMb3n9mn7R8plbNtYZaRqW/e9wMsLcU1nF6fkgP6QgBvv/psq3Z5Zl42ZlZaeucD1ENzH2BQQ4wt/0HZvsoTkDdefeFJWJiLBizHrSmD8cE/uBUkbNLPurYk5NGvN37jEfc42VLky2B1vOn7336xPtKJGNoMKnOlq8LRIJ0PkI/x+ADWs4r3mHQ99CQYgIiAX3rbloANURfkkCEvJ9jxvd26pJBrmzDhm9uexHMvHNLPDdbvaUmRwLVbT4MgowFZ85+eGWneVI/mOx+gDCOfBwiYBJr+9JmY+t6btm7WWqD5vpfu8jNmwv/40v1Qb6L52RLLNURf/LuH9fPNQbptAPCWrWdgbraXQ+TGB2rW1Lwcq6SUmCAGcElh1O8E56dv6gNkkRuPJ0OUvUhgy+ZjA0ZKvZLcffMJu3bvx3P70q0MffODGC8t9vHj5w82KtU1V1kzriDgX77+HCgyyzi7uV1ao69Xpg8wpM3+yPIBUNnNaskHAGwmZzvkqbQSySu/84HLwYn/bledXiDPFGDECeMzN23Xloe94zWTwMf+9B7EcTNjJOu6yjwufvkJOP6otSBKoMbUaVOup920ryfcByiGG/8WzkEW7cCefPEzLeq3jA/QsEJmRYzrimppn7aVRYK3Xr5ZLpfQaeoWmjXc7nxwJw4eVu/1Cqjh7y/H2PH4blSPD+TXRdaXMDsj8KF3vwIxqyuOpS6ZvskeNWU1m1QfoJ5sCaRsqYPs8wHcIckvsn1zzBzLrSS/UwQTfvGt50NEwmGQetXwbX3C8nKCG7/xiGXayU742GfvhY46sC+KQsi3vdWzxxy5gI0b5t12eno9P9TavMMn1gco6k43bCevZLbfaEENONGfEg1AMGtUnEmkQd2BgCNCnCWRI9fNYfOJG5xHmnQB298Y+N+3Po5DS8uyGQT04xj3P/pswEGpy24GCSf48Htfg54wBhGRz5Jea5ra8k41p9QHyEpi14lrUwDr1ZElppW9hExY53UNXBlHFbomkbrCkIdy/Op1l8AykBoV7URUCej3Y+x89oC2Fb58y6NYXk4GZGz3fII1a2Zx7hlHwaxtQnBmWQmWwK3K5WYEyqT6AEX1cqMslBJAnRxq1EG9gE0hxgsjackG8h176zURyz8wKc454xicdtJGvXiM6o+vzlO1bzlh/Oan78DMjCTa/3OXtaNcY99TLY4jRBHw+796VepQm/INDEsy2y1HPQHO3qfKYlJ9gCK4K8LVRJUfrWnHFQ4SkG+Dw5W5Gfqv74+GinSkc8iq5gR4z7XnyfTUrGj1jBEv8l2BR594Hvc+tAt7XjChz8Y9TKSl+fxsD6cfvy6YzB7lgW1J2yz1ysgrO4Re8xoMCynpWd5q3jEM9eFKpaIhULGLjLNWuSJW7t7zfrnhekiievUFJ2DdmjnsP7AIveS5qTOQEg1FhI/9xX0Ax65/I3VvsDZleXParl+89nzMzs1YrQi4F+qxIQQX6mLilkJkpS55UqMBFB2qhWju5ZLxbvo+QIikYcxUQkZfu79kQZEQePcbzzEU1lQSkPt117P7sWv3AX3DGGN1YnXpsyRN1rVrZ/CzV24OFanLcBg/R4qHn65Wo4n1AYCqdZODYBOdsd0bigzHf1UGV/UOZnseYABVVMZwrlYw1P6ua86R97nw8UJkq+0a0fWbZZhFPfv6y05DRG7PBq1Hyr9f5U5hrabRB5Cca5s8LpSF2oYZZBtBZZaNSptdC1dHSmbLIPNWSG6O/u9f//l/1qovVIwq7XOX1M3ORnjvtec5FJjrOjU14yrVqt71CWEAuB3CbEVeWnwl3Yutuq53qEpSaWelSvXRC5GDeRWAA+lMWr14mRlXvuJk9HqRqfiAKM6ioH2WFmKtpxjnnnoU5udnrRzKHdTWXYBJ8wFqkQnbJ+GSxQCUUZuNzWBS01sUdEaD9Qr5ABWQ4wHIe4yspORQWlVDxsLCDF570Ymy3n6HNEDziI/8hwBQuswhIcJ/ef/lzoa/pUs3uI0TEgJexiT5AEV1yZoGRqU6vh6FnmhWEdb/sn259NAMbnlvUJvgtS8cqILxVeTamevffB6Svpq0GufZrUZ9MhgXnnkcZuej3GiP85wClYufSvXwMKU+gIIO12i7u3kEyIo5WLsnhWxyzpFG+T5AOZz8OHSvWqZ2qtNOOAKvvfgUeb3FkyDrwUR+ACAShN9+76vgtDi3aq4mZXZ/t4Ep9wGyKi0cdawy+LZYtSx9TnWNl2nYB5B3KHtxINirLl3W9CvFzvckYbznLeeBhHC0Vvu2dBFcP2rT8etx5LoZN0WVCvn92Ao/T5gPkI9QRd0YR6KX0YYc1apDbof6JNEThaNJ+RqghfMBPGnNMBLc/BuwgwJn/552wgZsXDtf4ECPAGpsBPBzbzwXJPLJKOTcq6+D+zIT7gPko0L01zvxEGgaq1aZZF8/zK8RO9+dtUCUn0cuAoKdmL0E1WIkQgh89Jde6dRptBpAMi+BccoJG3DNKzbp60VmJPsp2vDtAphyH8BAH/DgOLBVEDAqtKRhs4EaVWUub4sWk2HFWmR/+YZZuAb5AdrzzzwWa1TIMWwjDhUE+QL/9W86rzIjar/HNt0Grnd5qLXs+uQwABv1xQDi1PNksmRHpQ6z3GYtfmTMU3C6uictyz5FJUyikrqIbIe6TqNCYMcHKIdXIDM4SfCxX94qd2+rFM5tH2sWZrF1ywm5JqUN++RGZLRpmwbc1PgAARA5dHfeGUdDxoqtKjodadLmSkFKmSDN+uTj1jnLCfyDpTNIoxSREKbwASjNMQfS2KdvGpQOYfrceWdsxEyU7iEk3OfsMGursPJ8/StPRS/q2RHR/MdCddGVHKSiU+sDFIMIeM2Fp6Tbg4S6lw09at8xp+WpeBSCcMPPnI8k3di1VGpZieKW5gF8s9fwfB17XkalZnsz+Pk3vly3L2POteoZu6FPEsC/eecl1vxFg9n69isps63pA0zgcmiAOcH8XA+f/09vwX/9y/vwxNMvSFnJAswkCVL1eEpFjjwlJSilBlmzpocPvOMiXPry4wEIVNiWzKtP/TZk7XvrrQdSmTZjLJXTm7duxhdu/g76caI13XCg9BRBEOPdbzwfSZKku83J6/Vb0obzkm10XR9gwhiA084kEDM2rp/D7/7KVekdDs7ISnuezX6b9gyj9nhZDhYDjMTsOFFYE/UvIRLmSl2DW+YQ9jC8EEkNCAAJjlw/h2sv34ybbn9cN1u6O34lB/cSmEm+mUaEt1/9srQ/pVPbJOfhmGnT7AOkyPPrCTIEKIRAFJm/Xi9Cb6YH0Yv0BJH8kzsq6Jex2UixcDkuHKucyOj/yoNG1r/udR2FchixasYEuT+/fPY9156L2RlnmIVqAAALn0lEQVSh8wy3rlq8KwRNqCRNr9ddtgnrF1K56TjA9fIlUCUHuiwXF9PkAwQrSoHbcsDVwBJYS331J38nqe5gnY6cbJUUrPtegZyBrTtSpWWwJZcz9nBxYXZgYN3CHDYdu76GnVbFyzAlmSCC5K63X3UWyBweUMt7UXmW16a5apieeQAKfrVg2wfmnEF7OstYkcYWVHLetTC1w2D9Va/o4D5AXfi2LXt3LRIlwkfe9ypn5Ac0dlwxRKaPLzz7OJx1ykb5q3EhJgw3uAWUZy9USSkxXAao1MI8G9InIeNw5aXNL65EUedSq5TRmX2BKlB3qC5kf6Z55mWVPZo0LyHjtBM34uxNR+lyBzYrOHMFIiL82rsu1ocjkXs8Y/0ydSAg72YTTJoPUKk+9eRAtdT5qYJ3SjIVwvMBKlSiqOlGS+WnqtwrCSOJE3z4fa+GEC28NRfiIAaOOWIBJx273tKh1aIvIR9Ifxt4Res0+wBDxeDxQNu0auIDlGYePICu3uhJJ1/qimOPXMD6tXMVsiopw/P1U68Lv3bdJTmrWKuBrX+HienxAaYInJm+bzaQzlNBE6g+lynCmpmJ8L63ne+6O9lSK5VhKwECY3Z+Blu3nOQsHalXv3BMrFsLNMGwHcFB3gkOWfLW8WCBgamatx9nYrzhstNx5IZ5HZvXAWQOFJQp2Jb55mcvEvi9D1yhZ8Pb0q11JyOrYdJ8gCmGTR+ChBuUqoHQkOgsgvq6XjhR/8tARIR3XHUWiM3xS7qccEwhcMEliagnsPnkDXVdoMr1bz0PDn7NRccAObDjRgnqS6uQgxsSwgNYVNk8CXjXG87C2tn8CX7O+cvkSNK/uOHa87EwP4PijUPrhZV1/jWeCsMfl6It18PoGKACyP9RI7pVFHXSsxuNKSFLxpEQ+ORvvA49Id9kiwQghDxwhIgghNQUgpD+ESIht2EUQhJ9RAQREd689Qy865qzUtu/lZiV88wwXOK6gdUJWwtkzY62jSoB8mDhOfZzbaI1O5y29z67cVXJIqhTT9iAr37iHdi77xAOHl6Gmj1PILeEiSKyz8MAJ9LRT5jBnGBhdhYLC3M4Ys2MXK4xgLea6VL7QhsD7WfO9o3yycGJYwBVbTt6EPb1QzOleZTFlajOHxv1m4hqDxp5n2pqyy2DIBwGC3NWOQ0mmr2U3pntRTjumHVm0Wm6poH1miiTueWT665iTvQOdpTebbKTT1aeKCdY7Sg9iDQgsE8g5KcoHrKJYwDArXC48qUe3cAwHWdsVj0N2kwFGBgz2yssnGc1AawI1LAZcWpmkWIO+/xlk05lL7yVtOpXW/Ef6Hz8EW6at1o9bOXFbn3Lum4iGaB9DCa54iQx2bRin+WpE5cYqhdHge/2Udx+ib5+SvVGyX6lmSIH6QviFuYBAuNKNluHx92ueucEF0CRjkNCAwhCMw9QbpvWQygXm7jZ+U5I0u8J5ErbOrVg56MMLot5D1buy6oJXUFQYBBrTNC+QOOHP+GrpKWIzDvB0mwtJ5mM46evsVnJXWLKVbe5y0KU5Hw3msH+XZy/q5fKysyrocUGpZHlkI8XQEiJlj1jYeL2BZpE2G+iKaeySkCpIEc9N+WTvJvHqPqpSIPI++FARHOUL4SrqWKsZ5TgquJddCZQBcSD0qGvDlRUaeDDx5qUH0Ko3GEYZxbLcws+APuaxNLSwfKz6BigACoOIhw7ui7MCPk+QC0zahAE+coQY2W2G6hCrhteEPSqDnKj2374vAo6BsiB4ygJZSt7DnEhXLvbPCUnpcrPpxm2p2SYujJdD1ShrL9TPbv8lM46PwKMuTbRPsBkIdS9tlpVqlq9F1uNEtxYt5xkSq1SNrK3aLCmy1OqAtMiQtX5Dfc5H7YGsM2hqieLdgxQAKO0PSe4gSRU0SP3mjWw7Z8ZOlGo50Q3NA7JzKQQqq016hgA4cExkplhz7dLLVttWUCei+tHf5oyVRPkFTOs4k2bjRmoeteR3rVqY032OaFrglq1ylaaInQMYCEb65bfI7WplhYvVcglcFyotoDcWdrKrmjeBHIN5D1aN8uqDONOgKmWyrYLKxhQ3bcqqojxa8JjmUXHAAjNVpo7RMCyfV6T/hqiRv+7l2P6vNmgt2Z0qdkcVKuoJleLISNA6hgsi/Q5k6rgt3w21CV16tYxACpYnPYh3ZSnrrPTWoVyyOKfabL+26irstFdIeHFNDOkXTa1mKaqKRw6BkBx16qzBEIC3x3C4kiOiQKlKl8tQx7bYXfjhHFQ1fZCxInTn0rkOAEIWKHk9AJbqiNhcn5XwSpZDVqMvO4iyBMi162Zgb1u3j5zIJORd9E8w1A72DIz1i7MWhGL6dICAyN1VHs9UmeXQJszug/VjHH6jEonpYdOIvsuTRvHmJ/rQeoXs39qEToNUADV9z97+Wb9m9NAQ8jaZ7Lte2gJpQ7GtsYSm45bXzILsBJh+VJEOPf0Y9QP06fkatZMf1vf/X47+fgNWL92Ng0xdPMAA0MFfI7ZuBZXvWITRLqMWDgDyfosAoABYnmsk/oUDLWpBBFAQuAD77gYSVJNQq0suK7qW654GY45Yh6gBGqVoVQA7PSn+lP/AayPzpLEzpidi/DhG14pzy3QJVSo0fad/dUjgGrCNk36CWPfS0vYf2ARLx1aRhwzhDBHqGqbns0wEgFJwvKFGgI2rJ3FEesWcOS6OTm2gDnCYNVB9lE/Zjz34iG88OIhxIlaKs56+QkA69VJS2Oy8Q6OWDeLozYsYGGuV1HuG3QMoG3z0oQgLfv9bQ0pc82ekgfYea+XGRCUzgVUdgACDsZEo2p9VQekB3CwGRK/a9xX/wOl6SKr91VnApUQvx3IVOrWn2whmP1ossFQs9OaTk+W41ZZ/EwT8QMlsTXrU53ZZuLBwoqIKi1pjryySrDSCKfI6mGFLgpUgvB0DDny3o68haTU6laxPlJpD0sIwOsjMrtXZG9al62AQ5bdOg0wBNjxicS7rr7Z2iH0WvpqR6g3vL4pWRgYelOuKJRdhIwGWHUx6VLY8iWvO7PXjabIT7Oq4RCabzQWo87+RGV5ZTRAR/w+2iLcVdSzVZqam2a0gqIzgUaG0MCuUK0wULNGKyg6BmiA9sh2FWmFCUXHAA0wErLteGMk6BhgUrFCraNJQ8cAHVYuKgiRjgHGDWf56CqGv7y27Txz0DHAuGHP569mhF4GGwHEau/3DuPHWGgw1bzCrMLu0GE8GAv1pZpXmKVJHTqsJqQagIAXcu7VzK/TIh2mCQQG7xEAP5L7Jnet/Dot0mG6EIEeEQnEnV0MrsNqRCyiW0UUiVud15U6dFgJKLJIlAOM/j30+OM8d3Cuf4iEIOIuHtRhdYCZeddSb4EAYMfO/nMMHDXuSnXoMCoQYc8FJ/d+SgAAc/JRwOzQ1aHDSkPgneH/4Fzf/sMlpqiXOSy5Q4fph/vaPDP3L9w0MwNYa4GIZ7eq40A7HdBhJYFc4kcS9a5UvzUDnH8qtoH4PsDf8KlDh+mGu7kW7rzoRGxTv40GIOLDUe+tSJIXTerOHOowiWgomIlfWoyXriMyhO0sh770RNpzmJJLmDm2N63s9ECH4aKuoK2XPiXlmCm+9LLT1/3Yvpd5H+DSTfNPCKJ3cRLHHel3GA2a0lmYEfztKRNGTL3orReeNP9Y5ZK3/5DPSGj5AUFiQ8PadejQDJU2LC7eAJfUmQMc7xecXHzBpvknQuly3wjbcip9f6E3s5k5udve8zi7+WuHDi2j4imcRWAkQBLfHy8ubc4jfqDklcizT6Q9W06ZuaIf9a5MOOnLQwq6pXMdxocw2ZO+oY4S6DOu/MrnZi675Mz1P6mfXw62Px2/nzj5OEAbAQguUUMdOgwHKd2lH5LoKWHmfQT6jxecEn26ak6NqPe2J3n+mPn4mrjPlwvCVWA6k4GjOlboMBoQwMmLIH6Mif6+x727dvdx29Wn02LdnP4/izKCyFXZqwgAAAAASUVORK5CYII=';
+
+// Déclaration des locales disponibles pour l'extension
+const AvailableLocales = ['en', 'fr', 'de'];
+
+//Traductions des textes utilisés par l'extension
+const Message = {
+	toggle_classification: {
+		'en': 'turn classification [CLASSIFICATION_STATE]',
+		'fr': 'définir la classification à [CLASSIFICATION_STATE]',
+		'de': 'Klassifikation auf setzen [CLASSIFICATION_STATE]'
+	},
+	on: {
+		'en': 'on',
+		'fr': 'démarrer',
+		'de': 'starten'
+	},
+	off: {
+		'en': 'off',
+		'fr': 'arrêter',
+		'de': 'stoppen'
+	},
+	videoToggle: {
+		'en': 'turn video [VIDEO_STATE]',
+		'fr': 'mettre caméra sur [VIDEO_STATE]',
+		'de': 'schalte Video [VIDEO_STATE]'
+	},
+	onfront: {
+		'en': 'front camera on',
+		'fr': 'allumer caméra avant',
+		'de': 'Frontkamera einschalten'
+	},
+	onback: {
+		'en': 'back camera on',
+		'fr': 'allumer caméra arrière',
+		'de': 'Rückfahrkamera einschalten'
+	},
+	offc: {
+		'en': 'camera off',
+		'fr': 'arrêter la caméra',
+		'de': 'Stopp Kamera'
+	},
+	video_on_flipped: {
+		'en': 'flip camera image',
+		'fr': 'retourner l\'image de la caméra',
+		'de': 'Kameraspiegel'
+	},
+	// URL du modèle de classification d'images Teachable Machine
+	image_classification_model_url: {
+		'en': 'TeachableMachine image classification model URL [URL]',
+		'fr': 'URL du modèle de classification d\'image TeachableMachine [URL]',
+		'de': 'URL des Bildklassifikationsmodells TeachableMachine [URL]'
+	},
+	image_classification_sample_model_url: {
+		'en': 'https://teachablemachine.withgoogle.com/models/',
+		'fr': 'https://teachablemachine.withgoogle.com/models/',
+		'de': 'https://teachablemachine.withgoogle.com/models/'
+	},
+	// URL du modèle de classification sonore Teachable Machine
+	sound_classification_model_url: {
+		'en': 'TeachableMachine sound classification model URL [URL]',
+		'fr': 'URL du modèle de classification de sons TeachableMachine [URL]',
+		'de': 'URL des TeachableMachine-Modells zur Klassifizierung von Klängen [URL]'
+	},
+	sound_classification_sample_model_url: {
+		'en': 'https://teachablemachine.withgoogle.com/models/',
+		'fr': 'https://teachablemachine.withgoogle.com/models/',
+		'de': 'https://teachablemachine.withgoogle.com/models/'
+	},
+	image_label: {
+		'en': 'image label',
+		'fr': 'étiquette d\'image',
+		'de': 'Bildbeschriftung'
+
+	},
+	sound_label: {
+		'en': 'sound label',
+		'fr': 'étiquette du son',
+		'de': 'Sound-Etikett'
+
+	},
+	when_received_block: {
+		'en': 'when received image label:[LABEL]',
+		'fr': 'quand je reçois l\'étiquette d\'image:[LABEL]',
+		'de': 'wenn das Bildetikett [LABEL] empfangen wird'
+
+	},
+	is_image_label_detected: {
+
+		'en': 'image [LABEL] detected',
+		'fr': 'image [LABEL] détectée',
+		'de': 'Bild [LABEL] erkannt'
+	},
+	is_sound_label_detected: {
+		'en': 'sound [LABEL] detected',
+		'fr': 'son [LABEL] détecté',
+		'de': 'Ton [LABEL] entdeckt'
+	},
+	image_label_confidence: {
+		'en': 'confidence of image [LABEL]',
+		'fr': 'indice de confiance image [LABEL]',
+		'de': 'Vertrauensindex Bild [LABEL]'
+
+	},
+	sound_label_confidence: {
+		'en': 'confidence of sound [LABEL]',
+		'fr': 'indice de confiance du son [LABEL]',
+		'de': 'Vertrauensindex Ton [LABEL]'
+	},
+	when_received_sound_label_block: {
+		'en': 'when received sound:[LABEL]',
+		'fr': 'quand je détecte le son:[LABEL]',
+		'de': 'wenn ich den Ton [LABEL] erkenne'
+	},
+	label_block: {
+		'en': 'label',
+		'fr': 'étiquette',
+		'de': 'Etikett'
+	},
+	any: {
+		'en': 'any',
+		'fr': 'n\'importe lequel',
+		'de': 'jede'
+	},
+	any_without_of: {
+		'en': 'any',
+		'fr': 'n\'importe lequel',
+		'de': 'jede'
+	},
+	all: {
+		'en': 'all',
+		'fr': 'tous',
+		'de': 'alle'
+	},
+
+	set_confidence_threshold: {
+		'en': 'set confidence threshold [CONFIDENCE_THRESHOLD]',
+		'fr': 'définir l\'indice de confiance à [CONFIDENCE_THRESHOLD]',
+		'de': 'Vertrauensschwelle festlegen [CONFIDENCE_THRESHOLD]'
+
+	},
+	get_confidence_threshold: {
+		'en': 'confidence threshold',
+		'fr': 'indice de confiance',
+		'de': 'Vertrauensschwelle'
+
+	},
+	set_classification_interval: {
+		'en': 'Label once every [CLASSIFICATION_INTERVAL] seconds',
+		'fr': 'étiquette une fois toutes les [CLASSIFICATION_INTERVAL] secondes',
+		'de': 'alle [CLASSIFICATION_INTERVAL] Sekunden ein Etikett'
+	}
+};
+
+// Définition de la classe principale pour gérer les blocs Scratch liés à Teachable Machine
+class Scratch3TMBlocks {
+
+	// Menu pour gérer l'état de la caméra vidéo
+	get VIDEO_MENU() {
+		return [
+			'onback', 'onfront', 'video_on_flipped', 'off'
+		].map(key => ({
+			text: Message[key][this.locale],
+			value: key
+		}));
+	}
+
+	// Constructeur initialisant la classe avec les paramètres par défaut
+	constructor(runtime) {
+		this.runtime = runtime;
+		this.locale = this.setLocale(); // Définit la langue de l'extension
+
+		this.interval = 1000; // Intervalle pour la classification
+		this.minInterval = 100; // Intervalle minimum pour la classification
+
+		// Définition d'un minuteur pour classifier les images vidéo à des intervalles réguliers
+		this.timer = setInterval(() => {
+			this.classifyVideoImage();
+		}, this.minInterval);
+
+		this.imageModelUrl = null; // URL du modèle de classification d'image
+		this.imageMetadata = null; // Métadonnées du modèle d'image
+		this.imageClassifier = null; // Classificateur d'image
+		this.initImageProbableLabels(); // Initialise les étiquettes probables pour l'image
+		this.confidenceThreshold = 0.5; // Seuil de confiance par défaut
+
+		this.soundModelUrl = null; // URL du modèle de classification sonore
+		this.soundMetadata = null; // Métadonnées du modèle sonore
+		this.soundClassifier = null; // Classificateur sonore
+		this.soundClassifierEnabled = false; // Indique si la classification sonore est activée
+		this.initSoundProbableLabels(); // Initialise les étiquettes probables pour les sons
+	}
+
+	// Initialise les étiquettes probables pour la classification d'image
+	initImageProbableLabels() {
+		this.imageProbableLabels = [];
+	}
+
+	// Initialise les étiquettes probables pour la classification sonore
+	initSoundProbableLabels() {
+		this.soundProbableLabels = [];
+	}
+
+	// Fournit les informations de l'extension pour l'intégration dans Scratch
+	getInfo() {
+		this.locale = this.setLocale(); // Définit la langue avant de retourner les informations
+
+		return {
+			id: 'tm',
+			name: 'Teachable Machine',
+			color1: '#365371',
+			color2: '#0f253b',
+			blockIconURI: blockIconURI,
+			blocks: [{
+					opcode: 'toggleClassification',
+					text: Message.toggle_classification[this.locale],
+					blockType: BlockType.COMMAND,
+					arguments: {
+						CLASSIFICATION_STATE: {
+							type: ArgumentType.STRING,
+							menu: 'classification_menu',
+							defaultValue: 'off'
+						}
+					}
+				},
+				'---',
+				'---',
+				{
+					opcode: 'videoToggle',
+					text: Message.videoToggle[this.locale],
+					blockType: BlockType.COMMAND,
+					arguments: {
+						VIDEO_STATE: {
+							type: ArgumentType.STRING,
+							menu: 'video_menu',
+							defaultValue: 'onback'
+						}
+					}
+				},
+				'---',
+				'---',
+				{
+					opcode: 'setImageClassificationModelURL',
+					text: Message.image_classification_model_url[this.locale],
+					blockType: BlockType.COMMAND,
+					arguments: {
+						URL: {
+							type: ArgumentType.STRING,
+							defaultValue: Message.image_classification_sample_model_url[this.locale]
+						}
+					}
+				},
+				{
+					opcode: 'whenReceived',
+					text: Message.when_received_block[this.locale],
+					blockType: BlockType.HAT,
+					arguments: {
+						LABEL: {
+							type: ArgumentType.STRING,
+							menu: 'received_menu',
+							defaultValue: Message.any[this.locale]
+						}
+					}
+				},
+				{
+					opcode: 'isImageLabelDetected',
+					text: Message.is_image_label_detected[this.locale],
+					blockType: BlockType.BOOLEAN,
+					arguments: {
+						LABEL: {
+							type: ArgumentType.STRING,
+							menu: 'image_labels_menu',
+							defaultValue: Message.any_without_of[this.locale]
+						}
+					}
+				},
+				{
+					opcode: 'imageLabelConfidence',
+					text: Message.image_label_confidence[this.locale],
+					blockType: BlockType.REPORTER,
+					disableMonitor: true,
+					arguments: {
+						LABEL: {
+							type: ArgumentType.STRING,
+							menu: 'image_labels_without_any_menu',
+							defaultValue: ''
+						}
+					}
+				},
+
+				{
+					opcode: 'getImageLabel',
+					text: Message.image_label[this.locale],
+					blockType: BlockType.REPORTER
+				},
+				'---',
+				'---',
+				'---',
+				{
+					opcode: 'setSoundClassificationModelURL',
+					text: Message.sound_classification_model_url[this.locale],
+					blockType: BlockType.COMMAND,
+					arguments: {
+						URL: {
+							type: ArgumentType.STRING,
+							defaultValue: Message.sound_classification_sample_model_url[this.locale]
+						}
+					}
+				},
+				{
+					opcode: 'whenReceivedSoundLabel',
+					text: Message.when_received_sound_label_block[this.locale],
+					blockType: BlockType.HAT,
+					arguments: {
+						LABEL: {
+							type: ArgumentType.STRING,
+							menu: 'received_sound_label_menu',
+							defaultValue: Message.any[this.locale]
+						}
+					}
+				},
+				{
+					opcode: 'isSoundLabelDetected',
+					text: Message.is_sound_label_detected[this.locale],
+					blockType: BlockType.BOOLEAN,
+					arguments: {
+						LABEL: {
+							type: ArgumentType.STRING,
+							menu: 'sound_labels_menu',
+							defaultValue: Message.any_without_of[this.locale]
+						}
+					}
+				},
+				{
+					opcode: 'soundLabelConfidence',
+					text: Message.sound_label_confidence[this.locale],
+					blockType: BlockType.REPORTER,
+					disableMonitor: true,
+					arguments: {
+						LABEL: {
+							type: ArgumentType.STRING,
+							menu: 'sound_labels_without_any_menu',
+							defaultValue: ''
+						}
+					}
+				},
+
+				{
+					opcode: 'getSoundLabel',
+					text: Message.sound_label[this.locale],
+					blockType: BlockType.REPORTER
+				},
+				'---',
+				'---',
+				'---',
+
+				{
+					opcode: 'setClassificationInterval',
+					text: Message.set_classification_interval[this.locale],
+					blockType: BlockType.COMMAND,
+					arguments: {
+						CLASSIFICATION_INTERVAL: {
+							type: ArgumentType.STRING,
+							menu: 'classification_interval_menu',
+							defaultValue: '1'
+						}
+					}
+				},
+				{
+					opcode: 'setConfidenceThreshold',
+					text: Message.set_confidence_threshold[this.locale],
+					blockType: BlockType.COMMAND,
+					arguments: {
+						CONFIDENCE_THRESHOLD: {
+							type: ArgumentType.NUMBER,
+							defaultValue: 0.5
+						}
+					}
+				},
+				{
+					opcode: 'getConfidenceThreshold',
+					text: Message.get_confidence_threshold[this.locale],
+					blockType: BlockType.REPORTER,
+					disableMonitor: true
+				}
+			],
+			menus: {
+				received_menu: {
+					acceptReporters: true,
+					items: 'getLabelsMenu'
+				},
+				image_labels_menu: {
+					acceptReporters: true,
+					items: 'getLabelsWithAnyWithoutOfMenu'
+				},
+				image_labels_without_any_menu: {
+					acceptReporters: true,
+					items: 'getLabelsWithoutAnyMenu'
+				},
+				received_sound_label_menu: {
+					acceptReporters: true,
+					items: 'getSoundLabelsWithoutBackgroundMenu'
+				},
+				sound_labels_menu: {
+					acceptReporters: true,
+					items: 'getSoundLabelsWithoutBackgroundWithAnyWithoutOfMenu'
+				},
+				sound_labels_without_any_menu: {
+					acceptReporters: true,
+					items: 'getSoundLabelsWithoutAnyMenu'
+				},
+				video_menu: {
+					acceptReporters: true,
+					items: this.VIDEO_MENU
+				},
+				classification_interval_menu: this.getClassificationIntervalMenu(),
+				classification_menu: this.getClassificationMenu()
+			}
+		};
+	}
+
+	// Fonction appelée lorsque l'étiquette d'image spécifiée est reçue
+	whenReceived(args) {
+		const label = this.getImageLabel();
+		if (args.LABEL === Message.any[this.locale]) {
+			return label !== '';
+		}
+		return label === args.LABEL;
+	}
+
+	// Fonction appelée lorsque l'étiquette sonore spécifiée est reçue
+	whenReceivedSoundLabel(args) {
+		if (!this.soundClassifierEnabled) {
+			return;
+		}
+
+		const label = this.getSoundLabel();
+		if (args.LABEL === Message.any[this.locale]) {
+			return label !== '';
+		}
+		return label === args.LABEL;
+	}
+
+	// Fonction pour vérifier si une étiquette est détectée pour l'image ou le son
+	isLabelDetected(args, getLabelFunc) {
+		const label = getLabelFunc();
+		return (args.LABEL === Message.any[this.locale]) ? label !== '' : label === args.LABEL;
+	}
+
+	isImageLabelDetected(args) {
+		return this.isLabelDetected(args, this.getImageLabel.bind(this));
+	}
+
+	isSoundLabelDetected(args) {
+		return this.isLabelDetected(args, this.getSoundLabel.bind(this));
+	}
+
+
+	// Fonction pour obtenir la confiance d'une étiquette d'image
+	imageLabelConfidence(args) {
+		if (args.LABEL === '') {
+			return 0;
+		}
+		const entry = this.imageProbableLabels.find(element => element.label === args.LABEL);
+		return (entry ? entry.confidence : 0);
+	}
+
+	// Fonction pour obtenir la confiance d'une étiquette sonore
+	soundLabelConfidence(args) {
+		if (!this.soundProbableLabels || this.soundProbableLabels.length === 0) return 0;
+
+		if (args.LABEL === '') {
+			return 0;
+		}
+		const entry = this.soundProbableLabels.find(element => element.label === args.LABEL);
+		return (entry ? entry.confidence : 0);
+	}
+
+	// Fonction pour charger un modèle de classification d'image à partir d'une URL
+	setImageClassificationModelURL(args) {
+		return this.loadImageClassificationModelFromURL(args.URL);
+	}
+
+	// Fonction pour charger un modèle de classification sonore à partir d'une URL
+	setSoundClassificationModelURL(args) {
+		return this.loadSoundClassificationModelFromURL(args.URL);
+	}
+
+	// Fonction pour charger un modèle de classification (image ou son) à partir d'une URL
+	loadModelFromURL(url, type) {
+		return new Promise(resolve => {
+			fetch(`${url}metadata.json`)
+				.then(res => res.json())
+				.then(metadata => {
+					const modelUrl = type === 'image' ? this.imageModelUrl : this.soundModelUrl;
+					const modelMetadata = type === 'image' ? this.imageMetadata : this.soundMetadata;
+					if (url === modelUrl && (new Date(metadata.timeStamp).getTime() === new Date(modelMetadata.timeStamp).getTime())) {
+						log.info(`${type} model already loaded: ${url}`);
+						resolve();
+					} else {
+						const loadFunc = type === 'image' ? ml5.imageClassifier : ml5.soundClassifier;
+						loadFunc(`${url}model.json`)
+							.then(classifier => {
+								if (type === 'image') {
+									this.imageModelUrl = url;
+									this.imageMetadata = metadata;
+									this.imageClassifier = classifier;
+									this.initImageProbableLabels();
+								} else {
+									this.soundModelUrl = url;
+									this.soundMetadata = metadata;
+									this.soundClassifier = classifier;
+									this.initSoundProbableLabels();
+									this.soundClassifierEnabled = true;
+									this.classifySound();
+								}
+								log.info(`${type} model loaded from: ${url}`);
+							})
+							.catch(error => log.warn(error))
+							.finally(() => resolve());
+					}
+				})
+				.catch(error => log.warn(error) || resolve());
+		});
+	}
+
+	// Charge un modèle de classification d'image à partir d'une URL donnée
+	loadImageClassificationModelFromURL(url) {
+		return this.loadModelFromURL(url, 'image');
+	}
+
+	// Charge un modèle de classification sonore à partir d'une URL donnée
+	loadSoundClassificationModelFromURL(url) {
+		return this.loadModelFromURL(url, 'sound');
+	}
+
+	// Menu pour les étiquettes d'images. Retourne une liste des labels disponibles, ou 'any' s'il n'y en a pas
+	getLabelsMenu() {
+		let items = [Message.any[this.locale]];
+		if (!this.imageMetadata) return items;
+		items = items.concat(this.imageMetadata.labels);
+		return items;
+	}
+
+	// Menu des étiquettes d'images incluant 'any' et 'any_without_of'
+	getLabelsWithAnyWithoutOfMenu() {
+		let items = [Message.any_without_of[this.locale]];
+		if (!this.imageMetadata) return items;
+		items = items.concat(this.imageMetadata.labels);
+		return items;
+	}
+
+	// Menu pour les étiquettes sonores. Retourne une liste des labels sonores ou 'any' s'il n'y en a pas
+	getSoundLabelsMenu() {
+		let items = [Message.any[this.locale]];
+		if (!this.soundMetadata) return items;	// Retourne 'any' si les métadonnées de sons sont absentes
+		items = items.concat(this.soundMetadata.wordLabels);	 // Ajoute les étiquettes de sons disponibles
+		return items;
+	}
+
+	// Retourne les étiquettes d'images sans 'any' comme option
+	getLabelsWithoutAnyMenu() {
+		let items = [''];	// Initialise avec une chaîne vide
+		if (this.imageMetadata) {
+			items = items.concat(this.imageMetadata.labels);	 // Ajoute les étiquettes disponibles si présentes
+		}
+		return items;
+	}
+
+	// Retourne les étiquettes sonores sans 'any' comme option
+	getSoundLabelsWithoutAnyMenu() {
+		if (this.soundMetadata) {
+			return this.soundMetadata.wordLabels;	// Retourne les étiquettes sonores si présentes
+		} else {
+			return [''];	// Retourne une chaîne vide si pas de métadonnées
+		}
+	}
+
+	// Retourne les étiquettes sonores sans le bruit de fond comme option
+	getSoundLabelsWithoutBackgroundMenu() {
+		let items = [Message.any[this.locale]];	// Inclut l'option 'any'
+		if (!this.soundMetadata) return items;	// Retourne 'any' si pas de métadonnées sonores
+		let arr = this.soundMetadata.wordLabels;	// Récupère les étiquettes sonores disponibles
+		for (let i = 0; i < arr.length; i++) {
+			if (arr[i] !== '_background_noise_') {	// Exclut le bruit de fond des options
+				items.push(arr[i]);
+			}
+		}
+		return items;
+	}
+
+	// Retourne les étiquettes sonores sans bruit de fond, avec 'any_without_of' comme option
+	getSoundLabelsWithoutBackgroundWithAnyWithoutOfMenu() {
+		let items = [Message.any_without_of[this.locale]];	// Inclut 'any_without_of'
+		if (!this.soundMetadata) return items;
+		let arr = this.soundMetadata.wordLabels;
+		for (let i = 0; i < arr.length; i++) {
+			if (arr[i] !== '_background_noise_') {
+				items.push(arr[i]);
+			}
+		}
+		return items;
+	}
+
+	// Retourne l'étiquette avec la confiance la plus élevée parmi les résultats probables
+	getMostProbableOne(probabilities) {
+		if (probabilities.length === 0) return null;	// Retourne null si aucune probabilité n'existe
+		let mostOne = probabilities[0];	// Initialise avec le premier élément
+		probabilities.forEach(clss => {
+			if (clss.confidence > mostOne.confidence) {	// Compare et garde l'élément avec la plus haute confiance
+				mostOne = clss;
+			}
+		});
+		return mostOne;	// Retourne l'élément avec la plus haute confiance
+	}
+
+	// Fonction pour classifier une image donnée (par exemple, une vidéo)
+	classifyImage(input) {
+		if (!this.imageMetadata || !this.imageClassifier) {
+			this._isImageClassifying = false;
+			return Promise.resolve([]);	 // Si pas de modèle ou de métadonnées, retourne une promesse vide
+		}
+		this._isImageClassifying = true;
+		return this.imageClassifier.classify(input)	 // Effectue la classification sur l'image fournie
+			.then(result => {
+				this.imageProbableLabels = result.slice();	// Stocke les résultats de classification
+				this.imageProbableLabelsUpdated = true;	// Indique que les résultats ont été mis à jour
+				return result;
+			})
+			.finally(() => {
+				setTimeout(() => {
+					 // Réinitialise les étiquettes après l'intervalle de classification
+					this.initImageProbableLabels();
+					this._isImageClassifying = false;
+				}, this.interval);
+			});
+	}
+
+	// Fonction pour classifier les sons continuellement
+	classifySound() {
+		this.soundClassifier.classify((err, result) => {
+			if (this.soundClassifierEnabled && result) {
+				this.soundProbableLabels = result.slice(); // Stocke les résultats probables
+				setTimeout(() => {
+					// Réinitialise les étiquettes après l'intervalle
+					this.initSoundProbableLabels();
+				}, this.interval);
+			}
+			if (err) {
+				console.error(err);	// Affiche une erreur si une erreur de classification sonore se produit
+			}
+		});
+	}
+
+	// Retourne l'étiquette d'image avec la plus haute confiance, ou une chaîne vide si aucune n'est suffisante
+	getImageLabel() {
+		if (!this.imageProbableLabels || this.imageProbableLabels.length === 0) return '';	// Si pas d'étiquettes, retourne vide
+		const mostOne = this.getMostProbableOne(this.imageProbableLabels);	// Obtient l'étiquette avec la confiance maximale
+		return (mostOne.confidence >= this.confidenceThreshold) ? mostOne.label : '';	// Retourne l'étiquette si la confiance est assez élevée
+	}
+
+	// Retourne l'étiquette sonore avec la plus haute confiance, ou une chaîne vide si aucune n'est suffisante
+	getSoundLabel() {
+		if (!this.soundProbableLabels || this.soundProbableLabels.length === 0) return ''; // Si pas d'étiquettes, retourne vide
+		const mostOne = this.getMostProbableOne(this.soundProbableLabels);	// Obtient l'étiquette avec la confiance maximale
+		return (mostOne.confidence >= this.confidenceThreshold) ? mostOne.label : '';// Retourne l'étiquette si la confiance est assez élevée
+	}
+
+	// Définit le seuil de confiance pour la classification
+	setConfidenceThreshold(args) {
+		let threshold = Cast.toNumber(args.CONFIDENCE_THRESHOLD);	// Convertit l'argument en nombre
+		threshold = MathUtil.clamp(threshold, 0, 1); // Limite la valeur du seuil entre 0 et 1
+		this.confidenceThreshold = threshold; // Met à jour le seuil de confiance
+	}
+
+	// Retourne le seuil de confiance actuellement défini
+	getConfidenceThreshold() {
+		return this.confidenceThreshold;
+	}
+
+	// Fonction pour activer ou désactiver la classification d'images et de sons
+	toggleClassification(args) {
+		const state = args.CLASSIFICATION_STATE;
+		if (this.timer) {
+			clearTimeout(this.timer);
+		}
+		this.soundClassifierEnabled = false;
+		if (state === 'on') {	
+
+			if (!this.runtime.ioDevices.video.videoReady) {
+				alert('Il faut d\'abord activer la vidéo');
+			} else {
+				this.video = this.runtime.ioDevices.video.provider.video;
+				this.timer = setInterval(() => {
+					this.classifyVideoImage();
+				}, this.minInterval);
+				this.soundClassifierEnabled = true;
+			}
+		}
+	}
+
+	// Définit l'intervalle de classification en secondes
+	setClassificationInterval(args) {
+		if (this.timer) {
+			clearTimeout(this.timer);
+		}
+		this.interval = args.CLASSIFICATION_INTERVAL * 1000;
+		this.timer = setInterval(() => {
+			this.classifyVideoImage();
+		}, this.minInterval);
+	}
+
+	// Fonction pour classifier une image de la vidéo en cours
+	classifyVideoImage() {
+		if (this._isImageClassifying) return Promise.resolve([]);
+		return this.classifyImage(this.video);
+	}
+
+	// Menu des intervalles de classification disponibles
+	getClassificationIntervalMenu() {
+		return {
+			acceptReporters: true,
+			items: [{
+					text: '1',
+					value: '1'
+				},
+				{
+					text: '0.5',
+					value: '0.5'
+				},
+				{
+					text: '0.2',
+					value: '0.2'
+				},
+				{
+					text: '0.1',
+					value: '0.1'
+				}
+			]
+		};
+	}
+
+	// Menu pour activer ou désactiver la classification
+	getClassificationMenu() {
+		return [{
+				text: Message.off[this.locale],
+				value: 'off'
+			},
+			{
+				text: Message.on[this.locale],
+				value: 'on'
+			}
+		];
+	}
+
+	// Fonction permettant d'activer la vidéo et de changer de caméra
+	videoToggle(args) {
+		switch (args.VIDEO_STATE) {
+			case 'off':
+				this.runtime.ioDevices.video.disableVideo();
+				if (this.timer) {
+					clearTimeout(this.timer);
+				}
+				this.soundClassifierEnabled = false;
+				break;
+			case 'onback':
+				this.runtime.ioDevices.video.enableVideo('environment');
+				this.runtime.ioDevices.video.mirror = false;
+				this.active = true;
+				break;
+			case 'onfront':
+				this.runtime.ioDevices.video.enableVideo('user');
+				this.runtime.ioDevices.video.mirror = true;
+				this.active = true;
+				break;
+			default:
+				this.runtime.ioDevices.video.mirror = !this.runtime.ioDevices.video.mirror;
+		}
+
+	}
+
+	// Fonction permettant de définir la langue de l'extension en fonction de la langue définit dans Scratch.
+	// Si la traduction d'une langue n'est pas disponible dans l'extension, c'est l'anglais qui est choisi
+	setLocale() {
+		let locale = formatMessage.setup().locale;
+		return AvailableLocales.includes(locale) ? locale : 'en';
+	}
+}
+
+module.exports = Scratch3TMBlocks;
\ No newline at end of file
diff --git a/node_modules/scratch-vm/src/io/video.js b/node_modules/scratch-vm/src/io/video.js
index 23dce8b..f1b62a5 100644
--- a/node_modules/scratch-vm/src/io/video.js
+++ b/node_modules/scratch-vm/src/io/video.js
@@ -82,9 +82,9 @@ class Video {
      *
      * @return {Promise.<Video>} resolves a promise to this IO device when video is ready.
      */
-    enableVideo () {
+    enableVideo (cam) {
         if (!this.provider) return null;
-        return this.provider.enableVideo().then(() => this._setupPreview());
+        return this.provider.enableVideo(cam).then(() => this._setupPreview());
     }
 
     /**
diff --git a/node_modules/scratch-vm/src/virtual-machine.js b/node_modules/scratch-vm/src/virtual-machine.js
index 64ad793..0f78b4f 100644
--- a/node_modules/scratch-vm/src/virtual-machine.js
+++ b/node_modules/scratch-vm/src/virtual-machine.js
@@ -36,6 +36,7 @@ const CORE_EXTENSIONS = [
     // 'operators',
     // 'variables',
     // 'myBlocks'
+    'pen'
 ];
 
 /**
